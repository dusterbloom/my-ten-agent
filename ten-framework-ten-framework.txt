Directory structure:
└── playground/
    ├── README.md
    ├── components.json
    ├── Dockerfile
    ├── LICENSE
    ├── next-env.d.ts
    ├── next.config.mjs
    ├── package.json
    ├── postcss.config.js
    ├── tailwind.config.js
    ├── tsconfig.json
    ├── .dockerignore
    └── src/
        ├── middleware.tsx
        ├── app/
        │   ├── global.css
        │   ├── layout.tsx
        │   ├── page.tsx
        │   └── api/
        │       └── agents/
        │           └── start/
        │               └── route.tsx
        ├── common/
        │   ├── constant.ts
        │   ├── graph.ts
        │   ├── hooks.ts
        │   ├── index.ts
        │   ├── mock.ts
        │   ├── moduleConfig.ts
        │   ├── request.ts
        │   ├── storage.ts
        │   └── utils.ts
        ├── components/
        │   ├── Agent/
        │   │   ├── AudioVisualizer.tsx
        │   │   ├── AvatarTrulience.tsx
        │   │   ├── Camera.tsx
        │   │   ├── Microphone.tsx
        │   │   ├── StreamPlayer.tsx
        │   │   ├── View.tsx
        │   │   └── VoicePresetSelect.tsx
        │   ├── authInitializer/
        │   │   └── index.tsx
        │   ├── Button/
        │   │   └── LoadingButton.tsx
        │   ├── Chat/
        │   │   ├── ChatCard.tsx
        │   │   ├── ChatCfgGraphSelect.tsx
        │   │   ├── ChatCfgModuleSelect.tsx
        │   │   ├── ChatCfgPropertySelect.tsx
        │   │   ├── ChatCfgTrulienceSetting.tsx
        │   │   ├── MessageList.tsx
        │   │   └── PdfSelect.tsx
        │   ├── Dynamic/
        │   │   ├── NetworkIndicator.tsx
        │   │   └── RTCCard.tsx
        │   ├── Icon/
        │   │   └── index.tsx
        │   ├── icons/
        │   │   ├── index.tsx
        │   │   ├── types.ts
        │   │   ├── cam/
        │   │   │   └── index.tsx
        │   │   ├── colorPicker/
        │   │   │   └── index.tsx
        │   │   ├── github/
        │   │   │   └── index.tsx
        │   │   ├── info/
        │   │   │   └── index.tsx
        │   │   ├── logo/
        │   │   │   └── index.tsx
        │   │   ├── mic/
        │   │   │   └── index.tsx
        │   │   ├── network/
        │   │   │   └── index.tsx
        │   │   ├── pdf/
        │   │   │   └── index.tsx
        │   │   ├── transcription/
        │   │   │   └── index.tsx
        │   │   └── voice/
        │   │       └── index.tsx
        │   ├── Layout/
        │   │   ├── Action.tsx
        │   │   ├── Header.module.css
        │   │   ├── Header.tsx
        │   │   └── HeaderComponents.tsx
        │   └── ui/
        │       ├── avatar.tsx
        │       ├── button.tsx
        │       ├── card.tsx
        │       ├── checkbox.tsx
        │       ├── dialog.tsx
        │       ├── dropdown.tsx
        │       ├── form.tsx
        │       ├── input.tsx
        │       ├── label.tsx
        │       ├── popover.tsx
        │       ├── progress.tsx
        │       ├── select.tsx
        │       ├── sheet.tsx
        │       ├── sonner.tsx
        │       ├── switch.tsx
        │       ├── tabs.tsx
        │       ├── textarea.tsx
        │       └── tooltip.tsx
        ├── lib/
        │   └── utils.ts
        ├── manager/
        │   ├── events.ts
        │   ├── index.ts
        │   ├── types.ts
        │   ├── rtc/
        │   │   ├── index.ts
        │   │   ├── rtc.ts
        │   │   └── types.ts
        │   └── rtm/
        │       └── index.ts
        ├── protobuf/
        │   ├── SttMessage.js
        │   ├── SttMessage.proto
        │   └── SttMessage_es6.js
        ├── store/
        │   ├── index.ts
        │   ├── provider/
        │   │   └── index.tsx
        │   └── reducers/
        │       └── global.ts
        └── types/
            └── index.ts

================================================
FILE: ai_agents/playground/README.md
================================================
## Playground

[![License](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](../LICENSE)
[![Node.js Version](https://img.shields.io/badge/node-%3E%3D20-brightgreen)](package.json)
[![TypeScript](https://img.shields.io/badge/TypeScript-5.0-blue)](tsconfig.json)
[![React](https://img.shields.io/badge/React-18-blue)](package.json)
[![Next.js 15](https://img.shields.io/badge/Next.js-15-black)](package.json)
[![shadcn/ui](https://img.shields.io/badge/UI-shadcn%2Fui-black)](https://ui.shadcn.com)
[![pnpm](https://img.shields.io/badge/pnpm-9.12.3-blue)](package.json)

Local playground for Ten Agent.

## Local Development

### Prerequisites

- Node.js >= 20
- [pnpm 9.12.3](https://pnpm.io/installation)

### Run local server

First, make sure you have started the Ten Agent server by following the instructions in the [root README](../README.md#3-start-agent-development-containers).

Then, you can start the playground web UI by running the following steps.

### Install dependencies

```bash
# cd ./playground
# install dependencies
# corepack enable
pnpm install
```

### Run

```bash
# run
pnpm dev
```



================================================
FILE: ai_agents/playground/components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/app/global.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}


================================================
FILE: ai_agents/playground/Dockerfile
================================================
# syntax=docker.io/docker/dockerfile:1

FROM oven/bun:alpine AS base

# 1. Install dependencies only when needed
FROM base AS deps
# Check https://github.com/nodejs/docker-node/tree/b4117f9333da4138b03a546ec926ef50a31506c3#nodealpine to understand why libc6-compat might be needed.
RUN apk add --no-cache libc6-compat

WORKDIR /app

# Install dependencies based on the preferred package manager
COPY package.json bun.lock ./
RUN \
  if [ -f yarn.lock ]; then corepack enable yarn && yarn --immutable; \
  elif [ -f package-lock.json ]; then npm ci; \
  elif [ -f pnpm-lock.yaml ]; then npm install -g pnpm@10.2.0 && pnpm i; \
  elif [ -f bun.lockb ]; then bun i --frozen-lockfile; \
  elif [ -f bun.lock ]; then bun i --frozen-lockfile; \
  else echo "Lockfile not found." && exit 1; \
  fi

# 2. Rebuild the source code only when needed
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Next.js collects completely anonymous telemetry data about general usage.
# Learn more here: https://nextjs.org/telemetry
# Uncomment the following line in case you want to disable telemetry during the build.
ENV NEXT_TELEMETRY_DISABLED=1

RUN \
  if [ -f yarn.lock ]; then corepack enable yarn && yarn run build; \
  elif [ -f package-lock.json ]; then npm run build; \
  elif [ -f pnpm-lock.yaml ]; then npm install -g pnpm@10.2.0 && pnpm run build; \
  elif [ -f bun.lockb ]; then bun run build; \
  elif [ -f bun.lock ]; then bun run build; \
  else echo "Lockfile not found." && exit 1; \
  fi

# 3. Production image, copy all the files and run next
FROM base AS runner
WORKDIR /app

# Uncomment the following line in case you want to disable telemetry during runtime.
ENV NEXT_TELEMETRY_DISABLED=1

ENV NODE_ENV=production

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

# COPY --from=builder /app/public ./public

# Set the correct permission for prerender cache
RUN mkdir .next
RUN chown nextjs:nodejs .next

# Automatically leverage output traces to reduce image size
# https://nextjs.org/docs/advanced-features/output-file-tracing
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

ENV PORT=3000

# server.js is created by next build from the standalone output
# https://nextjs.org/docs/pages/api-reference/next-config-js/output
CMD HOSTNAME="0.0.0.0" node server.js



================================================
FILE: ai_agents/playground/LICENSE
================================================
MIT License

Copyright (c) 2024 Agora Community

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: ai_agents/playground/next-env.d.ts
================================================
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.



================================================
FILE: ai_agents/playground/next.config.mjs
================================================
/** @type {import('next').NextConfig} */

const nextConfig = {
  // basePath: '/ai-agent',
  // output: 'export',
  output: 'standalone',
  reactStrictMode: false,
  webpack(config) {
    // Grab the existing rule that handles SVG imports
    const fileLoaderRule = config.module.rules.find((rule) =>
      rule.test?.test?.('.svg'),
    )

    config.module.rules.push(
      // Reapply the existing rule, but only for svg imports ending in ?url
      {
        ...fileLoaderRule,
        test: /\.svg$/i,
        resourceQuery: /url/, // *.svg?url
      },
      // Convert all other *.svg imports to React components
      {
        test: /\.svg$/i,
        issuer: fileLoaderRule.issuer,
        resourceQuery: { not: [...fileLoaderRule.resourceQuery.not, /url/] }, // exclude if *.svg?url
        use: ['@svgr/webpack'],
      },
    )

    // Modify the file loader rule to ignore *.svg, since we have it handled now.
    fileLoaderRule.exclude = /\.svg$/i

    return config
  }
};

export default nextConfig;



================================================
FILE: ai_agents/playground/package.json
================================================
{
  "name": "ten_agent_playground",
  "version": "0.5.0",
  "private": true,
  "engines": {
    "node": ">=20"
  },
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "proto": "pbjs -t json-module -w commonjs -o src/protobuf/SttMessage.js src/protobuf/SttMessage.proto"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.9.1",
    "@radix-ui/react-avatar": "^1.1.1",
    "@radix-ui/react-checkbox": "^1.1.2",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-popover": "^1.1.2",
    "@radix-ui/react-progress": "^1.1.2",
    "@radix-ui/react-select": "^2.1.2",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.1",
    "@radix-ui/react-tabs": "^1.1.1",
    "@radix-ui/react-tooltip": "^1.1.3",
    "@reduxjs/toolkit": "^2.2.3",
    "agora-rtc-sdk-ng": "^4.21.0",
    "agora-rtm": "^2.2.0",
    "axios": "^1.7.7",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "lucide-react": "^0.454.0",
    "next": "^15.0.3",
    "next-themes": "^0.4.3",
    "protobufjs": "^7.2.5",
    "react": "^18",
    "react-colorful": "^5.6.1",
    "react-dom": "^18",
    "react-hook-form": "^7.53.1",
    "react-redux": "^9.1.0",
    "redux": "^5.0.1",
    "sonner": "^1.7.0",
    "tailwind-merge": "^2.5.4",
    "tailwindcss-animate": "^1.0.7",
    "trulience-sdk": "https://trulience.com/release/prod/latest/trulience-sdk.tar.gz",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@minko-fe/postcss-pxtoviewport": "^1.3.2",
    "@svgr/webpack": "^8.1.0",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@types/react-redux": "^7.1.22",
    "autoprefixer": "^10.4.20",
    "eslint": "^8",
    "eslint-config-next": "^15.0.3",
    "postcss": "^8.4.47",
    "protobufjs-cli": "^1.1.2",
    "sass": "^1.77.5",
    "tailwindcss": "^3.4.14",
    "typescript": "^5"
  },
  "packageManager": "pnpm@10.2.0"
}


================================================
FILE: ai_agents/playground/postcss.config.js
================================================
/** @type {import('postcss-load-config').Config} */
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
    "@minko-fe/postcss-pxtoviewport": {
      viewportWidth: 375,
      exclude: /node_modules/,
      include: /\/src\/platform\/mobile\//,
    },
  },
};



================================================
FILE: ai_agents/playground/tailwind.config.js
================================================
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",

    // Or if using `src` directory:
    "./src/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      colors: {
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        chart: {
          1: "hsl(var(--chart-1))",
          2: "hsl(var(--chart-2))",
          3: "hsl(var(--chart-3))",
          4: "hsl(var(--chart-4))",
          5: "hsl(var(--chart-5))",
        },
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
};



================================================
FILE: ai_agents/playground/tsconfig.json
================================================
{
  "compilerOptions": {
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./src/*"
      ]
    },
    "target": "ES2017"
  },
  "include": [
    "svgr.d.ts",
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}



================================================
FILE: ai_agents/playground/.dockerignore
================================================
.git
.next
node_modules



================================================
FILE: ai_agents/playground/src/middleware.tsx
================================================
// middleware.js
import { NextRequest, NextResponse } from 'next/server';

const { AGENT_SERVER_URL, TEN_DEV_SERVER_URL } = process.env;

// Check if environment variables are available
if (!AGENT_SERVER_URL) {
    throw "Environment variables AGENT_SERVER_URL are not available";
}

if (!TEN_DEV_SERVER_URL) {
    throw "Environment variables TEN_DEV_SERVER_URL are not available";
}

export async function middleware(req: NextRequest) {
    const { pathname } = req.nextUrl;
    const url = req.nextUrl.clone();


    if (pathname.startsWith(`/api/agents/`)) {
        // if (!pathname.startsWith('/api/agents/start')) {
        // Proxy all other agents API requests
        url.href = `${AGENT_SERVER_URL}${pathname.replace('/api/agents/', '/')}`;

        try {
            const body = await req.json();
            console.log(`Request to ${pathname} with body ${JSON.stringify(body)}`);
        } catch (e) {
            console.log(`Request to ${pathname} ${e}`);
        }

        // console.log(`Rewriting request to ${url.href}`);
        return NextResponse.rewrite(url);
        // } else {
        //     return NextResponse.next();
        // }
    } else if (pathname.startsWith(`/api/vector/`)) {

        // Proxy all other documents requests
        url.href = `${AGENT_SERVER_URL}${pathname.replace('/api/vector/', '/vector/')}`;

        // console.log(`Rewriting request to ${url.href}`);
        return NextResponse.rewrite(url);
    } else if (pathname.startsWith(`/api/token/`)) {
        // Proxy all other documents requests
        url.href = `${AGENT_SERVER_URL}${pathname.replace('/api/token/', '/token/')}`;

        // console.log(`Rewriting request to ${url.href}`);
        return NextResponse.rewrite(url);
    } else if (pathname.startsWith('/api/dev/')) {

        if (pathname.startsWith('/api/dev/v1/addons/default-properties')) {
            url.href = `${AGENT_SERVER_URL}/dev-tmp/addons/default-properties`;
            console.log(`Rewriting request to ${url.href}`);
            return NextResponse.rewrite(url);
        }

        url.href = `${TEN_DEV_SERVER_URL}${pathname.replace('/api/dev/', '/api/designer/')}`;

        // console.log(`Rewriting request to ${url.href}`);
        return NextResponse.rewrite(url);
    } else {
        return NextResponse.next();
    }

}


================================================
FILE: ai_agents/playground/src/app/global.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

html,
body {
  background-color: #0f0f11;
  font-family: "PingFang SC";
  height: 100%;
}

a {
  color: inherit;
  text-decoration: none;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
  }
  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* Custom Scrollbar Styles */
::-webkit-scrollbar {
  width: 10px;
}

::-webkit-scrollbar-track {
  background: transparent;
  border-radius: 5px;
}

::-webkit-scrollbar-thumb {
  background: hsl(var(--muted));
  border-radius: 5px;
}

::-webkit-scrollbar-thumb:hover {
  background: hsl(var(--muted-foreground));
}

/* For Firefox */
* {
  scrollbar-width: thin;
  scrollbar-color: hsl(var(--muted)) transparent;
}



================================================
FILE: ai_agents/playground/src/app/layout.tsx
================================================
// import { ConfigProvider } from "antd";
import { StoreProvider } from "@/store"
import type { Metadata, Viewport } from "next"
import { Toaster } from "@/components/ui/sonner"

import "./global.css"

export const metadata: Metadata = {
  title: "TEN Agent | Real-Time Multimodal AI Agent",
  description:
    "TEN Agent is an open-source multimodal AI agent that can speak, see, and access a knowledge base(RAG).",
  appleWebApp: {
    capable: true,
    statusBarStyle: "black",
  },
}

export const viewport: Viewport = {
  width: "device-width",
  initialScale: 1,
  minimumScale: 1,
  maximumScale: 1,
  userScalable: false,
  viewportFit: "cover",
}

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  return (
    <html lang="en">
      <body className="dark">
        {/* <ConfigProvider
          theme={{
            components: {
              Select: {
                selectorBg: "#181A1D",
              },
            },
          }}
        > */}
        <StoreProvider>{children}</StoreProvider>
        {/* </ConfigProvider> */}
        <Toaster richColors closeButton theme="dark" />
      </body>
    </html>
  )
}



================================================
FILE: ai_agents/playground/src/app/page.tsx
================================================
"use client";

import dynamic from "next/dynamic";

import AuthInitializer from "@/components/authInitializer";
import { useAppSelector, EMobileActiveTab, useIsCompactLayout } from "@/common";
import Header from "@/components/Layout/Header";
import Action from "@/components/Layout/Action";
import { cn } from "@/lib/utils";
import Avatar from "@/components/Agent/AvatarTrulience";
import React from "react";
import { IRtcUser, IUserTracks } from "@/manager";
import { IMicrophoneAudioTrack } from "agora-rtc-sdk-ng";

const DynamicRTCCard = dynamic(() => import("@/components/Dynamic/RTCCard"), {
  ssr: false,
});
const DynamicChatCard = dynamic(() => import("@/components/Chat/ChatCard"), {
  ssr: false,
});

export default function Home() {
  const mobileActiveTab = useAppSelector(
    (state) => state.global.mobileActiveTab
  );
  const trulienceSettings = useAppSelector((state) => state.global.trulienceSettings);

  const isCompactLayout = useIsCompactLayout();
  const useTrulienceAvatar = trulienceSettings.enabled;
  const avatarInLargeWindow = trulienceSettings.avatarDesktopLargeWindow;
  const [remoteuser, setRemoteUser] = React.useState<IRtcUser>()

  React.useEffect(() => {
    const { rtcManager } = require("../manager/rtc/rtc");
    rtcManager.on("remoteUserChanged", onRemoteUserChanged);
    return () => {
      rtcManager.off("remoteUserChanged", onRemoteUserChanged);
    };
  }, []);

  const onRemoteUserChanged = (user: IRtcUser) => {
    if (useTrulienceAvatar) {
      user.audioTrack?.stop();
    }
    if (user.audioTrack) {
      setRemoteUser(user)
    } 
  }

  return (
    <AuthInitializer>
      <div className="relative mx-auto flex flex-1 min-h-screen flex-col md:h-screen">
        <Header className="h-[60px]" />
        <Action />
        <div className={cn(
          "mx-2 mb-2 flex h-full max-h-[calc(100vh-108px-24px)] flex-col md:flex-row md:gap-2 flex-1",
          {
            ["flex-col-reverse"]: avatarInLargeWindow && isCompactLayout
          }
        )}>
          <DynamicRTCCard
            className={cn(
              "m-0 w-full rounded-b-lg bg-[#181a1d] md:w-[480px] md:rounded-lg flex-1 flex",
              {
                ["hidden md:flex"]: mobileActiveTab === EMobileActiveTab.CHAT,
              }
            )}
          />

          {(!useTrulienceAvatar || isCompactLayout || !avatarInLargeWindow) && (
            <DynamicChatCard
              className={cn(
                "m-0 w-full rounded-b-lg bg-[#181a1d] md:rounded-lg flex-auto",
                {
                  ["hidden md:flex"]: mobileActiveTab === EMobileActiveTab.AGENT,
                }
              )}
            />
          )}

          {(useTrulienceAvatar && avatarInLargeWindow) && (
            <div className={cn(
              "w-full",
              {
                ["h-60 flex-auto p-1 bg-[#181a1d]"]: isCompactLayout,
                ["hidden md:block"]: mobileActiveTab === EMobileActiveTab.CHAT,
              }
            )}>
              <Avatar audioTrack={remoteuser?.audioTrack} />
            </div>
          )}

        </div>
      </div>
    </AuthInitializer>
  );
}



================================================
FILE: ai_agents/playground/src/app/api/agents/start/route.tsx
================================================
import { NextRequest, NextResponse } from 'next/server';
import axios from 'axios';

/**
 * Handles the POST request to start an agent.
 * 
 * @param request - The NextRequest object representing the incoming request.
 * @returns A NextResponse object representing the response to be sent back to the client.
 */
export async function POST(request: NextRequest) {
  try {
    const { AGENT_SERVER_URL } = process.env;

    // Check if environment variables are available
    if (!AGENT_SERVER_URL) {
      throw "Environment variables are not available";
    }

    const body = await request.json();
    const {
      request_id,
      channel_name,
      user_uid,
      graph_name,
      language,
      voice_type,
      properties
    } = body;

    // Send a POST request to start the agent
    const response = await axios.post(`${AGENT_SERVER_URL}/start`, {
      request_id,
      channel_name,
      user_uid,
      graph_name,
      // Get the graph properties based on the graph name, language, and voice type
      properties: properties,
    });

    const responseData = response.data;

    return NextResponse.json(responseData, { status: response.status });
  } catch (error) {
    if (error instanceof Response) {
      const errorData = await error.json();
      return NextResponse.json(errorData, { status: error.status });
    } else {
      return NextResponse.json({ code: "1", data: null, msg: "Internal Server Error" }, { status: 500 });
    }
  }
}


================================================
FILE: ai_agents/playground/src/common/constant.ts
================================================
import {
  IOptions,
  ColorItem,
  LanguageOptionItem,
  VoiceOptionItem,
  GraphOptionItem,
  ITrulienceSettings,
} from "@/types";
export const GITHUB_URL = "https://github.com/TEN-framework/TEN-Agent";
export const OPTIONS_KEY = "__options__";
export const DEFAULT_OPTIONS: IOptions = {
  channel: "",
  userName: "",
  userId: 0,
  appId: "",
  token: "",
};
export const DESCRIPTION =
  "TEN Agent is an open-source multimodal AI agent that can speak, see, and access a knowledge base(RAG).";
export const LANGUAGE_OPTIONS: LanguageOptionItem[] = [
  {
    label: "English",
    value: "en-US",
  },
  {
    label: "Chinese",
    value: "zh-CN",
  },
  {
    label: "Korean",
    value: "ko-KR",
  },
  {
    label: "Japanese",
    value: "ja-JP",
  },
];
export const GRAPH_OPTIONS: GraphOptionItem[] = [
  {
    label: "Voice Agent - OpenAI LLM + Azure TTS",
    value: "va_openai_azure",
  },
  {
    label: "Voice Agent with Vision - OpenAI LLM + Azure TTS",
    value: "camera_va_openai_azure",
  },
  //{
  //  label: "Voice Agent with Knowledge - RAG + Qwen LLM + Cosy TTS",
  //  value: "va_qwen_rag"
  // },
];

export const isRagGraph = (graphName: string) => {
  return graphName === "va_qwen_rag";
};

export const VOICE_OPTIONS: VoiceOptionItem[] = [
  {
    label: "Male",
    value: "male",
  },
  {
    label: "Female",
    value: "female",
  },
];

export enum VideoSourceType {
  CAMERA = 'camera',
  SCREEN = 'screen',
}

export const VIDEO_SOURCE_OPTIONS = [{
  label: "Camera",
  value: VideoSourceType.CAMERA,
}, {
  label: "Screen Share",
  value: VideoSourceType.SCREEN,
}]

export const COLOR_LIST: ColorItem[] = [
  {
    active: "#0888FF",
    default: "#143354",
  },
  {
    active: "#563FD8",
    default: "#2C2553",
  },
  {
    active: "#18A957",
    default: "#173526",
  },
  {
    active: "#FFAB08",
    default: "#423115",
  },
  {
    active: "#FD5C63",
    default: "#462629",
  },
  {
    active: "#E225B2",
    default: "#481C3F",
  },
];

export type VoiceTypeMap = {
  [voiceType: string]: string;
};

export type VendorNameMap = {
  [vendorName: string]: VoiceTypeMap;
};

export type LanguageMap = {
  [language: string]: VendorNameMap;
};

export enum EMobileActiveTab {
  AGENT = "agent",
  CHAT = "chat",
}

export const MOBILE_ACTIVE_TAB_MAP = {
  [EMobileActiveTab.AGENT]: "Agent",
  [EMobileActiveTab.CHAT]: "Chat",
};

export const isLLM = (extensionName: string) => {
  return extensionName === "llm" || extensionName === "v2v";
}

export const isEditModeOn = process.env.NEXT_PUBLIC_EDIT_GRAPH_MODE === "true";

export const TRULIENCE_SETTINGS_KEY = "__trulience__";
export const DEFAULT_TRULIENCE_OPTIONS: ITrulienceSettings = {
  enabled: false,
  avatarId: "",
  avatarToken: "",
  avatarDesktopLargeWindow: false,
  animationURL: "https://trulience.com",
  trulienceSDK: "https://trulience.com/sdk/trulience.sdk.js",
};


================================================
FILE: ai_agents/playground/src/common/graph.ts
================================================
import { ModuleRegistry } from "./moduleConfig"

export namespace AddonDef {
  export type AttributeType =
    | "string"
    | "bool"
    | "int32"
    | "int64"
    | "Uint32"
    | "Uint64"
    | "float64"
    | "array"
    | "buf"

  export type Attribute = {
    type: AttributeType
  }

  export type PropertyDefinition = {
    name: string
    attributes: Attribute
  }

  export type Command = {
    name: string
    property?: PropertyDefinition[]
    required?: string[]
    result?: {
      property: PropertyDefinition[]
      required?: string[]
    }
  }

  export type ApiEndpoint = {
    name: string
    property?: PropertyDefinition[]
  }

  export type Api = {
    property?: {properties: Record<string, Attribute>}
    cmd_in?: Command[]
    cmd_out?: Command[]
    data_in?: ApiEndpoint[]
    data_out?: ApiEndpoint[]
    audio_frame_in?: ApiEndpoint[]
    audio_frame_out?: ApiEndpoint[]
    video_frame_in?: ApiEndpoint[]
    video_frame_out?: ApiEndpoint[]
  }

  export type Module = {
    name: string
    defaultProperty: Property
    api: Api
  }
}

type Property = {
  [key: string]: any
}

type Node = {
  name: string
  addon: string
  extensionGroup: string
  app: string
  property?: Property
}
type Command = {
  name: string // Command name
  dest: Array<Destination> // Destination connections
}

type Data = {
  name: string // Data type name
  dest: Array<Destination> // Destination connections
}

type AudioFrame = {
  name: string // Audio frame type name
  dest: Array<Destination> // Destination connections
}

type VideoFrame = {
  name: string // Video frame type name
  dest: Array<Destination> // Destination connections
}

type MsgConversion = {
  type: string // Type of message conversion
  rules: Array<{
    path: string // Path in the data structure
    conversionMode: string // Mode of conversion (e.g., "replace", "append")
    value?: string // Optional value for the conversion
    originalPath?: string // Optional original path for mapping
  }>
  keepOriginal?: boolean // Whether to keep the original data
}

type Destination = {
  app: string // Application identifier
  extension: string // Extension name
  msgConversion?: MsgConversion // Optional message conversion rules
}

type Connection = {
  app: string // Application identifier
  extension: string // Extension name
  cmd?: Array<Command> // Optional command connections
  data?: Array<Data> // Optional data connections
  audio_frame?: Array<AudioFrame> // Optional audio frame connections
  video_frame?: Array<VideoFrame> // Optional video frame connections
}

type Graph = {
  uuid: string
  name: string
  autoStart: boolean
  nodes: Node[]
  connections: Connection[]
}

enum GraphConnProtocol {
  CMD = "cmd",
  DATA = "data",
  AUDIO_FRAME = "audio_frame",
  VIDEO_FRAME = "video_frame",
}

class GraphEditor {
  private static sharedApp: string = "localhost"

  /**
   * Set a shared app value.
   */
  static setApp(app: string): void {
    GraphEditor.sharedApp = app
  }

  /**
   * Add a node to the graph
   */
  static addNode(
    graph: Graph,
    addon: string,
    name: string,
    group: string = "default",
    properties: Record<string, any> = {},
  ): Node {
    if (graph.nodes.some((node) => node.name === name)) {
      throw new Error(
        `Node with name "${name}" already exists in graph "${graph.name}".`,
      )
    }

    const node: Node = {
      name,
      addon,
      extensionGroup: group,
      app: GraphEditor.sharedApp,
      property: properties,
    }

    graph.nodes.push(node)
    return node
  }

  /**
   * Remove a node from the graph
   */
  static removeNode(graph: Graph, nodeName: string): Node {
    const nodeIndex = graph.nodes.findIndex((node) => node.name === nodeName)
    if (nodeIndex === -1) {
      throw new Error(`Node "${nodeName}" not found in graph "${graph.name}".`)
    }
    const node = graph.nodes.splice(nodeIndex, 1)[0]
    return node;
  }

  /**
   * Update node properties
   */
  static updateNode(
    graph: Graph,
    nodeName: string,
    properties: Record<string, any>,
  ): void {
    const node = graph.nodes.find((node) => node.name === nodeName)
    if (!node) {
      throw new Error(`Node "${nodeName}" not found in graph "${graph.name}".`)
    }

    // Update properties (remove property if value is empty)
    node.property = {
      ...node.property,
      ...Object.fromEntries(
        Object.entries(properties).filter(([_, value]) => value !== ""),
      ),
    }
  }

  static updateNodeProperty(
    graph: Graph,
    nodeName: string,
    properties: Record<string, any>,
  ): boolean {
    const node = this.findNode(graph, nodeName)
    if (!node) return false

    node.property = {
      ...node.property,
      ...Object.fromEntries(
        Object.entries(properties).filter(([_, value]) => value !== ""),
      ),
    }

    return true
  }

  static removeNodeProperties(
    graph: Graph,
    nodeName: string,
    properties: string[],
  ): boolean {
    const node = this.findNode(graph, nodeName)
    if (!node) return false

    properties.forEach((prop) => {
      if (node.property) delete node.property[prop]
    })

    return true
  }

  /**
   * Add a connection to the graph across all protocols (cmd, data, audio_frame, video_frame)
   */
  static addConnection(
    graph: Graph,
    source: string,
    destination: string,
    protocolLabel: GraphConnProtocol,
    protocolName: string, // Name for the protocol object
  ): void {
    // Find the source connection in the graph
    let connection = graph.connections.find(
      (conn) =>
        conn.extension === source,
    )

    if (!connection) {
      // If no connection exists, create a new one
      connection = {
        app: GraphEditor.sharedApp,
        extension: source,
      }
      graph.connections.push(connection)
    }

    // Handle protocol-specific addition
    const protocolField = protocolLabel.toLowerCase() as keyof Connection
    if (!connection[protocolField]) {
      connection[protocolField] = [] as any
    }

    const protocolArray = connection[protocolField] as Array<
      Command | Data | AudioFrame | VideoFrame
    >

    // Check if the protocol object exists
    let protocolObject = protocolArray.find(
      (item) => item.name === protocolName,
    )
    if (!protocolObject) {
      protocolObject = {
        name: protocolName,
        dest: [],
      }
      protocolArray.push(protocolObject)
    }

    // Check if the destination already exists
    if (
      protocolObject.dest.some(
        (dest) => dest.extension === destination,
      )
    ) {
      throw new Error(
        `Destination "${destination}" already exists in protocol "${protocolLabel}" with name "${protocolName}".`,
      )
    }

    // Add the destination
    protocolObject.dest.push({
      app: GraphEditor.sharedApp,
      extension: destination,
    })
  }
  static addOrUpdateConnection(
    graph: Graph,
    source: string,
    destination: string,
    protocolLabel: GraphConnProtocol,
    protocolName: string, // Explicit name of the protocol object
  ): void {
    let connection = this.findConnection(graph, source)

    if (connection) {
      // Add or update destination in the existing connection
      const protocolField = protocolLabel.toLowerCase() as keyof Connection
      if (!connection[protocolField]) {
        connection[protocolField] = [] as any
      }

      const protocolArray = connection[protocolField] as Array<
        Command | Data | AudioFrame | VideoFrame
      >

      // Find the protocol object by name
      let protocolObject = protocolArray.find(
        (item) => item.name === protocolName,
      )
      if (!protocolObject) {
        // Create a new protocol object if it doesn't exist
        protocolObject = {
          name: protocolName,
          dest: [],
        }
        protocolArray.push(protocolObject)
      }

      // Check if the destination already exists
      if (
        !protocolObject.dest.some(
          (dest) => dest.extension === destination,
        )
      ) {
        // Add the new destination
        protocolObject.dest.push({
          app: GraphEditor.sharedApp,
          extension: destination,
        })
      }
    } else {
      // Add a new connection if none exists
      this.addConnection(
        graph,
        source,
        destination,
        protocolLabel,
        protocolName,
      )
    }
  }
  /**
 * Remove a connection from the graph across all protocols (cmd, data, audio_frame, video_frame)
 */
  static removeConnection(
    graph: Graph,
    source: string,
    destination?: string,
    protocolLabel?: GraphConnProtocol,
    protocolName?: string, // Optional name of the protocol object
  ): void {
    // Find the source connection in the graph
    const connectionIndex = graph.connections.findIndex(
      (conn) =>
        conn.extension === source,
    );

    if (connectionIndex === -1) {
      console.warn(`Source "${source}" not found in the graph. Operation ignored.`);
      return; // Exit the function if the connection does not exist
    }

    const connection = graph.connections[connectionIndex];

    // If protocolLabel is provided, handle protocol-specific removal
    if (protocolLabel) {
      const protocolField = protocolLabel.toLowerCase() as keyof Connection;
      const protocolArray = connection[protocolField] as Array<
        Command | Data | AudioFrame | VideoFrame
      >;

      if (!protocolArray) {
        console.warn(
          `Protocol "${protocolLabel}" does not exist for source "${source}". Operation ignored.`
        );
        return; // Exit the function if the protocol does not exist
      }

      const protocolObjectIndex = protocolArray.findIndex(
        (item) => item.name === protocolName,
      );

      if (protocolObjectIndex === -1) {
        console.warn(
          `Protocol object with name "${protocolName}" not found in protocol "${protocolLabel}". Operation ignored.`
        );
        return; // Exit the function if the protocol object does not exist
      }

      if (destination) {
        // Remove a specific destination
        protocolArray[protocolObjectIndex].dest = protocolArray[
          protocolObjectIndex
        ].dest.filter((dest) => dest.extension !== destination);

        // Remove the protocol object if it has no destinations
        if (protocolArray[protocolObjectIndex].dest.length === 0) {
          protocolArray.splice(protocolObjectIndex, 1);
        }
      } else {
        // Remove the entire protocol object
        protocolArray.splice(protocolObjectIndex, 1);
      }
    } else {
      // If no protocolLabel is provided, remove the entire connection
      graph.connections.splice(connectionIndex, 1);
    }

    // Clean up empty connections
    GraphEditor.removeEmptyConnections(graph);
  }

  static findNode(graph: Graph, nodeName: string): Node | null {
    return graph.nodes.find((node) => node.name === nodeName) || null
  }

  static findNodeByPredicate(graph: Graph, predicate: (node: Node) => boolean): Node | null {
    return graph.nodes.find(predicate) || null
  }

  static findConnection(
    graph: Graph,
    extension: string,
  ): Connection | null {
    return (
      graph.connections.find(
        (conn) =>
          conn.extension === extension,
      ) || null
    )
  }

  static removeEmptyConnections(graph: Graph): void {
    graph.connections = graph.connections.filter((connection) => {
      // Filter each protocol to remove empty destination objects
      connection.cmd = Array.isArray(connection.cmd)
        ? connection.cmd.filter((cmd) => cmd.dest?.length > 0)
        : undefined;
      if (!connection.cmd?.length) delete connection.cmd;

      connection.data = Array.isArray(connection.data)
        ? connection.data.filter((data) => data.dest?.length > 0)
        : undefined;
      if (!connection.data?.length) delete connection.data;

      connection.audio_frame = Array.isArray(connection.audio_frame)
        ? connection.audio_frame.filter((audio) => audio.dest?.length > 0)
        : undefined;
      if (!connection.audio_frame?.length) delete connection.audio_frame;

      connection.video_frame = Array.isArray(connection.video_frame)
        ? connection.video_frame.filter((video) => video.dest?.length > 0)
        : undefined;
      if (!connection.video_frame?.length) delete connection.video_frame;

      // Check if at least one protocol remains
      return (
        connection.cmd?.length ||
        connection.data?.length ||
        connection.audio_frame?.length ||
        connection.video_frame?.length
      );
    });
  }



  static removeNodeAndConnections(graph: Graph, addon: string): void {
    // Remove the node
    const node = this.removeNode(graph, addon)

    // Remove all connections involving this node
    graph.connections = graph.connections.filter((connection) => {
      const isSource =
        connection.extension === `${node.name}`
      const protocols = ["cmd", "data", "audio_frame", "video_frame"] as const

      protocols.forEach((protocol) => {
        if (connection[protocol]) {
          connection[protocol].forEach((item) => item.dest = item.dest.filter(d => d.extension !== node.name),
          )
        }
      })

      // Return true if connection still has content, false to remove it
      return (
        !isSource &&
        (connection.cmd?.length ||
          connection.data?.length ||
          connection.audio_frame?.length ||
          connection.video_frame?.length)
      )
    })
    // Clean up empty connections
    GraphEditor.removeEmptyConnections(graph);
  }

  /**
 * Link a tool to an LLM node by creating the appropriate connections.
 */
  static linkTool(graph: Graph, llmNode: Node, toolNode: Node, tool: ModuleRegistry.ToolModule): void {
    // Create the connection from the LLM node to the tool node
    GraphEditor.addOrUpdateConnection(
      graph,
      `${llmNode.name}`,
      `${toolNode.name}`,
      GraphConnProtocol.CMD,
      "tool_call"
    );

    // Create the connection from the tool node back to the LLM node
    GraphEditor.addOrUpdateConnection(
      graph,
      `${toolNode.name}`,
      `${llmNode.name}`,
      GraphConnProtocol.CMD,
      "tool_register"
    );

    const rtcModule = GraphEditor.findNodeByPredicate(graph, (node) => node.addon.includes("rtc"));
    if (toolNode.addon.includes("vision") && rtcModule) {
      // Create the connection from the RTC node to the tool node to deliver video frame
      GraphEditor.addOrUpdateConnection(
        graph,
        `${rtcModule.name}`,
        `${toolNode.name}`,
        GraphConnProtocol.VIDEO_FRAME,
        "video_frame"
      );
    }

    const messageCollector = GraphEditor.findNodeByPredicate(graph, ((node) => node.addon.includes("message_collector")))
    if (tool.options.outputContentText && messageCollector) {
      GraphEditor.addOrUpdateConnection(
        graph,
        `${toolNode.name}`,
        `${messageCollector.name}`,
        GraphConnProtocol.DATA,
        "content_data"
      )
    }
  }

  static enableRTCVideoSubscribe(graph: Graph, enabled: Boolean): void {
    const rtcNode = GraphEditor.findNodeByPredicate(graph, (node) => node.addon.includes("rtc"));
    if (!rtcNode) {
      throw new Error("RTC node not found in the graph.");
    }

    if (enabled) {
      GraphEditor.updateNodeProperty(graph, rtcNode.name, {
        subscribe_video_pix_fmt: 4,
        subscribe_video: true,
      });
    } else {
      GraphEditor.removeNodeProperties(graph, rtcNode.name, ["subscribe_video_pix_fmt", "subscribe_video"]);
    }
  }
}

export type { Graph, Node, Connection, Command, Destination }

export { GraphEditor, GraphConnProtocol as ProtocolLabel }



================================================
FILE: ai_agents/playground/src/common/hooks.ts
================================================
"use client";

import { IMicrophoneAudioTrack } from "agora-rtc-sdk-ng";
import { deepMerge, normalizeFrequencies } from "./utils";
import { useState, useEffect, useMemo, useRef, useCallback } from "react";
import type { AppDispatch, AppStore, RootState } from "../store";
import { useDispatch, useSelector, useStore } from "react-redux";
import { Node, AddonDef, Graph } from "@/common/graph";
import { initializeGraphData, updateGraph } from "@/store/reducers/global";
import { moduleRegistry, ModuleRegistry, toolModuleRegistry } from "@/common/moduleConfig";
// import { Grid } from "antd"

// const { useBreakpoint } = Grid;

export const useAppDispatch = useDispatch.withTypes<AppDispatch>();
export const useAppSelector = useSelector.withTypes<RootState>();
export const useAppStore = useStore.withTypes<AppStore>();

export const useMultibandTrackVolume = (
  track?: IMicrophoneAudioTrack | MediaStreamTrack,
  bands: number = 5,
  loPass: number = 100,
  hiPass: number = 600
) => {
  const [frequencyBands, setFrequencyBands] = useState<Float32Array[]>([]);

  useEffect(() => {
    if (!track) {
      return setFrequencyBands(new Array(bands).fill(new Float32Array(0)));
    }

    const ctx = new AudioContext();
    let finTrack =
      track instanceof MediaStreamTrack ? track : track.getMediaStreamTrack();
    const mediaStream = new MediaStream([finTrack]);
    const source = ctx.createMediaStreamSource(mediaStream);
    const analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;

    source.connect(analyser);

    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Float32Array(bufferLength);

    const updateVolume = () => {
      analyser.getFloatFrequencyData(dataArray);
      let frequencies: Float32Array = new Float32Array(dataArray.length);
      for (let i = 0; i < dataArray.length; i++) {
        frequencies[i] = dataArray[i];
      }
      frequencies = frequencies.slice(loPass, hiPass);

      const normalizedFrequencies = normalizeFrequencies(frequencies);
      const chunkSize = Math.ceil(normalizedFrequencies.length / bands);
      const chunks: Float32Array[] = [];
      for (let i = 0; i < bands; i++) {
        chunks.push(
          normalizedFrequencies.slice(i * chunkSize, (i + 1) * chunkSize)
        );
      }

      setFrequencyBands(chunks);
    };

    const interval = setInterval(updateVolume, 10);

    return () => {
      source.disconnect();
      clearInterval(interval);
    };
  }, [track, loPass, hiPass, bands]);

  return frequencyBands;
};

export const useAutoScroll = (ref: React.RefObject<HTMLElement | null>) => {
  const callback: MutationCallback = (mutationList, observer) => {
    mutationList.forEach((mutation) => {
      switch (mutation.type) {
        case "childList":
          if (!ref.current) {
            return;
          }
          ref.current.scrollTop = ref.current.scrollHeight;
          break;
      }
    });
  };

  useEffect(() => {
    if (!ref.current) {
      return;
    }
    const observer = new MutationObserver(callback);
    observer.observe(ref.current, {
      childList: true,
      subtree: true,
    });

    return () => {
      observer.disconnect();
    };
  }, [ref]);
};

// export const useSmallScreen = () => {
//   const screens = useBreakpoint();

//   const xs = useMemo(() => {
//     return !screens.sm && screens.xs
//   }, [screens])

//   const sm = useMemo(() => {
//     return !screens.md && screens.sm
//   }, [screens])

//   return {
//     xs,
//     sm,
//     isSmallScreen: xs || sm
//   }
// }

export const usePrevious = (value: any) => {
  const ref = useRef();

  useEffect(() => {
    ref.current = value;
  }, [value]);

  return ref.current;
};



const useGraphs = () => {
  const dispatch = useAppDispatch()
  const selectedGraphId = useAppSelector(
    (state) => state.global.selectedGraphId,
  )
  const graphMap = useAppSelector((state) => state.global.graphMap)
  const selectedGraph = graphMap[selectedGraphId]
  const addonModules: AddonDef.Module[] = useAppSelector((state) => state.global.addonModules);

  const initialize = async () => {
    await dispatch(initializeGraphData())
  }

  const update = async (graph: Graph, updates: Partial<Graph>) => {
    await dispatch(updateGraph({ graph, updates })).unwrap()
  }

  const getGraphNodeAddonByName = useCallback(
    (nodeName: string) => {
      if (!selectedGraph) {
        return null
      }
      const node = selectedGraph.nodes.find((node: Node) => node.name === nodeName)
      if (!node) {
        return null
      }
      return node
    },
    [selectedGraph],
  )


  const getInstalledAndRegisteredModulesMap = useCallback(() => {
    const groupedModules: Record<ModuleRegistry.NonToolModuleType, ModuleRegistry.Module[]> = {
      stt: [],
      tts: [],
      llm: [],
      v2v: []
    }

    addonModules.forEach((addonModule) => {
      const registeredModule = moduleRegistry[addonModule.name];
      if (registeredModule && registeredModule.type !== "tool") {
        groupedModules[registeredModule.type].push(registeredModule);
      }
    });

    return groupedModules;
  }, [addonModules]);

  const getInstalledAndRegisteredToolModules = useCallback(() => {
    const toolModules: ModuleRegistry.ToolModule[] = [];

    addonModules.forEach((addonModule) => {
      const registeredModule = toolModuleRegistry[addonModule.name];
      if (registeredModule && registeredModule.type === "tool") {
        toolModules.push(registeredModule);
      }
    });

    return toolModules;
  }, [addonModules])

  const installedAndRegisteredModulesMap = useMemo(
    () => getInstalledAndRegisteredModulesMap(),
    [getInstalledAndRegisteredModulesMap],
  );

  const installedAndRegisteredToolModules = useMemo(
    () => getInstalledAndRegisteredToolModules(),
    [getInstalledAndRegisteredToolModules],
  );

  return {
    initialize,
    getGraphNodeAddonByName,
    updateGraph: update,
    selectedGraph,
    installedAndRegisteredModulesMap,
    installedAndRegisteredToolModules,
  }
}

export { useGraphs }


================================================
FILE: ai_agents/playground/src/common/index.ts
================================================
export * from "./hooks"
export * from "./constant"
export * from "./utils"
export * from "./storage"
export * from "./request"
export * from "./mock"



================================================
FILE: ai_agents/playground/src/common/mock.ts
================================================
import { getRandomUserId } from "./utils";
import { IChatItem, EMessageType, EMessageDataType } from "@/types";

const SENTENCES = [
  "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
  "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium.",
  "Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit.",
  "Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit.",
  "Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.",
  "Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.",
  "Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",
];

export const genRandomParagraph = (num: number = 0): string => {
  let paragraph = "";
  for (let i = 0; i < num; i++) {
    const randomIndex = Math.floor(Math.random() * SENTENCES.length);
    paragraph += SENTENCES[randomIndex] + " ";
  }

  return paragraph.trim();
};

export const genRandomChatList = (num: number = 10): IChatItem[] => {
  const arr: IChatItem[] = [];
  for (let i = 0; i < num; i++) {
    const type = Math.random() > 0.5 ? EMessageType.AGENT : EMessageType.USER;
    arr.push({
      userId: getRandomUserId(),
      userName: type == "agent" ? EMessageType.AGENT : "You",
      text: genRandomParagraph(3),
      type,
      data_type: EMessageDataType.TEXT,
      time: Date.now(),
    });
  }

  return arr;
};



================================================
FILE: ai_agents/playground/src/common/moduleConfig.ts
================================================
export namespace ModuleRegistry {
    export enum ModuleType {
        STT = "stt",
        LLM = "llm",
        V2V = "v2v",
        TTS = "tts",
        TOOL = "tool",
    }

    export interface Module {
        name: string;
        type: ModuleType;
        label: string;
    }

    export type NonToolModuleType = Exclude<ModuleType, ModuleType.TOOL>
    export type NonToolModule = Module & { type: NonToolModuleType };
    export enum Modalities {
        Video = "video",
        Audio = "audio",
        Text = "text"
    }
    export interface LLMModuleOptions {
        inputModalities: Modalities[]
    }
    export interface V2VModuleOptions {
        inputModalities: Modalities[]
    }
    export interface ToolModuleOptions {
        outputContentText?: boolean
    }
    // Extending Module to define LLMModule with options
    export interface LLMModule extends Module {
        type: ModuleType.LLM; // Ensuring it's specific to LLM
        options: LLMModuleOptions;
    }
    export interface V2VModule extends Module {
        type: ModuleType.V2V,
        options: LLMModuleOptions
    }
    export interface ToolModule extends Module {
        type: ModuleType.TOOL,
        options: ToolModuleOptions
    }
}


// Custom labels for specific keys
export const ModuleTypeLabels: Record<ModuleRegistry.NonToolModuleType, string> = {
    [ModuleRegistry.ModuleType.STT]: "STT (Speech to Text)",
    [ModuleRegistry.ModuleType.LLM]: "LLM (Large Language Model)",
    [ModuleRegistry.ModuleType.TTS]: "TTS (Text to Speech)",
    [ModuleRegistry.ModuleType.V2V]: "LLM v2v (V2V Large Language Model)",
};

export const sttModuleRegistry: Record<string, ModuleRegistry.Module> = {
    deepgram_asr_python: {
        name: "deepgram_asr_python",
        type: ModuleRegistry.ModuleType.STT,
        label: "Deepgram STT",
    },
    transcribe_asr_python: {
        name: "transcribe_asr_python",
        type: ModuleRegistry.ModuleType.STT,
        label: "Transcribe STT",
    },
    speechmatics_asr_python: {
        name: "speechmatics_asr_python",
        type: ModuleRegistry.ModuleType.STT,
        label: "Speechmatics STT",
    }
}

export const llmModuleRegistry: Record<string, ModuleRegistry.LLMModule> = {
    openai_chatgpt_python: {
        name: "openai_chatgpt_python",
        type: ModuleRegistry.ModuleType.LLM,
        label: "OpenAI ChatGPT",
        options: { inputModalities: [ModuleRegistry.Modalities.Text] }
    },
    dify_python: {
        name: "dify_python",
        type: ModuleRegistry.ModuleType.LLM,
        label: "Dify Chat Bot",
        options: { inputModalities: [ModuleRegistry.Modalities.Text] }
    },
    coze_python_async: {
        name: "coze_python_async",
        type: ModuleRegistry.ModuleType.LLM,
        label: "Coze Chat Bot",
        options: { inputModalities: [ModuleRegistry.Modalities.Text] }
    },
    gemini_llm_python: {
        name: "gemini_llm_python",
        type: ModuleRegistry.ModuleType.LLM,
        label: "Gemini LLM",
        options: { inputModalities: [ModuleRegistry.Modalities.Text] }
    },
    bedrock_llm_python: {
        name: "bedrock_llm_python",
        type: ModuleRegistry.ModuleType.LLM,
        label: "Bedrock LLM",
        options: { inputModalities: [ModuleRegistry.Modalities.Text, ModuleRegistry.Modalities.Video] }
    },
}

export const ttsModuleRegistry: Record<string, ModuleRegistry.Module> = {
    azure_tts: {
        name: "azure_tts",
        type: ModuleRegistry.ModuleType.TTS,
        label: "Azure TTS",
    },
    cartesia_tts: {
        name: "cartesia_tts",
        type: ModuleRegistry.ModuleType.TTS,
        label: "Cartesia TTS",
    },
    cosy_tts_python: {
        name: "cosy_tts_python",
        type: ModuleRegistry.ModuleType.TTS,
        label: "Cosy TTS",
    },
    elevenlabs_tts_python: {
        name: "elevenlabs_tts_python",
        type: ModuleRegistry.ModuleType.TTS,
        label: "Elevenlabs TTS",
    },
    fish_audio_tts: {
        name: "fish_audio_tts",
        type: ModuleRegistry.ModuleType.TTS,
        label: "Fish Audio TTS",
    },
    minimax_tts_python: {
        name: "minimax_tts_python",
        type: ModuleRegistry.ModuleType.TTS,
        label: "Minimax TTS",
    },
    polly_tts: {
        name: "polly_tts",
        type: ModuleRegistry.ModuleType.TTS,
        label: "Polly TTS",
    },
    neuphonic_tts: {
        name: "neuphonic_tts",
        type: ModuleRegistry.ModuleType.TTS,
        label: "Neuphonic TTS",
    },
    openai_tts_python: {
        name: "openai_tts_python",
        type: ModuleRegistry.ModuleType.TTS,
        label: "OpenAI TTS",
    },
    dubverse_tts: {
        name: "dubverse_tts",
        type: ModuleRegistry.ModuleType.TTS,
        label: "Dubverse TTS",
    }
}

export const v2vModuleRegistry: Record<string, ModuleRegistry.V2VModule> = {
    openai_v2v_python: {
        name: "openai_v2v_python",
        type: ModuleRegistry.ModuleType.V2V,
        label: "OpenAI Realtime",
        options: { inputModalities: [ModuleRegistry.Modalities.Audio] }
    },
    gemini_v2v_python: {
        name: "gemini_v2v_python",
        type: ModuleRegistry.ModuleType.V2V,
        label: "Gemini Realtime",
        options: { inputModalities: [ModuleRegistry.Modalities.Video, ModuleRegistry.Modalities.Audio] }
    },
    glm_v2v_python: {
        name: "glm_v2v_python",
        type: ModuleRegistry.ModuleType.V2V,
        label: "GLM Realtime",
        options: { inputModalities: [ModuleRegistry.Modalities.Audio] }
    },
    stepfun_v2v_python: {
        name: "stepfun_v2v_python",
        type: ModuleRegistry.ModuleType.V2V,
        label: "Stepfun Realtime",
        options: { inputModalities: [ModuleRegistry.Modalities.Audio] }
    },
    azure_v2v_python: {
        name: "azure_v2v_python",
        type: ModuleRegistry.ModuleType.V2V,
        label: "Azure Realtime",
        options: { inputModalities: [ModuleRegistry.Modalities.Audio] }
    }
}

export const toolModuleRegistry: Record<string, ModuleRegistry.ToolModule> = {
    vision_analyze_tool_python: {
        name: "vision_analyze_tool_python",
        type: ModuleRegistry.ModuleType.TOOL,
        label: "Vision Analyze Tool",
        options: {}
    },
    weatherapi_tool_python: {
        name: "weatherapi_tool_python",
        type: ModuleRegistry.ModuleType.TOOL,
        label: "WeatherAPI Tool",
        options: {}
    },
    bingsearch_tool_python: {
        name: "bingsearch_tool_python",
        type: ModuleRegistry.ModuleType.TOOL,
        label: "BingSearch Tool",
        options: {}
    },
    vision_tool_python: {
        name: "vision_tool_python",
        type: ModuleRegistry.ModuleType.TOOL,
        label: "Vision Tool",
        options: {}
    },
    openai_image_generate_tool: {
        name: "openai_image_generate_tool",
        type: ModuleRegistry.ModuleType.TOOL,
        label: "OpenAI Image Generate Tool",
        options: { outputContentText: true }
    },
    computer_tool_python: {
        name: "computer_tool_python",
        type: ModuleRegistry.ModuleType.TOOL,
        label: "Computer Tool",
        options: { outputContentText: true }
    },
    mcp_client_python: {
        name: "mcp_client_python",
        type: ModuleRegistry.ModuleType.TOOL,
        label: "MCP Client Tool",
        options: {}
    }
}

export const moduleRegistry: Record<string, ModuleRegistry.Module> = {
    ...sttModuleRegistry,
    ...llmModuleRegistry,
    ...ttsModuleRegistry,
    ...v2vModuleRegistry
}

export const compatibleTools: Record<string, string[]> = {
    openai_chatgpt_python: ["vision_tool_python", "weatherapi_tool_python", "bingsearch_tool_python", "openai_image_generate_tool", "computer_tool_python", "mcp_client_python"],
    openai_v2v_python: ["weatherapi_tool_python", "bingsearch_tool_python", "openai_image_generate_tool", "computer_tool_python", "mcp_client_python"],
    gemini_v2v_python: ["weatherapi_tool_python", "bingsearch_tool_python", "openai_image_generate_tool", "computer_tool_python"],
    glm_v2v_python: ["weatherapi_tool_python", "bingsearch_tool_python", "openai_image_generate_tool", "computer_tool_python"],
    stepfun_v2v_python: ["weatherapi_tool_python", "bingsearch_tool_python", "openai_image_generate_tool", "computer_tool_python", "mcp_client_python"],
    azure_v2v_python: ["weatherapi_tool_python", "bingsearch_tool_python", "openai_image_generate_tool", "computer_tool_python", "mcp_client_python"],
}



================================================
FILE: ai_agents/playground/src/common/request.ts
================================================
import { genUUID } from "./utils"
import { Language } from "@/types"
import axios from "axios"
import { AddonDef, Connection, Graph, GraphEditor, Node, ProtocolLabel } from "./graph"
import { isEditModeOn } from "./constant"

interface StartRequestConfig {
  channel: string
  userId: number,
  graphName: string,
  language: Language,
  voiceType: "male" | "female"
}

interface GenAgoraDataConfig {
  userId: string | number
  channel: string
}

export const apiGenAgoraData = async (config: GenAgoraDataConfig) => {
  // the request will be rewrite at middleware.tsx to send to $AGENT_SERVER_URL
  const url = `/api/token/generate`
  const { userId, channel } = config
  const data = {
    request_id: genUUID(),
    uid: userId,
    channel_name: channel
  }
  let resp: any = await axios.post(url, data)
  resp = (resp.data) || {}
  return resp
}

export const apiStartService = async (config: StartRequestConfig): Promise<any> => {
  // look at app/apis/route.tsx for the server-side implementation
  const url = `/api/agents/start`
  const { channel, userId, graphName, language, voiceType } = config
  const data = {
    request_id: genUUID(),
    channel_name: channel,
    user_uid: userId,
    graph_name: graphName,
    language,
    voice_type: voiceType
  }
  let resp: any = await axios.post(url, data)
  resp = (resp.data) || {}
  return resp
}

export const apiStopService = async (channel: string) => {
  // the request will be rewrite at middleware.tsx to send to $AGENT_SERVER_URL
  const url = `/api/agents/stop`
  const data = {
    request_id: genUUID(),
    channel_name: channel
  }
  let resp: any = await axios.post(url, data)
  resp = (resp.data) || {}
  return resp
}

export const apiGetDocumentList = async () => {
  // the request will be rewrite at middleware.tsx to send to $AGENT_SERVER_URL
  const url = `/api/vector/document/preset/list`
  let resp: any = await axios.get(url)
  resp = (resp.data) || {}
  if (resp.code !== "0") {
    throw new Error(resp.msg)
  }
  return resp
}

export const apiUpdateDocument = async (options: { channel: string, collection: string, fileName: string }) => {
  // the request will be rewrite at middleware.tsx to send to $AGENT_SERVER_URL
  const url = `/api/vector/document/update`
  const { channel, collection, fileName } = options
  const data = {
    request_id: genUUID(),
    channel_name: channel,
    collection: collection,
    file_name: fileName
  }
  let resp: any = await axios.post(url, data)
  resp = (resp.data) || {}
  return resp
}


// ping/pong 
export const apiPing = async (channel: string) => {
  // the request will be rewrite at middleware.tsx to send to $AGENT_SERVER_URL
  const url = `/api/agents/ping`
  const data = {
    request_id: genUUID(),
    channel_name: channel
  }
  let resp: any = await axios.post(url, data)
  resp = (resp.data) || {}
  return resp
}

export const apiFetchAddonsExtensions = async (): Promise<AddonDef.Module[]> => {
  // let resp: any = await axios.get(`/api/dev/v1/addons/extensions`)
  let resp: any = await axios.post(`/api/dev/v1/apps/addons`, {
    base_dir: "/app/agents"
  })
  return resp.data.data
}

export const apiCheckCompatibleMessages = async (payload: {
  app: string
  graph: string
  extension_group: string
  extension: string
  msg_type: string
  msg_direction: string
  msg_name: string
}) => {
  let resp: any = await axios.post(`/api/dev/v1/messages/compatible`, payload)
  resp = (resp.data) || {}
  return resp
}

export const apiFetchGraphs = async (): Promise<Graph[]> => {
  if (isEditModeOn) {
    let resp: any = await axios.post(`/api/dev/v1/graphs`, {})
    return resp.data.data.map((graph: any) => ({
      name: graph.name,
      uuid: graph.uuid,
      autoStart: graph.auto_start,
      nodes: [],
      connections: [],
    }))
  } else {
    let resp: any = await axios.get(`/api/agents/graphs`)
    return resp.data.data.map((graph: any) => ({
      name: graph.name,
      uuid: graph.uuid,
      autoStart: graph.auto_start,
      nodes: [],
      connections: [],
    }))
  }
}

export const apiLoadApp = async (): Promise<any> => {
  let resp: any = await axios.post(`/api/dev/v1/apps/load`, {
    base_dir: "/app/agents",
  })
  return resp.data.data
}

export const apiFetchGraphNodes = async (graphId: string): Promise<Node[]> => {
  // let resp: any = await axios.get(`/api/dev/v1/graphs/${graphId}/nodes`)
  let resp: any = await axios.post(`/api/dev/v1/graphs/nodes`, {
    graph_id: graphId,
  })
  return resp.data.data.map((node: any) => ({
    name: node.name,
    addon: node.addon,
    extensionGroup: node.extension_group,
    app: node.app,
    property: node.property || {},
  }))
}

export const apiFetchGraphConnections = async (graphId: string): Promise<Connection[]> => {
  // let resp: any = await axios.get(`/api/dev/v1/graphs/${graphId}/connections`)
  let resp: any = await axios.post(`/api/dev/v1/graphs/connections`, {
    graph_id: graphId,
  })
  return resp.data.data.map(
    (connection: any) => ({
      app: connection.app,
      extensionGroup: connection.extension_group,
      extension: connection.extension,
      cmd: connection.cmd?.map((cmd: any) => ({
        name: cmd.name,
        dest: cmd.dest.map((dest: any) => ({
          app: dest.app,
          extensionGroup: dest.extension_group,
          extension: dest.extension,
          msgConversion: dest.msgConversion
            ? {
              type: dest.msgConversion.type,
              rules: dest.msgConversion.rules.map((rule: any) => ({
                path: rule.path,
                conversionMode: rule.conversionMode,
                value: rule.value,
                originalPath: rule.originalPath,
              })),
              keepOriginal: dest.msgConversion.keepOriginal,
            }
            : undefined,
        })),
      })),
      data: connection.data?.map((data: any) => ({
        name: data.name,
        dest: data.dest.map((dest: any) => ({
          app: dest.app,
          extensionGroup: dest.extension_group,
          extension: dest.extension,
          msgConversion: dest.msgConversion
            ? {
              type: dest.msgConversion.type,
              rules: dest.msgConversion.rules.map((rule: any) => ({
                path: rule.path,
                conversionMode: rule.conversionMode,
                value: rule.value,
                originalPath: rule.originalPath,
              })),
              keepOriginal: dest.msgConversion.keepOriginal,
            }
            : undefined,
        })),
      })),
      audio_frame: connection.audio_frame?.map((audioFrame: any) => ({
        name: audioFrame.name,
        dest: audioFrame.dest.map((dest: any) => ({
          app: dest.app,
          extensionGroup: dest.extension_group,
          extension: dest.extension,
          msgConversion: dest.msgConversion
            ? {
              type: dest.msgConversion.type,
              rules: dest.msgConversion.rules.map((rule: any) => ({
                path: rule.path,
                conversionMode: rule.conversionMode,
                value: rule.value,
                originalPath: rule.originalPath,
              })),
              keepOriginal: dest.msgConversion.keepOriginal,
            }
            : undefined,
        })),
      })),
      video_frame: connection.video_frame?.map((videoFrame: any) => ({
        name: videoFrame.name,
        dest: videoFrame.dest.map((dest: any) => ({
          app: dest.app,
          extensionGroup: dest.extension_group,
          extension: dest.extension,
          msgConversion: dest.msgConversion
            ? {
              type: dest.msgConversion.type,
              rules: dest.msgConversion.rules.map((rule: any) => ({
                path: rule.path,
                conversionMode: rule.conversionMode,
                value: rule.value,
                originalPath: rule.originalPath,
              })),
              keepOriginal: dest.msgConversion.keepOriginal,
            }
            : undefined,
        })),
      })),
    }),
  )
}

export const apiGetDefaultProperty = async (module: string): Promise<any> => {
  let resp: any = await axios.post(`/api/dev/v1/extensions/property/get`, {
    addon_name: module,
    app_base_dir: "/app/agents",
  })
  return resp.data.data
}

export const apiAddNode = async (graphId: string, name: string, module: string, properties: Record<string, any>) => {
  let resp: any = await axios.post(`/api/dev/v1/graphs/nodes/add`, {
    graph_id: graphId,
    name,
    addon: module,
    property: properties
  })
  return resp.data.data
}

export const apiReplaceNodeModule = async (graphId: string, name: string, module: string, properties: Record<string, any>) => {
  let resp: any = await axios.post(`/api/dev/v1/graphs/nodes/replace`, {
    graph_id: graphId,
    name,
    addon: module,
    property: properties
  })
  return resp.data.data
}

export const apiRemoveNode = async (graphId: string, name: string, module: string) => {
  let resp: any = await axios.post(`/api/dev/v1/graphs/nodes/delete`, {
    graph_id: graphId,
    name,
    addon: module,
  })
  return resp.data.data
}

export const apiAddConnection = async (graphId: string, srcExtension: string, msgType: ProtocolLabel, msgName: string, dest_extension: string) => {
  let resp: any = await axios.post(`/api/dev/v1/graphs/connections/add`, {
    graph_id: graphId,
    src_extension: srcExtension,
    msg_type: msgType,
    msg_name: msgName,
    dest_extension: dest_extension
  })
  return resp.data.data
}

export const apiRemoveConnection = async (graphId: string, srcExtension: string, msgType: ProtocolLabel, msgName: string, dest_extension: string) => {
  let resp: any = await axios.post(`/api/dev/v1/graphs/connections/delete`, {
    graph_id: graphId,
    src_extension: srcExtension,
    msg_type: msgType,
    msg_name: msgName,
    dest_extension: dest_extension
  })
  return resp.data.data
}

export const apiUpdateGraph = async (graphId: string, updates: Partial<Graph>) => {
  const { autoStart, nodes, connections } = updates
  const payload: any = {}

  // Map autoStart field
  if (autoStart !== undefined) payload.auto_start = autoStart

  // Map nodes to the payload
  if (nodes) {
    payload.nodes = nodes.map((node) => ({
      name: node.name,
      addon: node.addon,
      extension_group: node.extensionGroup,
      app: node.app,
      property: node.property,
    }))
  }

  // Map connections to the payload
  if (connections) {
    payload.connections = connections.map((connection) => ({
      app: connection.app,
      extension: connection.extension,
      cmd: connection.cmd?.map((cmd) => ({
        name: cmd.name,
        dest: cmd.dest.map((dest) => ({
          app: dest.app,
          extension: dest.extension,
          msgConversion: dest.msgConversion
            ? {
              type: dest.msgConversion.type,
              rules: dest.msgConversion.rules.map((rule) => ({
                path: rule.path,
                conversionMode: rule.conversionMode,
                value: rule.value,
                originalPath: rule.originalPath,
              })),
              keepOriginal: dest.msgConversion.keepOriginal,
            }
            : undefined,
        })),
      })),
      data: connection.data?.map((data) => ({
        name: data.name,
        dest: data.dest.map((dest) => ({
          app: dest.app,
          extension: dest.extension,
          msgConversion: dest.msgConversion
            ? {
              type: dest.msgConversion.type,
              rules: dest.msgConversion.rules.map((rule) => ({
                path: rule.path,
                conversionMode: rule.conversionMode,
                value: rule.value,
                originalPath: rule.originalPath,
              })),
              keepOriginal: dest.msgConversion.keepOriginal,
            }
            : undefined,
        })),
      })),
      audio_frame: connection.audio_frame?.map((audioFrame) => ({
        name: audioFrame.name,
        dest: audioFrame.dest.map((dest) => ({
          app: dest.app,
          extension: dest.extension,
          msgConversion: dest.msgConversion
            ? {
              type: dest.msgConversion.type,
              rules: dest.msgConversion.rules.map((rule) => ({
                path: rule.path,
                conversionMode: rule.conversionMode,
                value: rule.value,
                originalPath: rule.originalPath,
              })),
              keepOriginal: dest.msgConversion.keepOriginal,
            }
            : undefined,
        })),
      })),
      video_frame: connection.video_frame?.map((videoFrame) => ({
        name: videoFrame.name,
        dest: videoFrame.dest.map((dest) => ({
          app: dest.app,
          extension: dest.extension,
          msgConversion: dest.msgConversion
            ? {
              type: dest.msgConversion.type,
              rules: dest.msgConversion.rules.map((rule) => ({
                path: rule.path,
                conversionMode: rule.conversionMode,
                value: rule.value,
                originalPath: rule.originalPath,
              })),
              keepOriginal: dest.msgConversion.keepOriginal,
            }
            : undefined,
        })),
      })),
    }))
  }

  // let resp: any = await axios.put(`/api/dev/v1/graphs/${graphId}`, payload)
  let resp: any = await axios.post(`/api/dev/v1/graphs/update`, {
    graph_id: graphId,
    nodes: payload.nodes,
    connections: payload.connections,
  })
  resp = (resp.data) || {}
  return resp
}

export const apiFetchAddonModulesDefaultProperties = async (): Promise<
  Record<string, Partial<AddonDef.Module>>
> => {
  let resp: any = await axios.get(`/api/dev/v1/addons/default-properties`)
  const properties = resp.data.data
  const result: Record<string, Partial<AddonDef.Module>> = {}
  for (const property of properties) {
    result[property.addon] = property.property
  }
  return result
}

export const apiSaveProperty = async () => {
  let resp: any = await axios.put(`/api/dev/v1/property`)
  resp = (resp.data) || {}
  return resp
}

export const apiReloadPackage = async () => {
  let resp: any = await axios.post(`/api/dev/v1/apps/reload`, {
    base_dir: "/app/agents",
  })
  resp = (resp.data) || {}
  return resp
}


export const apiFetchInstalledAddons = async (): Promise<AddonDef.Module[]> => {
  const [modules, defaultProperties] = await Promise.all([
    apiFetchAddonsExtensions(),
    apiFetchAddonModulesDefaultProperties(),
  ])
  return modules.map((module: any) => ({
    name: module.name,
    defaultProperty: defaultProperties[module.name],
    api: module.api,
  }))
}

export const apiFetchGraphDetails = async (graph: Graph): Promise<Graph> => {
  const [nodes, connections] = await Promise.all([
    apiFetchGraphNodes(graph.uuid),
    apiFetchGraphConnections(graph.uuid),
  ])
  return {
    uuid: graph.uuid,
    name: graph.name,
    autoStart: graph.autoStart,
    nodes,
    connections,
  }
}


================================================
FILE: ai_agents/playground/src/common/storage.ts
================================================
import { IOptions, ITrulienceSettings } from "@/types"
import { OPTIONS_KEY, DEFAULT_OPTIONS, TRULIENCE_SETTINGS_KEY, DEFAULT_TRULIENCE_OPTIONS } from "./constant"

export const getOptionsFromLocal = () => {
  if (typeof window !== "undefined") {
    const data = localStorage.getItem(OPTIONS_KEY)
    if (data) {
      return JSON.parse(data)
    }
  }
  return DEFAULT_OPTIONS
}

export const setOptionsToLocal = (options: IOptions) => {
  if (typeof window !== "undefined") {
    localStorage.setItem(OPTIONS_KEY, JSON.stringify(options))
  }
}


export const getTrulienceSettingsFromLocal = () => {
  if (typeof window !== "undefined") {
    const data = localStorage.getItem(TRULIENCE_SETTINGS_KEY)
    if (data) {
      return JSON.parse(data)
    }
  }
  return DEFAULT_TRULIENCE_OPTIONS
}

export const setTrulienceSettingsToLocal = (settings: ITrulienceSettings) => {
  if (typeof window !== "undefined") {
    localStorage.setItem(TRULIENCE_SETTINGS_KEY, JSON.stringify(settings))
  }
}


================================================
FILE: ai_agents/playground/src/common/utils.ts
================================================
"use client";

import { useEffect, useState } from "react";

export const genRandomString = (length: number = 10) => {
  let result = '';
  const characters = 'abcdefghijklmnopqrstuvwxyz0123456789';
  const charactersLength = characters.length;

  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }

  return result;
}


export const getRandomUserId = (): number => {
  return Math.floor(Math.random() * 99999) + 100000
}

export const getRandomChannel = (number = 6) => {
  return "agora_" + genRandomString(number)
}


export const sleep = (ms: number) => {
  return new Promise(resolve => setTimeout(resolve, ms));
}


export const normalizeFrequencies = (frequencies: Float32Array) => {
  const normalizeDb = (value: number) => {
    const minDb = -100;
    const maxDb = -10;
    let db = 1 - (Math.max(minDb, Math.min(maxDb, value)) * -1) / 100;
    db = Math.sqrt(db);

    return db;
  };

  // Normalize all frequency values
  return frequencies.map((value) => {
    if (value === -Infinity) {
      return 0;
    }
    return normalizeDb(value);
  });
};


export const genUUID = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    const r = (Math.random() * 16) | 0
    const v = c === "x" ? r : (r & 0x3) | 0x8
    return v.toString(16)
  })
}


export const isMobile = () => {
  return /Mobile|iPhone|iPad|Android|Windows Phone/i.test(navigator.userAgent)
}

export function useIsCompactLayout(): boolean {
  
  const [isCompactLayout, setIsCompactLayout] = useState(false);

  useEffect(() => {
    // Guard clause for SSR or environments without window
    if (typeof window === 'undefined') {
      return;
    }

    // Create a media query for max-width: 768px
    const mediaQuery = window.matchMedia('(max-width: 768px)');

    // Set initial value based on the current match state
    setIsCompactLayout(mediaQuery.matches);

    // Handler to update state whenever the media query match status changes
    const handleChange = (event: MediaQueryListEvent) => {
      setIsCompactLayout(event.matches);
    };

    // Attach the listener using the modern API
    mediaQuery.addEventListener('change', handleChange);

    // Cleanup
    return () => {
      mediaQuery.removeEventListener('change', handleChange);
    };
  }, []);

  return isCompactLayout;

}

export const deepMerge = (target: Record<string, any>, source: Record<string, any>): Record<string, any> => {
  for (const key of Object.keys(source)) {
    if (source[key] instanceof Object && key in target) {
      Object.assign(source[key], deepMerge(target[key], source[key]));
    }
  }
  // Merge source into target
  return { ...target, ...source };
}


================================================
FILE: ai_agents/playground/src/components/Agent/AudioVisualizer.tsx
================================================
export interface AudioVisualizerProps {
  type: "agent" | "user"
  frequencies: Float32Array[]
  gap: number
  barWidth: number
  minBarHeight: number
  maxBarHeight: number
  borderRadius: number
}

export default function AudioVisualizer(props: AudioVisualizerProps) {
  const {
    frequencies,
    gap,
    barWidth,
    minBarHeight,
    maxBarHeight,
    borderRadius,
    type,
  } = props

  const summedFrequencies = frequencies.map((bandFrequencies) => {
    const sum = bandFrequencies.reduce((a, b) => a + b, 0)
    if (sum <= 0) {
      return 0
    }
    return Math.sqrt(sum / bandFrequencies.length)
  })

  return (
    <div
      className={`flex items-center justify-center`}
      style={{ gap: `${gap}px` }}
    >
      {summedFrequencies.map((frequency, index) => {
        const style = {
          height:
            minBarHeight + frequency * (maxBarHeight - minBarHeight) + "px",
          borderRadius: borderRadius + "px",
          width: barWidth + "px",
          transition:
            "background-color 0.35s ease-out, transform 0.25s ease-out",
          // transform: transform,
          backgroundColor: type === "agent" ? "#0888FF" : "#EAECF0",
          boxShadow: type === "agent" ? "0 0 10px #EAECF0" : "none",
        }

        return <span key={index} style={style} />
      })}
    </div>
  )
}



================================================
FILE: ai_agents/playground/src/components/Agent/AvatarTrulience.tsx
================================================
"use client";

import React, { useEffect, useMemo, useRef, useState } from "react"
import { useAppSelector } from "@/common"
import { TrulienceAvatar } from "trulience-sdk"
import { IMicrophoneAudioTrack } from "agora-rtc-sdk-ng"
import { Maximize, Minimize } from "lucide-react";
import { cn } from "@/lib/utils";
import { toast } from "sonner";
import { Progress, ProgressIndicator } from "../ui/progress";

interface AvatarProps {
  audioTrack?: IMicrophoneAudioTrack,
  localAudioTrack?: IMicrophoneAudioTrack
}

export default function Avatar({ audioTrack }: AvatarProps) {
  const agentConnected = useAppSelector((state) => state.global.agentConnected)
  const trulienceSettings = useAppSelector((state) => state.global.trulienceSettings)
  const trulienceAvatarRef = useRef<TrulienceAvatar>(null)
  const [errorMessage, setErrorMessage] = useState<string>("")

  // Track loading progress
  const [loadProgress, setLoadProgress] = useState(0)

  // State for the final avatar ID
  const [finalAvatarId, setFinalAvatarId] = useState("")

  // State for toggling fullscreen
  const [fullscreen, setFullscreen] = useState(false)

  // Safely read URL param on the client
  useEffect(() => {
    if (typeof window !== "undefined") {
      const urlParams = new URLSearchParams(window.location.search)
      const avatarIdFromURL = urlParams.get("avatarId")
      setFinalAvatarId(
        avatarIdFromURL || trulienceSettings.avatarId || ""
      )
    }
  }, [])

  // Define event callbacks
  const eventCallbacks = useMemo(() => {
    return {
      "auth-success": (resp: string) => {
        console.log("Trulience Avatar auth-success:", resp)
      },
      "auth-fail": (resp: any) => {
        console.log("Trulience Avatar auth-fail:", resp)
        setErrorMessage(resp.message)
      },
      "websocket-connect": (resp: string) => {
        console.log("Trulience Avatar websocket-connect:", resp)
      },
      "load-progress": (details: Record<string, any>) => {
        console.log("Trulience Avatar load-progress:", details.progress)
        setLoadProgress(details.progress)
      },
    }
  }, [])

  // Only create TrulienceAvatar instance once we have a final avatar ID
  const trulienceAvatarInstance = useMemo(() => {
    if (!finalAvatarId) return null
    return (
      <TrulienceAvatar
        url={trulienceSettings.trulienceSDK}
        ref={trulienceAvatarRef}
        avatarId={finalAvatarId}
        token={trulienceSettings.avatarToken}
        eventCallbacks={eventCallbacks}
        width="100%"
        height="100%"
      />
    )
  }, [finalAvatarId, eventCallbacks])

  // Update the Avatar’s audio stream whenever audioTrack or agentConnected changes
  useEffect(() => {
    if (trulienceAvatarRef.current) {
      if (audioTrack && agentConnected) {
        const stream = new MediaStream([audioTrack.getMediaStreamTrack()])
        trulienceAvatarRef.current.setMediaStream(null)
        trulienceAvatarRef.current.setMediaStream(stream)
        console.warn("[TrulienceAvatar] MediaStream set:", stream)
      } else if (!agentConnected) {
        const trulienceObj = trulienceAvatarRef.current.getTrulienceObject()
        trulienceObj?.sendMessageToAvatar("<trl-stop-background-audio immediate='true' />")
        trulienceObj?.sendMessageToAvatar("<trl-content position='DefaultCenter' />")
      }
    }

    // Cleanup: unset media stream
    return () => {
      trulienceAvatarRef.current?.setMediaStream(null)
    }
  }, [audioTrack, agentConnected])

  return (
    <div className={cn("relative h-full w-full overflow-hidden rounded-lg", {
      ["absolute top-0 left-0 h-screen w-screen rounded-none"]: fullscreen
    })}>
      <button
        className="absolute z-10 top-2 right-2 bg-black/50 p-2 rounded-lg hover:bg-black/70 transition"
        onClick={() => setFullscreen(prevValue => !prevValue)}
      >
        {fullscreen ? <Minimize className="text-white" size={24} /> : <Maximize className="text-white" size={24} />}
      </button>

      {/* Render the TrulienceAvatar */}
      {trulienceAvatarInstance}

      {/* Show a loader overlay while progress < 1 */}
      {errorMessage ? (
        <div className="absolute inset-0 z-10 flex items-center justify-center bg-red-500 bg-opacity-80 text-white">
          <div>{errorMessage}</div>
        </div>
      ) : loadProgress < 1 && (
        <div className="absolute inset-0 z-10 flex items-center justify-center bg-black bg-opacity-80">
          {/* Simple Tailwind spinner */}
          <Progress
            className="relative h-[15px] w-[200px] overflow-hidden rounded-full bg-blackA6"
            style={{
              // Fix overflow clipping in Safari
              // https://gist.github.com/domske/b66047671c780a238b51c51ffde8d3a0
              transform: "translateZ(0)",
            }}
            value={loadProgress*100}
          >
            <ProgressIndicator
              className="ease-[cubic-bezier(0.65, 0, 0.35, 1)] size-full bg-white transition-transform duration-[660ms]"
              style={{ transform: `translateX(-${100 - loadProgress*100}%)` }}
            />
          </Progress>
        </div>
      )}
    </div>
  )
}



================================================
FILE: ai_agents/playground/src/components/Agent/Camera.tsx
================================================
"use client"

import * as React from "react"
// import CamSelect from "./camSelect"
import { CamIconByStatus } from "@/components/Icon"
import AgoraRTC, { ICameraVideoTrack, ILocalVideoTrack } from "agora-rtc-sdk-ng"
// import { LocalStreamPlayer } from "../streamPlayer"
// import { useSmallScreen } from "@/common"
import {
  DeviceSelect,
} from "@/components/Agent/Microphone"
import { Button } from "@/components/ui/button"
import { LocalStreamPlayer } from "@/components/Agent/StreamPlayer"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "../ui/select"
import { VIDEO_SOURCE_OPTIONS, VideoSourceType } from "@/common"
import { MonitorIcon, MonitorXIcon } from "lucide-react"


export const ScreenIconByStatus = (
  props: React.SVGProps<SVGSVGElement> & { active?: boolean; color?: string },
) => {
  const { active, color, ...rest } = props
  if (active) {
    return <MonitorIcon color={color || "#3D53F5"} {...rest} />
  }
  return <MonitorXIcon color={color || "#667085"} {...rest} />
}

export function VideoDeviceWrapper(props: {
  children: React.ReactNode
  title: string
  Icon: (
    props: React.SVGProps<SVGSVGElement> & { active?: boolean },
  ) => React.ReactNode
  onIconClick: () => void
  videoSourceType: VideoSourceType
  onVideoSourceChange: (value: VideoSourceType) => void
  isActive: boolean
  select?: React.ReactNode
}) {
  const { Icon, onIconClick, isActive, select, children, onVideoSourceChange, videoSourceType } = props

  return (
    <div className="flex flex-col">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-4">
          <div className="text-sm font-medium">{props.title}</div>
          <div className="w-[150px]">
            <Select value={videoSourceType} onValueChange={onVideoSourceChange}>
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {VIDEO_SOURCE_OPTIONS.map((item) => (
                  <SelectItem key={item.value} value={item.value}>
                    {item.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>
        <div className="flex items-center gap-2">
          <Button
            variant="outline"
            size="icon"
            className="border-secondary bg-transparent"
            onClick={onIconClick}
          >
            <Icon className="h-5 w-5" active={isActive} />
          </Button>
          {select}
        </div>
      </div>
      {children}
    </div>
  )
}

export default function VideoBlock(props: {
  videoSourceType:VideoSourceType,
  onVideoSourceChange:(value: VideoSourceType) => void,
  cameraTrack?: ICameraVideoTrack,
  screenTrack?: ILocalVideoTrack
}) {
  const { videoSourceType, cameraTrack, screenTrack, onVideoSourceChange } = props
  const [videoMute, setVideoMute] = React.useState(false)

  React.useEffect(() => {
    cameraTrack?.setMuted(videoMute)
    screenTrack?.setMuted(videoMute)
  }, [cameraTrack, screenTrack, videoMute])

  const onClickMute = () => {
    setVideoMute(!videoMute)
  }

  return (
    <VideoDeviceWrapper
      title="VIDEO"
      Icon={videoSourceType === VideoSourceType.CAMERA ? CamIconByStatus : ScreenIconByStatus}
      onIconClick={onClickMute}
      isActive={!videoMute}
      videoSourceType={videoSourceType}
      onVideoSourceChange={onVideoSourceChange}
      select={videoSourceType === VideoSourceType.CAMERA ? <CamSelect videoTrack={cameraTrack} /> : <div className="w-[180px]" />}
    >
      <div className="my-3 h-60 w-full overflow-hidden rounded-lg">
        <LocalStreamPlayer videoTrack={videoSourceType === VideoSourceType.CAMERA ? cameraTrack : screenTrack} />
      </div>
    </VideoDeviceWrapper>
  )
}

interface SelectItem {
  label: string
  value: string
  deviceId: string
}

const DEFAULT_ITEM: SelectItem = {
  label: "Default",
  value: "default",
  deviceId: "",
}

const CamSelect = (props: { videoTrack?: ICameraVideoTrack }) => {
  const { videoTrack } = props
  const [items, setItems] = React.useState<SelectItem[]>([DEFAULT_ITEM])
  const [value, setValue] = React.useState("default")

  React.useEffect(() => {
    if (videoTrack) {
      const label = videoTrack?.getTrackLabel()
      setValue(label)
      AgoraRTC.getCameras().then((arr) => {
        setItems(
          arr.map((item) => ({
            label: item.label,
            value: item.label,
            deviceId: item.deviceId,
          })),
        )
      })
    }
  }, [videoTrack])

  const onChange = async (value: string) => {
    const target = items.find((item) => item.value === value)
    if (target) {
      setValue(target.value)
      if (videoTrack) {
        await videoTrack.setDevice(target.deviceId)
      }
    }
  }

  return (
    <DeviceSelect
      items={items}
      value={value}
      onChange={onChange}
      placeholder="Select a camera"
    />
  )
}



================================================
FILE: ai_agents/playground/src/components/Agent/Microphone.tsx
================================================
"use client"

import * as React from "react"
import { useMultibandTrackVolume } from "@/common"
import AudioVisualizer from "@/components/Agent/AudioVisualizer"
import AgoraRTC, { IMicrophoneAudioTrack } from "agora-rtc-sdk-ng"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Button } from "@/components/ui/button"
import { MicIconByStatus } from "@/components/Icon"

export default function MicrophoneBlock(props: {
  audioTrack?: IMicrophoneAudioTrack
}) {
  const { audioTrack } = props
  const [audioMute, setAudioMute] = React.useState(false)
  const [mediaStreamTrack, setMediaStreamTrack] =
    React.useState<MediaStreamTrack>()

  React.useEffect(() => {
    audioTrack?.on("track-updated", onAudioTrackupdated)
    if (audioTrack) {
      setMediaStreamTrack(audioTrack.getMediaStreamTrack())
    }

    return () => {
      audioTrack?.off("track-updated", onAudioTrackupdated)
    }
  }, [audioTrack])

  React.useEffect(() => {
    audioTrack?.setMuted(audioMute)
  }, [audioTrack, audioMute])

  const subscribedVolumes = useMultibandTrackVolume(mediaStreamTrack, 20)

  const onAudioTrackupdated = (track: MediaStreamTrack) => {
    console.log("[test] audio track updated", track)
    setMediaStreamTrack(track)
  }

  const onClickMute = () => {
    setAudioMute(!audioMute)
  }

  return (
    <CommonDeviceWrapper
      title="MICROPHONE"
      Icon={MicIconByStatus}
      onIconClick={onClickMute}
      isActive={!audioMute}
      select={<MicrophoneSelect audioTrack={audioTrack} />}
    >
      <div className="mt-3 flex h-12 flex-col items-center justify-center gap-2.5 self-stretch rounded-md border border-[#272A2F] bg-[#1E2024] p-2 shadow-[0px_2px_2px_0px_rgba(0,0,0,0.25)]">
        <AudioVisualizer
          type="user"
          barWidth={4}
          minBarHeight={2}
          maxBarHeight={20}
          frequencies={subscribedVolumes}
          borderRadius={2}
          gap={4}
        />
      </div>
    </CommonDeviceWrapper>
  )
}

export function CommonDeviceWrapper(props: {
  children: React.ReactNode
  title: string
  Icon: (
    props: React.SVGProps<SVGSVGElement> & { active?: boolean },
  ) => React.ReactNode
  onIconClick: () => void
  isActive: boolean
  select?: React.ReactNode
}) {
  const { title, Icon, onIconClick, isActive, select, children } = props

  return (
    <div className="flex flex-col">
      <div className="flex items-center justify-between">
        <div className="text-sm font-medium">{title}</div>
        <div className="flex items-center gap-2">
          <Button
            variant="outline"
            size="icon"
            className="border-secondary bg-transparent"
            onClick={onIconClick}
          >
            <Icon className="h-5 w-5" active={isActive} />
          </Button>
          {select}
        </div>
      </div>
      {children}
    </div>
  )
}

export type TDeviceSelectItem = {
  label: string
  value: string
  deviceId: string
}

export const DEFAULT_DEVICE_ITEM: TDeviceSelectItem = {
  label: "Default",
  value: "default",
  deviceId: "",
}

export const DeviceSelect = (props: {
  items: TDeviceSelectItem[]
  value: string
  onChange: (value: string) => void
  placeholder?: string
}) => {
  const { items, value, onChange, placeholder } = props

  return (
    <Select value={value} onValueChange={onChange}>
      <SelectTrigger className="w-[180px]">
        <SelectValue placeholder={placeholder} />
      </SelectTrigger>
      <SelectContent>
        {items.map((item) => (
          <SelectItem key={item.value} value={item.value}>
            {item.label}
          </SelectItem>
        ))}
      </SelectContent>
    </Select>
  )
}

export const MicrophoneSelect = (props: {
  audioTrack?: IMicrophoneAudioTrack
}) => {
  const { audioTrack } = props
  const [items, setItems] = React.useState<TDeviceSelectItem[]>([
    DEFAULT_DEVICE_ITEM,
  ])
  const [value, setValue] = React.useState("default")

  React.useEffect(() => {
    if (audioTrack) {
      const label = audioTrack?.getTrackLabel()
      setValue(label)
      AgoraRTC.getMicrophones().then((arr) => {
        setItems(
          arr.map((item) => ({
            label: item.label,
            value: item.label,
            deviceId: item.deviceId,
          })),
        )
      })
    }
  }, [audioTrack])

  const onChange = async (value: string) => {
    const target = items.find((item) => item.value === value)
    if (target) {
      setValue(target.value)
      if (audioTrack) {
        await audioTrack.setDevice(target.deviceId)
      }
    }
  }

  return <DeviceSelect items={items} value={value} onChange={onChange} />
}



================================================
FILE: ai_agents/playground/src/components/Agent/StreamPlayer.tsx
================================================
"use client"

import * as React from "react"
import {
  ICameraVideoTrack,
  ILocalVideoTrack,
  IMicrophoneAudioTrack,
  VideoPlayerConfig,
} from "agora-rtc-sdk-ng"

export interface StreamPlayerProps {
  videoTrack?: ICameraVideoTrack | ILocalVideoTrack
  audioTrack?: IMicrophoneAudioTrack
  style?: React.CSSProperties
  fit?: "cover" | "contain" | "fill"
  onClick?: () => void
  mute?: boolean
}

export const LocalStreamPlayer = React.forwardRef(
  (props: StreamPlayerProps, ref) => {
    const {
      videoTrack,
      audioTrack,
      mute = false,
      style = {},
      fit = "cover",
      onClick = () => {},
    } = props
    const vidDiv = React.useRef(null)

    React.useLayoutEffect(() => {
      const config = { fit } as VideoPlayerConfig
      if (mute) {
        videoTrack?.stop()
      } else {
        if (!videoTrack?.isPlaying) {
          videoTrack?.play(vidDiv.current!, config)
        }
      }

      return () => {
        videoTrack?.stop()
      }
    }, [videoTrack, fit, mute])

    // local audio track need not to be played
    // useLayoutEffect(() => {}, [audioTrack, localAudioMute])

    return (
      <div
        className="relative h-full w-full overflow-hidden"
        style={style}
        ref={vidDiv}
        onClick={onClick}
      />
    )
  },
)



================================================
FILE: ai_agents/playground/src/components/Agent/View.tsx
================================================
"use client"

import { useMultibandTrackVolume } from "@/common"
import { cn } from "@/lib/utils"
// import AudioVisualizer from "../audioVisualizer"
import { IMicrophoneAudioTrack } from "agora-rtc-sdk-ng"
import AudioVisualizer from "@/components/Agent/AudioVisualizer"

export interface AgentViewProps {
  audioTrack?: IMicrophoneAudioTrack
}

export default function AgentView(props: AgentViewProps) {
  const { audioTrack } = props

  const subscribedVolumes = useMultibandTrackVolume(audioTrack, 12)

  return (
    <div
      className={cn(
        "flex h-auto w-full flex-col items-center justify-center px-4 py-5",
        "bg-[#0F0F11] bg-gradient-to-br from-[rgba(27,66,166,0.16)] via-[rgba(27,45,140,0.00)] to-[#11174E] shadow-[0px_3.999px_48.988px_0px_rgba(0,7,72,0.12)] backdrop-blur-[7px]",
      )}
    >
      <div className="mb-2 text-lg font-semibold text-[#EAECF0]">Agent</div>
      <div className="mt-8 h-14 w-full">
        <AudioVisualizer
          type="agent"
          frequencies={subscribedVolumes}
          barWidth={6}
          minBarHeight={6}
          maxBarHeight={56}
          borderRadius={2}
          gap={6}
        />
      </div>
    </div>
  )
}



================================================
FILE: ai_agents/playground/src/components/Agent/VoicePresetSelect.tsx
================================================
"use client"

import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { useAppSelector, useAppDispatch, VOICE_OPTIONS } from "@/common"
import { setVoiceType } from "@/store/reducers/global"
import type { VoiceType } from "@/types"
import { VoiceIcon } from "@/components/Icon"

export default function AgentVoicePresetSelect() {
  const dispatch = useAppDispatch()
  const options = useAppSelector((state) => state.global.options)
  const voiceType = useAppSelector((state) => state.global.voiceType)

  const onVoiceChange = (value: string) => {
    dispatch(setVoiceType(value as VoiceType))
  }

  return (
    <Select value={voiceType} onValueChange={onVoiceChange}>
      <SelectTrigger className="w-[180px]">
        <div className="inline-flex items-center gap-2">
          <SelectValue placeholder="Voice" />
        </div>
      </SelectTrigger>
      <SelectContent>
        {VOICE_OPTIONS.map((option) => (
          <SelectItem
            key={option.value}
            value={option.value}
            className="flex items-center gap-2"
          >
            <span className="flex items-center gap-2">
              <VoiceIcon className="h-4 w-4" />
              {option.label}
            </span>
          </SelectItem>
        ))}
      </SelectContent>
    </Select>
  )
}



================================================
FILE: ai_agents/playground/src/components/authInitializer/index.tsx
================================================
"use client"

import { ReactNode, useEffect } from "react"
import { useAppDispatch, getOptionsFromLocal, getRandomChannel, getRandomUserId, useAppSelector, getTrulienceSettingsFromLocal } from "@/common"
import { setOptions, reset, fetchGraphDetails, setTrulienceSettings } from "@/store/reducers/global"
import { useGraphs } from "@/common/hooks";

interface AuthInitializerProps {
  children: ReactNode;
}

const AuthInitializer = (props: AuthInitializerProps) => {
  const { children } = props;
  const dispatch = useAppDispatch()
  const { initialize } = useGraphs()
  const selectedGraphId = useAppSelector((state) => state.global.selectedGraphId)
  const graphList = useAppSelector((state) => state.global.graphList)

  useEffect(() => {
    if (typeof window !== "undefined") {
      const options = getOptionsFromLocal()
      const trulienceSettings = getTrulienceSettingsFromLocal()
      initialize()
      if (options && options.channel) {
        dispatch(reset())
        dispatch(setOptions(options))
        dispatch(setTrulienceSettings(trulienceSettings))
      } else {
        dispatch(reset())
        dispatch(setOptions({
          channel: getRandomChannel(),
          userId: getRandomUserId(),
        }))
      }
    }
  }, [dispatch])

  useEffect(() => {
    if (selectedGraphId) {
      const graph = graphList.find((g) => g.uuid === selectedGraphId)
      if (!graph) {
        return
      }
      dispatch(fetchGraphDetails(graph));
    }
  }, [selectedGraphId, graphList, dispatch]); // Automatically fetch details when `selectedGraphId` changes

  return children
}


export default AuthInitializer;



================================================
FILE: ai_agents/playground/src/components/Button/LoadingButton.tsx
================================================
import { Button, ButtonProps } from "@/components/ui/button"
import { AnimatedSpinnerIcon } from "@/components/Icon"

export interface LoadingButtonProps extends Omit<ButtonProps, "asChild"> {
  loading?: boolean
  svgProps?: React.SVGProps<SVGSVGElement>
}

export function LoadingButton(props: LoadingButtonProps) {
  const { loading, disabled, children, svgProps, ...rest } = props
  return (
    <Button {...rest} disabled={loading || disabled}>
      {loading && <AnimatedSpinnerIcon {...svgProps} />}
      {children}
    </Button>
  )
}



================================================
FILE: ai_agents/playground/src/components/Chat/ChatCard.tsx
================================================
"use client";

import * as React from "react";
import { cn } from "@/lib/utils";
import {
  RemotePropertyCfgSheet,
} from "@/components/Chat/ChatCfgPropertySelect";
import PdfSelect from "@/components/Chat/PdfSelect";
import {
  genRandomChatList,
  useAppDispatch,
  useAutoScroll,
  LANGUAGE_OPTIONS,
  useAppSelector,
  GRAPH_OPTIONS,
  isRagGraph,
  isEditModeOn,
} from "@/common";
import {
  setRtmConnected,
  addChatItem,
  setSelectedGraphId,
  setLanguage,
} from "@/store/reducers/global";
import MessageList from "@/components/Chat/MessageList";
import { Button } from "@/components/ui/button";
import { Send } from "lucide-react";
import { rtmManager } from "@/manager/rtm";
import { type IRTMTextItem, EMessageDataType, EMessageType, ERTMTextType } from "@/types";
import { RemoteGraphSelect } from "@/components/Chat/ChatCfgGraphSelect";
import { RemoteModuleCfgSheet } from "@/components/Chat/ChatCfgModuleSelect";

export default function ChatCard(props: { className?: string }) {
  const { className } = props;
  const [modal2Open, setModal2Open] = React.useState(false);
  const [inputValue, setInputValue] = React.useState("");

  const rtmConnected = useAppSelector((state) => state.global.rtmConnected);
  const dispatch = useAppDispatch();
  const graphName = useAppSelector((state) => state.global.selectedGraphId);
  const agentConnected = useAppSelector((state) => state.global.agentConnected);
  const options = useAppSelector((state) => state.global.options);

  const disableInputMemo = React.useMemo(() => {
    return (
      !options.channel ||
      !options.userId ||
      !options.appId ||
      !options.token ||
      !rtmConnected ||
      !agentConnected
    );
  }, [
    options.channel,
    options.userId,
    options.appId,
    options.token,
    rtmConnected,
    agentConnected,
  ]);

  // const chatItems = genRandomChatList(10)
  const chatRef = React.useRef(null);

  useAutoScroll(chatRef);

  const onTextChanged = (text: IRTMTextItem) => {
    console.log("[rtm] onTextChanged", text);
    if (text.type == ERTMTextType.TRANSCRIBE) {
      // const isAgent = Number(text.uid) != Number(options.userId)
      dispatch(
        addChatItem({
          userId: options.userId,
          text: text.text,
          type: text.stream_id === "0" ? EMessageType.AGENT : EMessageType.USER,
          data_type: EMessageDataType.TEXT,
          isFinal: text.is_final,
          time: text.ts,
        })
      );
    }
    if (text.type == ERTMTextType.INPUT_TEXT) {
      dispatch(
        addChatItem({
          userId: options.userId,
          text: text.text,
          type: EMessageType.USER,
          data_type: EMessageDataType.TEXT,
          isFinal: true,
          time: text.ts,
        })
      );
    }
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setInputValue(e.target.value);
  };

  const handleInputSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!inputValue || disableInputMemo) {
      return;
    }
    rtmManager.sendText(inputValue);
    setInputValue("");
  };

  return (
    <>
      {/* Chat Card */}
      <div className={cn("h-full overflow-hidden min-h-0 flex", className)}>
        <div className="flex w-full flex-col p-4 flex-1">
          {/* Scrollable messages container */}
          <div className="flex-1 overflow-y-auto" ref={chatRef}>
            <MessageList />
          </div>
          {/* Input area */}
          <div
            className={cn("border-t pt-4", {
              ["hidden"]: !graphName.includes("rtm"), // TODO: TMP use rtm key word
            })}
          >
            <form onSubmit={handleInputSubmit} className="flex items-center space-x-2">
              <input
                type="text"
                disabled={disableInputMemo}
                placeholder="Type a message..."
                value={inputValue}
                onChange={handleInputChange}
                className={cn(
                  "flex-grow rounded-md border bg-background p-1.5 focus:outline-none focus:ring-1 focus:ring-ring",
                  {
                    ["cursor-not-allowed"]: disableInputMemo,
                  }
                )}
              />
              <Button
                type="submit"
                disabled={disableInputMemo || inputValue.length === 0}
                size="icon"
                variant="outline"
                className={cn("bg-transparent", {
                  ["opacity-50"]: disableInputMemo || inputValue.length === 0,
                  ["cursor-not-allowed"]: disableInputMemo,
                })}
              >
                <Send className="h-4 w-4" />
                <span className="sr-only">Send message</span>
              </Button>
            </form>
          </div>
        </div>
      </div>
    </>
  );

}



================================================
FILE: ai_agents/playground/src/components/Chat/ChatCfgGraphSelect.tsx
================================================
import * as React from "react"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { useAppDispatch, useAppSelector } from "@/common/hooks"
import {
  setSelectedGraphId,
} from "@/store/reducers/global"
import { useIsCompactLayout } from "@/common"
import { cn } from "@/lib/utils"


export function RemoteGraphSelect() {
  const dispatch = useAppDispatch()
  const graphName = useAppSelector((state) => state.global.selectedGraphId)
  const graphs = useAppSelector((state) => state.global.graphList)
  const agentConnected = useAppSelector((state) => state.global.agentConnected)

  const onGraphNameChange = (val: string) => {
    dispatch(setSelectedGraphId(val))
  }

  const graphOptions = graphs.map((item) => ({
    label: item.name,
    value: item.uuid,
  }))

  return (
    <>
      <Select
        value={graphName}
        onValueChange={onGraphNameChange}
        disabled={agentConnected}
      >
        <SelectTrigger
          className={cn(
            "w-auto", // or "w-auto max-w-full" if you want to keep the existing defaults
          )}
        >
          <SelectValue placeholder={"Select Graph"} />
        </SelectTrigger>
        <SelectContent>
          {graphOptions.map((item) => (
            <SelectItem key={item.value} value={item.value}>
              {item.label}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </>
  )
}



================================================
FILE: ai_agents/playground/src/components/Chat/ChatCfgModuleSelect.tsx
================================================
import * as React from "react"
import { buttonVariants } from "@/components/ui/button"
import {
    Select,
    SelectContent,
    SelectGroup,
    SelectItem,
    SelectLabel,
    SelectTrigger,
    SelectValue,
} from "@/components/ui/select"
import {
    Sheet,
    SheetContent,
    SheetDescription,
    SheetHeader,
    SheetTitle,
    SheetTrigger,
} from "@/components/ui/sheet"
import {
    Form,
    FormControl,
    FormDescription,
    FormField,
    FormItem,
    FormLabel,
    FormMessage,
} from "@/components/ui/form"
import { Button } from "@/components/ui/button"
import { cn } from "@/lib/utils"
import { useAppSelector, useGraphs } from "@/common/hooks"
import { AddonDef, Graph, Destination, GraphEditor, ProtocolLabel as GraphConnProtocol, ProtocolLabel } from "@/common/graph"
import { toast } from "sonner"
import { BoxesIcon, ChevronRightIcon, LoaderCircleIcon, Trash2Icon, WrenchIcon } from "lucide-react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuPortal, DropdownMenuSub, DropdownMenuSubContent, DropdownMenuSubTrigger, DropdownMenuTrigger } from "../ui/dropdown"
import { apiAddConnection, apiAddNode, apiGetDefaultProperty, apiRemoveNode, apiReplaceNodeModule, isLLM } from "@/common"
import { compatibleTools, ModuleRegistry, ModuleTypeLabels, moduleRegistry, toolModuleRegistry } from "@/common/moduleConfig"
import { fetchGraphDetails } from "@/store/reducers/global"

export function RemoteModuleCfgSheet() {
    const addonModules = useAppSelector((state) => state.global.addonModules);
    const { getGraphNodeAddonByName, selectedGraph, updateGraph, installedAndRegisteredModulesMap, installedAndRegisteredToolModules } = useGraphs();

    const metadata = React.useMemo(() => {
        const dynamicMetadata: Record<string, { type: string; options: { value: string; label: string }[] }> = {};

        if (selectedGraph) {
            Object.keys(installedAndRegisteredModulesMap).forEach((key) => {
                const moduleTypeKey = key as ModuleRegistry.NonToolModuleType;

                // Check if the current graph has a node whose name contains the ModuleType
                const hasMatchingNode = selectedGraph.nodes.some((node) =>
                    node.name.includes(moduleTypeKey)
                );

                if (hasMatchingNode) {
                    dynamicMetadata[moduleTypeKey] = {
                        type: "string",
                        options: installedAndRegisteredModulesMap[moduleTypeKey].map((module) => ({
                            value: module.name,
                            label: module.label,
                        })),
                    };
                }
            });
        }

        return dynamicMetadata;
    }, [installedAndRegisteredModulesMap, selectedGraph]);

    const initialData = React.useMemo(() => {
        const dynamicInitialData: Record<string, string | null | undefined> = {};

        if (selectedGraph) {
            Object.keys(installedAndRegisteredModulesMap).forEach((key) => {
                const moduleTypeKey = key as ModuleRegistry.ModuleType;

                // Check if the current graph has a node whose name contains the ModuleType
                const hasMatchingNode = selectedGraph.nodes.some((node) =>
                    node.name.includes(moduleTypeKey)
                );

                if (hasMatchingNode) {
                    dynamicInitialData[moduleTypeKey] = getGraphNodeAddonByName(moduleTypeKey)?.addon;
                }
            });
        }

        return dynamicInitialData;
    }, [installedAndRegisteredModulesMap, selectedGraph, getGraphNodeAddonByName]);


    return (
        <Sheet>
            <SheetTrigger
                className={cn(
                    buttonVariants({ variant: "outline", size: "icon" }),
                    "bg-transparent"
                )}
            >
                <BoxesIcon />
            </SheetTrigger>
            <SheetContent className="w-[400px] overflow-y-auto sm:w-[540px]">
                <SheetHeader>
                    <SheetTitle>Module Picker</SheetTitle>
                    <SheetDescription>
                        You can adjust STT/TTS/LLM/LLMv2v extension modules here, the values will be
                        written into property.json file when you save.
                    </SheetDescription>
                </SheetHeader>

                <div className="my-4">
                    <GraphModuleCfgForm
                        initialData={initialData}
                        metadata={metadata}
                        onUpdate={async (data, tools) => {
                            try {
                                // Clone the selectedGraph to avoid mutating the original graph
                                const selectedGraphCopy: Graph = JSON.parse(JSON.stringify(selectedGraph));
                                const nodes = selectedGraphCopy.nodes;
                                let needUpdate = false;
                                let enableRTCVideoSubscribe = false;


                                // Retrieve the agora_rtc node
                                const agoraRtcNode = GraphEditor.findNode(selectedGraphCopy, "agora_rtc");
                                if (!agoraRtcNode) {
                                    toast.error("agora_rtc node not found in the graph");
                                    return;
                                }

                                // Update graph nodes with selected modules
                                Object.entries(data).forEach(([key, value]) => {
                                    const node = nodes.find((n) => n.name === key);
                                    if (node && value && node.addon !== value) {
                                        node.addon = value;
                                        node.property = addonModules.find((module) => module.name === value)?.defaultProperty;
                                        needUpdate = true;
                                    }
                                });

                                const reasoningNodesWithVisualSupport = GraphEditor.findNodeByPredicate(selectedGraphCopy, (node) => {
                                    const module = moduleRegistry[node.addon]
                                    if (!module) {
                                        return false
                                    }

                                    if (module.type === ModuleRegistry.ModuleType.LLM) {
                                        const llmModule = module as ModuleRegistry.LLMModule
                                        return isLLM(node.name) && llmModule.options.inputModalities.includes(ModuleRegistry.Modalities.Video)
                                    }

                                    if (module.type === ModuleRegistry.ModuleType.V2V) {
                                        const v2vModule = module as ModuleRegistry.V2VModule
                                        return isLLM(node.name) && v2vModule.options.inputModalities.includes(ModuleRegistry.Modalities.Video)
                                    }

                                    return false
                                })

                                if (reasoningNodesWithVisualSupport) {
                                    GraphEditor.addOrUpdateConnection(
                                        selectedGraphCopy,
                                        `${agoraRtcNode.name}`,
                                        `${reasoningNodesWithVisualSupport.name}`,
                                        ProtocolLabel.VIDEO_FRAME,
                                        "video_frame"
                                    );
                                    enableRTCVideoSubscribe = true;
                                }

                                // Identify removed tools and process them
                                const currentToolsInGraph = nodes
                                    .filter((node) => installedAndRegisteredToolModules.map((module) => module.name).includes(node.addon))
                                    .map((node) => node.addon);

                                const removedTools = currentToolsInGraph.filter((tool) => !tools.includes(tool));
                                removedTools.forEach((tool) => {
                                    GraphEditor.removeNodeAndConnections(selectedGraphCopy, tool);
                                    needUpdate = true;
                                });

                                // Process tool modules
                                if (tools.length > 0) {
                                    if (!enableRTCVideoSubscribe) {
                                        enableRTCVideoSubscribe = tools.some((tool) => tool.includes("vision"))
                                    }
                                    tools.forEach((tool) => {
                                        if (!currentToolsInGraph.includes(tool)) {
                                            const toolModule = addonModules.find((module) => module.name === tool);

                                            if (!toolModule) {
                                                toast.error(`Module ${tool} not found`);
                                                return;
                                            }

                                            const toolNode = GraphEditor.addNode(selectedGraphCopy, tool, tool, "default", toolModule.defaultProperty)

                                            // Create or update connections
                                            const llmNode = GraphEditor.findNodeByPredicate(selectedGraphCopy, (node) => isLLM(node.name));
                                            if (llmNode) {
                                                GraphEditor.linkTool(selectedGraphCopy, llmNode, toolNode, toolModuleRegistry[tool]);
                                            }
                                        }
                                    });
                                    needUpdate = true;
                                }

                                GraphEditor.enableRTCVideoSubscribe(selectedGraphCopy, enableRTCVideoSubscribe);

                                // Perform the update if changes are detected
                                if (needUpdate) {
                                    await updateGraph(selectedGraph, selectedGraphCopy);
                                    toast.success("Modules updated", {
                                        description: `Graph: ${selectedGraphCopy.uuid}`,
                                    });
                                }
                            } catch (e: any) {
                                toast.error(`Failed to update modules: ${e}`);
                            }
                        }}

                    />
                </div>
            </SheetContent>
        </Sheet>
    );
}

const GraphModuleCfgForm = ({
    initialData,
    metadata,
    onUpdate,
}: {
    initialData: Record<string, string | null | undefined>;
    metadata: Record<string, { type: string; options: { value: string, label: string }[] }>;
    onUpdate: (data: Record<string, string | null>, tools: string[]) => void;
}) => {
    const formSchema = z.record(z.string(), z.string().nullable());
    const form = useForm<z.infer<typeof formSchema>>({
        resolver: zodResolver(formSchema),
        defaultValues: initialData,
    });
    const { selectedGraph, installedAndRegisteredToolModules } = useGraphs();
    const { watch } = form;

    // Watch for changes in "llm" and "v2v" fields
    const llmValue = watch("llm");
    const v2vValue = watch("v2v");
    const toolModules = React.useMemo(() => {
        // Step 1: Get installed and registered tool modules
        const allToolModules = installedAndRegisteredToolModules || [];

        // Step 2: Determine the active module based on form values
        const activeModule = llmValue || v2vValue;

        // Step 3: Get compatible tools for the active module
        if (activeModule) {
            const compatibleToolNames = compatibleTools[activeModule] || [];
            return allToolModules.filter((module) => compatibleToolNames.includes(module.name));
        }

        // If no LLM or V2V module is selected, return all tool modules
        return [];
    }, [installedAndRegisteredToolModules, selectedGraph, llmValue, v2vValue]);


    const onSubmit = (data: z.infer<typeof formSchema>) => {
        onUpdate(data, selectedTools);
    };

    const [selectedTools, setSelectedTools] = React.useState<string[]>([]);

    // Synchronize selectedTools with selectedGraph and toolModules
    React.useEffect(() => {
        const toolNames = toolModules.map((module) => module.name);
        const graphToolAddons =
            selectedGraph?.nodes
                .filter((node) => toolNames.includes(node.addon))
                .map((node) => node.addon) || [];
        setSelectedTools(graphToolAddons);
    }, [toolModules, selectedGraph]);

    // Desired field order
    const fieldOrder: ModuleRegistry.NonToolModuleType[] = [
        ModuleRegistry.ModuleType.STT,
        ModuleRegistry.ModuleType.LLM,
        ModuleRegistry.ModuleType.V2V,
        ModuleRegistry.ModuleType.TTS,
    ];
    return (
        <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
                {fieldOrder.map(
                    (key) =>
                        metadata[key] && ( // Check if the field exists in metadata
                            <div key={key} className="space-y-2">
                                <FormField
                                    control={form.control}
                                    name={key}
                                    render={({ field }) => (
                                        <FormItem>
                                            <FormLabel>
                                                <div className="flex items-center justify-between ">
                                                    <div className="py-3">{ModuleTypeLabels[key]}</div>
                                                    {isLLM(key) && (
                                                        <DropdownMenu>
                                                            <DropdownMenuTrigger className={cn(
                                                                buttonVariants({ variant: "outline", size: "icon" }),
                                                                "bg-transparent",
                                                            )}><WrenchIcon />
                                                            </DropdownMenuTrigger>
                                                            <DropdownMenuContent>
                                                                <DropdownMenuSub>
                                                                    <DropdownMenuSubTrigger icon={<ChevronRightIcon size={15} />} className="flex justify-between">
                                                                        Add Tools
                                                                    </DropdownMenuSubTrigger>
                                                                    <DropdownMenuPortal>
                                                                        <DropdownMenuSubContent
                                                                            className="DropdownMenuSubContent"
                                                                            sideOffset={2}
                                                                            alignOffset={-5}
                                                                        >
                                                                            {toolModules.length > 0 ? toolModules.map((module) => (
                                                                                <DropdownMenuItem
                                                                                    key={module.name}
                                                                                    disabled={selectedTools.includes(module.name)} // Disable if the tool is already selected
                                                                                    onClick={() => {
                                                                                        if (!selectedTools.includes(module.name)) {
                                                                                            setSelectedTools((prev) => [
                                                                                                ...prev,
                                                                                                module.name,
                                                                                            ]);
                                                                                        }
                                                                                    }}>
                                                                                    {module.name}
                                                                                </DropdownMenuItem>
                                                                            )) : (
                                                                                <DropdownMenuItem disabled>No compatible tools</DropdownMenuItem>
                                                                            )}
                                                                        </DropdownMenuSubContent>
                                                                    </DropdownMenuPortal>
                                                                </DropdownMenuSub>
                                                            </DropdownMenuContent>
                                                        </DropdownMenu>
                                                    )}
                                                </div>
                                            </FormLabel>
                                            <FormControl>
                                                <Select
                                                    value={field.value ?? ""}
                                                    onValueChange={field.onChange}
                                                >
                                                    <SelectTrigger>
                                                        <SelectValue placeholder={`Select a ${key.toUpperCase()} option`} />
                                                    </SelectTrigger>
                                                    <SelectContent>
                                                        {metadata[key].options.map((option) => (
                                                            <SelectItem key={option.value} value={option.value}>
                                                                {option.label}
                                                            </SelectItem>
                                                        ))}
                                                    </SelectContent>
                                                </Select>
                                            </FormControl>
                                        </FormItem>
                                    )}
                                />
                                {isLLM(key) && selectedTools.length > 0 && (
                                    <div className="mt-2">
                                        {selectedTools.map((tool) => (
                                            <div
                                                key={tool}
                                                className="flex items-center justify-between py-2 px-3 rounded-md"
                                            >
                                                <span className="text-sm">{tool}</span>
                                                <div
                                                    className={cn(
                                                        buttonVariants({ variant: "outline", size: "icon" }),
                                                        "bg-transparent",
                                                        "ml-2",
                                                        "cursor-pointer"
                                                    )}
                                                    onClick={() => {
                                                        setSelectedTools((prev) => prev.filter((t) => t !== tool))
                                                    }} // Delete action
                                                >
                                                    <Trash2Icon />
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        )
                )}

                <Button type="submit" disabled={form.formState.isSubmitting}>
                    {form.formState.isSubmitting ? (
                        <>
                            <LoaderCircleIcon className="h-4 w-4 animate-spin" />
                            <span>Saving...</span>
                        </>
                    ) : (
                        "Save changes"
                    )}
                </Button>
            </form>
        </Form>
    );
};



================================================
FILE: ai_agents/playground/src/components/Chat/ChatCfgPropertySelect.tsx
================================================
"use client"

import * as React from "react"
import { buttonVariants } from "@/components/ui/button"
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
  SheetFooter,
  SheetClose,
} from "@/components/ui/sheet"
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form"
import { Label } from "@/components/ui/label"
import { Button } from "@/components/ui/button"
import { Checkbox } from "@/components/ui/checkbox"
import { Input } from "@/components/ui/input"
import { Switch } from "@/components/ui/switch"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import {
  useAppDispatch,
  useAppSelector,
} from "@/common"
import { cn } from "@/lib/utils"
import { SettingsIcon, LoaderCircleIcon, BoxesIcon, Trash2Icon } from "lucide-react"
import { zodResolver } from "@hookform/resolvers/zod"
import { useForm } from "react-hook-form"
import { z } from "zod"
import { toast } from "sonner"
import { useGraphs } from "@/common/hooks"
import { AddonDef, Graph } from "@/common/graph"

export function RemotePropertyCfgSheet() {
  const dispatch = useAppDispatch()
  const { selectedGraph, updateGraph } = useGraphs()
  const graphName = useAppSelector((state) => state.global.selectedGraphId)

  const [selectedExtension, setSelectedExtension] = React.useState<string>("")
  const selectedExtensionNode = selectedGraph?.nodes.find(n => n.name === selectedExtension)
  const addonModules = useAppSelector((state) => state.global.addonModules)
  const selectedAddonModule = addonModules.find(
    (module) => module.name === selectedExtensionNode?.addon,
  )
  const hasProperty = !!selectedAddonModule?.api?.property?.properties && Object.keys(selectedAddonModule?.api?.property?.properties).length > 0

  return (
    <Sheet>
      <SheetTrigger
        className={cn(
          buttonVariants({ variant: "outline", size: "icon" }),
          "bg-transparent",
        )}
      >
        <SettingsIcon />
      </SheetTrigger>
      <SheetContent className="w-[400px] overflow-y-auto sm:w-[540px]">
        <SheetHeader>
          <SheetTitle>Properties Setting</SheetTitle>
          <SheetDescription>
            You can adjust extension properties for selected graph here, the values will be
            written into property.json file when you save.
          </SheetDescription>
        </SheetHeader>

        <div className="my-4">
          <Label>Extension</Label>
          <Select
            onValueChange={setSelectedExtension}
            value={selectedExtension}
          >
            <SelectTrigger className="mt-2 w-full">
              <SelectValue placeholder="Select extension" />
            </SelectTrigger>
            <SelectContent>
              {selectedGraph ? (selectedGraph.nodes).map((node) => (
                <SelectItem key={node.name} value={node.name}>
                  {node.name}
                </SelectItem>
              )) : null}
            </SelectContent>
          </Select>
        </div>

        {hasProperty ? selectedExtensionNode?.["property"] && (
          <GraphCfgForm
            selectedAddonModule={selectedAddonModule}
            selectedExtension={selectedExtension}
            key={`${graphName}-${selectedExtension}`}
            initialData={
              selectedExtensionNode?.["property"] || {}
            }
            metadata={
              addonModules.find(
                (module) => module.name === selectedExtensionNode?.addon,
              )?.api?.property?.properties || {}
            }
            onUpdate={async (data) => {
              // clone the overridenProperties
              const selectedGraphCopy: Graph = JSON.parse(JSON.stringify(selectedGraph))
              const nodes = selectedGraphCopy?.nodes || []
              let needUpdate = false
              for (const node of nodes) {
                if (node.name === selectedExtension) {
                  node.property = data
                  needUpdate = true
                }
              }
              if (needUpdate) {
                await updateGraph(selectedGraph, selectedGraphCopy)
                toast.success("Properties updated", {
                  description: `Graph: ${graphName}, Extension: ${selectedExtension}`,
                })
              }
            }}
          />
        ) : (
          <SheetDescription>
            No properties found for the selected extension.
          </SheetDescription>
        )}
      </SheetContent>
    </Sheet>
  )
}



export function RemotePropertyAddCfgSheet({
  selectedExtension,
  extensionNodeData,
  onUpdate,
}: {
  selectedExtension: string,
  extensionNodeData: Record<string, string | number | boolean | null>,
  onUpdate: (data: string) => void
}) {
  const dispatch = useAppDispatch()
  const { selectedGraph } = useGraphs()

  const selectedExtensionNode = selectedGraph?.nodes.find(n => n.name === selectedExtension)
  const addonModules = useAppSelector((state) => state.global.addonModules)
  const selectedAddonModule = addonModules.find(
    (module) => module.name === selectedExtensionNode?.addon,
  )
  const allProperties = Object.keys(selectedAddonModule?.api?.property?.properties || {})
  const usedProperties = Object.keys(extensionNodeData)
  const remainingProperties = allProperties.filter(
    (prop) => !usedProperties.includes(prop),
  )
  const hasRemainingProperties = remainingProperties.length > 0

  const [selectedProperty, setSelectedProperty] = React.useState<string>("")
  const [isSheetOpen, setSheetOpen] = React.useState(false) // State to control the sheet

  return (
    <Sheet open={isSheetOpen} onOpenChange={setSheetOpen}>
      <SheetTrigger asChild
      >
        <div>
          <Button type="button" variant="secondary" onClick={() => { setSheetOpen(true) }}>Add</Button>
        </div>
      </SheetTrigger>
      <SheetContent className="w-[400px] overflow-y-auto sm:w-[540px]">
        <SheetHeader>
          <SheetTitle>Property Add</SheetTitle>
          <SheetDescription>
            You can add a property into a graph extension node and configure its value.
          </SheetDescription>
        </SheetHeader>
        {hasRemainingProperties ? (
          <>
            <Select
              onValueChange={(key) => {
                setSelectedProperty(key)
              }}
              value={selectedProperty}
            >
              <SelectTrigger className="w-full my-4">
                <SelectValue placeholder="Select a property" />
              </SelectTrigger>
              <SelectContent>
                {remainingProperties.map((item) => (
                  <SelectItem key={item} value={item}>
                    {item}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>

            <Button type="submit" onClick={() => {
              setSheetOpen(false)
              if (selectedProperty !== "") {
                onUpdate(selectedProperty)
                setSelectedProperty("")
              }
            }}>Add</Button>
          </>
        ) : (
          <>
            <SheetDescription className="my-4">
              No remaining properties to add.
            </SheetDescription>
            <Button type="submit" onClick={() => {
              setSheetOpen(false)
            }}>OK</Button>
          </>
        )}

      </SheetContent>
    </Sheet>
  )
}

// Helper to convert values based on type
const convertToType = (value: any, type: string) => {
  switch (type) {
    case "int64":
    case "int32":
      return parseInt(value, 10)
    case "float64":
    case "float32":
      return parseFloat(value)
    case "bool":
      return value === true || value === "true"
    case "string":
      return String(value)
    default:
      return value
  }
}

const defaultTypeValue = (type: string) => {
  switch (type) {
    case "int64":
    case "int32":
      return 0
    case "float64":
      return 0.1
    case "bool":
      return false
    case "string":
    default:
      return ""
  }
}

import { useState } from "react"

const GraphCfgForm = ({
  selectedExtension,
  selectedAddonModule,
  initialData,
  metadata,
  onUpdate,
}: {
  selectedExtension: string,
  selectedAddonModule: AddonDef.Module | undefined,
  initialData: Record<string, string | number | boolean | null>
  metadata: Record<string, { type: string }>
  onUpdate: (data: Record<string, string | number | boolean | null>) => void
}) => {
  const formSchema = z.record(
    z.string(),
    z.union([z.string(), z.number(), z.boolean(), z.null()])
  )

  const [formData, setFormData] = useState(initialData)

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: formData,
  })

  const onSubmit = (data: z.infer<typeof formSchema>) => {
    const convertedData = Object.entries(data).reduce(
      (acc, [key, value]) => {
        const type = metadata[key]?.type || "string"
        acc[key] = value === "" ? defaultTypeValue(type) : convertToType(value, type)
        return acc
      },
      {} as Record<string, string | number | boolean | null>
    )
    onUpdate(convertedData)
  }

  const handleDelete = (key: string) => {
    const updatedData = { ...formData }
    delete updatedData[key] // Remove the specific key
    setFormData(updatedData) // Update state
    form.reset(updatedData) // Reset the form
  }

  const initialDataWithType = Object.entries(formData).reduce(
    (acc, [key, value]) => {
      acc[key] = { value, type: metadata[key]?.type || "string" }
      return acc
    },
    {} as Record<
      string,
      { value: string | number | boolean | null; type: string }
    >
  )

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        {Object.entries(initialDataWithType).map(([key, { value, type }]) => (
          <FormField
            key={key}
            control={form.control}
            name={key}
            render={({ field }) => (
              <FormItem>
                <FormLabel>{key}</FormLabel>
                <div className="flex justify-between items-center">
                  <FormControl>
                    {type === "bool" ? (
                      <div className="flex items-center space-x-2">
                        <Switch
                          checked={field.value === true}
                          onCheckedChange={field.onChange}
                        />
                      </div>
                    ) : (
                      <Input
                        {...field}
                        value={
                          field.value === null || field.value === undefined
                            ? ""
                            : field.value.toString()
                        }
                        type={type === "string" ? "text" : "number"}
                      />
                    )}
                  </FormControl>
                  <div
                    className={cn(
                      buttonVariants({ variant: "outline", size: "icon" }),
                      "bg-transparent",
                      "ml-2",
                      "cursor-pointer"
                    )}
                    onClick={() => handleDelete(key)} // Delete action
                  >
                    <Trash2Icon />
                  </div>
                </div>
              </FormItem>
            )}
          />
        ))}
        <div className="flex">
          <RemotePropertyAddCfgSheet
            selectedExtension={selectedExtension}
            extensionNodeData={formData}
            onUpdate={(key: string) => {
              let defaultProperty = selectedAddonModule?.defaultProperty || {}
              let defaultValue = defaultProperty[key]

              if (defaultValue === undefined) {
                let schema = selectedAddonModule?.api?.property?.properties || {}
                let schemaType = schema[key]?.type
                if (schemaType === "bool") {
                  defaultValue = false
                }
              }
              let updatedData = { ...formData }
              updatedData[key] = defaultValue
              setFormData(updatedData)
              form.reset(updatedData)
            }}
          />
          <Button
            className="mx-2"
            type="submit"
            disabled={form.formState.isSubmitting}
          >
            {form.formState.isSubmitting ? (
              <>
                <LoaderCircleIcon className="h-4 w-4 animate-spin" />
                <span>Saving...</span>
              </>
            ) : (
              "Save changes"
            )}
          </Button>
        </div>
      </form>
    </Form>
  )
}



================================================
FILE: ai_agents/playground/src/components/Chat/ChatCfgTrulienceSetting.tsx
================================================
import * as React from "react"
import { buttonVariants } from "@/components/ui/button"
import {
    Sheet,
    SheetContent,
    SheetDescription,
    SheetHeader,
    SheetTitle,
    SheetTrigger,
} from "@/components/ui/sheet"
import {
    Form,
    FormControl,
    FormField,
    FormItem,
    FormLabel,
} from "@/components/ui/form"
import { Button } from "@/components/ui/button"
import { cn } from "@/lib/utils"
import { LoaderCircleIcon, UsersIcon } from "lucide-react"
import { set, useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"
import { Switch } from "../ui/switch"
import { useAppDispatch, useAppSelector } from "@/common/hooks"
import { Input } from "../ui/input"
import { setTrulienceSettings } from "@/store/reducers/global"
import { toast } from "sonner"

export function TrulienceCfgSheet() {
    const dispatch = useAppDispatch()
    const trulienceSettings = useAppSelector((state) => state.global.trulienceSettings)
    return (
        <Sheet>
            <SheetTrigger
                className={cn(
                    buttonVariants({ variant: "outline", size: "icon" }),
                    "bg-transparent"
                )}
            >
                <UsersIcon />
            </SheetTrigger>
            <SheetContent className="w-[400px] overflow-y-auto sm:w-[540px]">
                <SheetHeader>
                    <SheetTitle>Trulience Avatar</SheetTitle>
                    <SheetDescription>
                        You can configure the Trulience Avatar settings here. This will give you a nice avatar for your chat.
                    </SheetDescription>
                </SheetHeader>

                <div className="my-4">
                    <TrulienceCfgForm
                        initialData={{
                            enable_trulience_avatar: trulienceSettings.enabled,
                            trulience_avatar_id: trulienceSettings.avatarId,
                            trulience_avatar_token: trulienceSettings.avatarToken,
                            trulience_large_window: trulienceSettings.avatarDesktopLargeWindow,
                            trulience_sdk_url: trulienceSettings.trulienceSDK,
                            trulience_animation_url: trulienceSettings.animationURL,
                        }}
                        onUpdate={async (data) => {
                            if (data.enable_trulience_avatar === true) {
                                if (!data.trulience_avatar_id) {
                                    toast.error("Trulience Settings", {
                                        description: `Please provide Trulience Avatar ID`,
                                    })
                                    return
                                }
                            }
                            dispatch(setTrulienceSettings({
                                enabled: data.enable_trulience_avatar as boolean,
                                avatarId: data.trulience_avatar_id as string,
                                avatarToken: data.trulience_avatar_token as string,
                                avatarDesktopLargeWindow: data.trulience_large_window as boolean,
                                trulienceSDK: data.trulience_sdk_url as string,
                                animationURL: data.trulience_animation_url as string,
                            }))
                            toast.success("Trulience Settings", {
                              description: `Settings updated successfully`,
                            })
                        }}
                    />
                </div>
            </SheetContent>
        </Sheet>
    );
}

const TrulienceCfgForm = ({
    initialData,
    onUpdate,
}: {
    initialData: Record<string, string | boolean | null | undefined>;
    onUpdate: (data: Record<string, string | boolean | null>) => void;
}) => {
    const formSchema = z.record(z.string(),
        z.union([z.string(), z.boolean(), z.null()]));
    const form = useForm<z.infer<typeof formSchema>>({
        resolver: zodResolver(formSchema),
        defaultValues: initialData,
    });
    const { watch } = form;
    // Watch for changes in "enable_trulience_avatar" field
    const enableTrulienceAvatar = watch("enable_trulience_avatar");

    const onSubmit = (data: z.infer<typeof formSchema>) => {
        onUpdate(data);
    };
    return (
        <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
                <FormField
                    key={"enable_trulience_avatar"}
                    control={form.control}
                    name={"enable_trulience_avatar"}
                    render={({ field }) => (
                        <FormItem>
                            <FormLabel>Enable Trulience Avatar</FormLabel>
                            <div className="flex justify-between items-center">
                                <FormControl>
                                    <div className="flex items-center space-x-2">
                                        <Switch
                                            checked={field.value === true}
                                            onCheckedChange={field.onChange}
                                        />
                                    </div>
                                </FormControl>
                            </div>
                        </FormItem>
                    )}
                />
                {
                    enableTrulienceAvatar && (
                        <>
                            <FormField
                                key={"trulience_avatar_id"}
                                control={form.control}
                                name={"trulience_avatar_id"}
                                render={({ field }) => (
                                    <FormItem>
                                        <FormLabel>Trulience Avatar ID</FormLabel>
                                        <div className="flex justify-between items-center">
                                            <FormControl>
                                                <Input
                                                    {...field}
                                                    value={
                                                        field.value === null || field.value === undefined
                                                            ? ""
                                                            : field.value.toString()
                                                    }
                                                    type={"text"}
                                                />
                                            </FormControl>
                                        </div>
                                    </FormItem>
                                )}
                            />
                            <FormField
                                key={"trulience_avatar_token"}
                                control={form.control}
                                name={"trulience_avatar_token"}
                                render={({ field }) => (
                                    <FormItem>
                                        <FormLabel>Trulience Avatar Token</FormLabel>
                                        <div className="flex justify-between items-center">
                                            <FormControl>
                                                <Input
                                                    {...field}
                                                    value={
                                                        field.value === null || field.value === undefined
                                                            ? ""
                                                            : field.value.toString()
                                                    }
                                                    type={"text"}
                                                />
                                            </FormControl>
                                        </div>
                                    </FormItem>
                                )}
                            />
                            <FormField
                                key={"trulience_large_window"}
                                control={form.control}
                                name={"trulience_large_window"}
                                render={({ field }) => (
                                    <FormItem>
                                        <FormLabel>Trulience Large Window</FormLabel>
                                        <div className="flex justify-between items-center">
                                            <FormControl>
                                                <div className="flex items-center space-x-2">
                                                    <Switch
                                                        checked={field.value === true}
                                                        onCheckedChange={field.onChange}
                                                    />
                                                </div>
                                            </FormControl>
                                        </div>
                                    </FormItem>
                                )}
                            />
                            <FormField
                                key={"trulience_sdk_url"}
                                control={form.control}
                                name={"trulience_sdk_url"}
                                render={({ field }) => (
                                    <FormItem>
                                        <FormLabel>Trulience SDK URL</FormLabel>
                                        <div className="flex justify-between items-center">
                                            <FormControl>
                                                <Input
                                                    {...field}
                                                    value={
                                                        field.value === null || field.value === undefined
                                                            ? ""
                                                            : field.value.toString()
                                                    }
                                                    type={"text"}
                                                />
                                            </FormControl>
                                        </div>
                                    </FormItem>
                                )}
                            />
                            <FormField
                                key={"trulience_animation_url"}
                                control={form.control}
                                name={"trulience_animation_url"}
                                render={({ field }) => (
                                    <FormItem>
                                        <FormLabel>Trulience Animation URL</FormLabel>
                                        <div className="flex justify-between items-center">
                                            <FormControl>
                                                <Input
                                                    {...field}
                                                    value={
                                                        field.value === null || field.value === undefined
                                                            ? ""
                                                            : field.value.toString()
                                                    }
                                                    type={"text"}
                                                />
                                            </FormControl>
                                        </div>
                                    </FormItem>
                                )}
                            />
                        </>
                    )
                }
                <Button type="submit" disabled={form.formState.isSubmitting}>
                    {form.formState.isSubmitting ? (
                        <>
                            <LoaderCircleIcon className="h-4 w-4 animate-spin" />
                            <span>Saving...</span>
                        </>
                    ) : (
                        "Save changes"
                    )}
                </Button>
            </form>
        </Form>
    );
};



================================================
FILE: ai_agents/playground/src/components/Chat/MessageList.tsx
================================================
import * as React from "react"
import {
  useAppDispatch,
  useAutoScroll,
  LANGUAGE_OPTIONS,
  useAppSelector,
  GRAPH_OPTIONS,
  isRagGraph,
} from "@/common"
import { Bot, Brain, MessageCircleQuestion } from "lucide-react"
import { EMessageDataType, EMessageType, type IChatItem } from "@/types"
import { Avatar, AvatarFallback } from "@/components/ui/avatar"
import { cn } from "@/lib/utils"

export default function MessageList(props: { className?: string }) {
  const { className } = props

  const chatItems = useAppSelector((state) => state.global.chatItems)

  const containerRef = React.useRef<HTMLDivElement>(null)

  useAutoScroll(containerRef)

  return (
    <div
      ref={containerRef}
      className={cn("flex-grow space-y-2 overflow-y-auto p-4", className)}
    >
      {chatItems.map((item, index) => {
        return <MessageItem data={item} key={item.time} />
      })}
    </div>
  )
}

export function MessageItem(props: { data: IChatItem }) {
  const { data } = props

  return (
    <>
      <div
        className={cn("flex items-start gap-2", {
          "flex-row-reverse": data.type === EMessageType.USER,
        })}
      >
        {data.type === EMessageType.AGENT ? data.data_type === EMessageDataType.REASON ? (
          <Avatar>
            <AvatarFallback>
              <Brain size={20} />
            </AvatarFallback>
          </Avatar>
        ) : (
          <Avatar>
            <AvatarFallback>
              <Bot />
            </AvatarFallback>
          </Avatar>
        ) : null}
        <div className="max-w-[80%] rounded-lg bg-secondary p-2 text-secondary-foreground">
          {data.data_type === EMessageDataType.IMAGE ? (
            <img src={data.text} alt="chat" className="w-full" />
          ) : (
            <p className={data.data_type === EMessageDataType.REASON ? cn(
              "text-xs",
              "text-zinc-500",
            ) : ""}>{data.text}</p>
          )}
        </div>
      </div>
    </>
  )
}



================================================
FILE: ai_agents/playground/src/components/Chat/PdfSelect.tsx
================================================
"use client"

import * as React from "react"
import { Button } from "@/components/ui/button"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { FileTextIcon } from "lucide-react"

import { OptionType, IPdfData } from "@/types"
import {
  apiGetDocumentList,
  apiUpdateDocument,
  useAppSelector,
  genUUID,
} from "@/common"
import { toast } from "sonner"

export default function PdfSelect() {
  const options = useAppSelector((state) => state.global.options)
  const { channel, userId } = options
  const [pdfOptions, setPdfOptions] = React.useState<OptionType[]>([])
  const [selectedPdf, setSelectedPdf] = React.useState<string>("")
  const agentConnected = useAppSelector((state) => state.global.agentConnected)

  React.useEffect(() => {
    if (agentConnected) {
      getPDFOptions()
    }
  }, [agentConnected])

  const getPDFOptions = async () => {
    const res = await apiGetDocumentList()
    setPdfOptions(
      res.data.map((item: any) => {
        return {
          value: item.collection,
          label: item.file_name,
        }
      }),
    )
    setSelectedPdf("")
  }

  const onUploadSuccess = (data: IPdfData) => {
    setPdfOptions([
      ...pdfOptions,
      {
        value: data.collection,
        label: data.fileName,
      },
    ])
    setSelectedPdf(data.collection)
  }

  const onSelectPdf = async (val: string) => {
    const item = pdfOptions.find((item) => item.value === val)
    if (!item) {
      //   return message.error("Please select a PDF file")
      return
    }
    setSelectedPdf(val)
    await apiUpdateDocument({
      collection: val,
      fileName: item.label,
      channel,
    })
  }

  return (
    <>
      <Dialog>
        <DialogTrigger asChild>
          <Button variant="outline" size="sm" className="w-fit bg-transparent">
            <FileTextIcon />
            PDF
          </Button>
        </DialogTrigger>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Upload & Select PDF</DialogTitle>
          </DialogHeader>
          <UploadPdf onSuccess={onUploadSuccess} />
          <div className="mt-4">
            <Select
              value={selectedPdf}
              onValueChange={onSelectPdf}
              disabled={!agentConnected}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select a PDF file" />
              </SelectTrigger>
              <SelectContent>
                {pdfOptions.map((option) => (
                  <SelectItem key={option.value} value={option.value}>
                    {option.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </DialogContent>
      </Dialog>
    </>
  )
}

export function UploadPdf({
  onSuccess,
}: {
  onSuccess?: (data: IPdfData) => void
}) {
  const agentConnected = useAppSelector((state) => state.global.agentConnected)
  const options = useAppSelector((state) => state.global.options)
  const { channel, userId } = options
  const [uploading, setUploading] = React.useState(false)

  const handleUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!agentConnected) {
      toast.error("Please connect to agent first")
      return
    }

    const file = e.target.files?.[0]
    if (!file) return

    setUploading(true)

    const formData = new FormData()
    formData.append("file", file)
    formData.append("channel_name", channel)
    formData.append("uid", String(userId))
    formData.append("request_id", genUUID())

    try {
      const response = await fetch("/api/vector/document/upload", {
        method: "POST",
        body: formData,
      })
      const data = await response.json()

      if (data.code === "0") {
        toast.success(`Upload ${file.name} success`)
        const { collection, file_name } = data.data
        onSuccess?.({
          fileName: file_name,
          collection,
        })
      } else {
        toast.info(data.msg)
      }
    } catch (err) {
      toast.error(`Upload ${file.name} failed`)
    } finally {
      setUploading(false)
    }
  }

  return (
    <div>
      <Label htmlFor="pdf-upload" className="cursor-pointer">
        <Input
          id="pdf-upload"
          type="file"
          accept="application/pdf"
          className="hidden"
          onChange={handleUpload}
          disabled={uploading}
        />
        <Button variant="outline" size="sm" disabled={uploading} asChild>
          <span>{uploading ? "Uploading..." : "Upload PDF"}</span>
        </Button>
      </Label>
    </div>
  )
}



================================================
FILE: ai_agents/playground/src/components/Dynamic/NetworkIndicator.tsx
================================================
"use client"

import * as React from "react"
import { NetworkQuality } from "agora-rtc-sdk-ng"
import { rtcManager } from "@/manager"
import { NetworkIconByLevel } from "@/components/Icon"

export default function NetworkIndicator() {
  const [networkQuality, setNetworkQuality] = React.useState<NetworkQuality>()

  React.useEffect(() => {
    rtcManager.on("networkQuality", onNetworkQuality)

    return () => {
      rtcManager.off("networkQuality", onNetworkQuality)
    }
  }, [])

  const onNetworkQuality = (quality: NetworkQuality) => {
    setNetworkQuality(quality)
  }

  return (
    <NetworkIconByLevel
      level={networkQuality?.uplinkNetworkQuality}
      className="h-4 w-4 md:h-5 md:w-5"
    />
  )
}



================================================
FILE: ai_agents/playground/src/components/Dynamic/RTCCard.tsx
================================================
"use client"

import * as React from "react"
import { cn } from "@/lib/utils"
import { ICameraVideoTrack, ILocalVideoTrack, IMicrophoneAudioTrack } from "agora-rtc-sdk-ng"
import { useAppSelector, useAppDispatch, VOICE_OPTIONS, VideoSourceType, useIsCompactLayout } from "@/common"
import { ITextItem, EMessageType, IChatItem } from "@/types"
import { rtcManager, IUserTracks, IRtcUser } from "@/manager"
import {
  setRoomConnected,
  addChatItem,
  setVoiceType,
  setOptions,
} from "@/store/reducers/global"
import AgentVoicePresetSelect from "@/components/Agent/VoicePresetSelect"
import AgentView from "@/components/Agent/View"
import Avatar from "@/components/Agent/AvatarTrulience"
import MicrophoneBlock from "@/components/Agent/Microphone"
import VideoBlock from "@/components/Agent/Camera"
import dynamic from "next/dynamic"
import ChatCard from "@/components/Chat/ChatCard"

let hasInit: boolean = false

export default function RTCCard(props: { className?: string }) {
  const { className } = props

  const dispatch = useAppDispatch()
  const options = useAppSelector((state) => state.global.options)
  const trulienceSettings = useAppSelector((state) => state.global.trulienceSettings)
  const { userId, channel } = options
  const [videoTrack, setVideoTrack] = React.useState<ICameraVideoTrack>()
  const [audioTrack, setAudioTrack] = React.useState<IMicrophoneAudioTrack>()
  const [screenTrack, setScreenTrack] = React.useState<ILocalVideoTrack>()
  const [remoteuser, setRemoteUser] = React.useState<IRtcUser>()
  const [videoSourceType, setVideoSourceType] = React.useState<VideoSourceType>(VideoSourceType.CAMERA)
  const useTrulienceAvatar = trulienceSettings.enabled
  const avatarInLargeWindow = trulienceSettings.avatarDesktopLargeWindow;

  const isCompactLayout = useIsCompactLayout();

  const DynamicChatCard = dynamic(() => import("@/components/Chat/ChatCard"), {
    ssr: false,
  });

  React.useEffect(() => {
    if (!options.channel) {
      return
    }
    if (hasInit) {
      return
    }

    init()

    return () => {
      if (hasInit) {
        destory()
      }
    }
  }, [options.channel])

  const init = async () => {
    console.log("[rtc] init")
    rtcManager.on("localTracksChanged", onLocalTracksChanged)
    rtcManager.on("textChanged", onTextChanged)
    rtcManager.on("remoteUserChanged", onRemoteUserChanged)
    await rtcManager.createCameraTracks()
    await rtcManager.createMicrophoneAudioTrack()
    await rtcManager.join({
      channel,
      userId,
    })
    dispatch(
      setOptions({
        ...options,
        appId: rtcManager.appId ?? "",
        token: rtcManager.token ?? "",
      }),
    )
    await rtcManager.publish()
    dispatch(setRoomConnected(true))
    hasInit = true
  }

  const destory = async () => {
    console.log("[rtc] destory")
    rtcManager.off("textChanged", onTextChanged)
    rtcManager.off("localTracksChanged", onLocalTracksChanged)
    rtcManager.off("remoteUserChanged", onRemoteUserChanged)
    await rtcManager.destroy()
    dispatch(setRoomConnected(false))
    hasInit = false
  }

  const onRemoteUserChanged = (user: IRtcUser) => {
    console.log("[rtc] onRemoteUserChanged", user)
    if (useTrulienceAvatar) {
      // trulience SDK will play audio in synch with mouth
      user.audioTrack?.stop();
    }
    if (user.audioTrack) {
      setRemoteUser(user)
    } 
  }

  const onLocalTracksChanged = (tracks: IUserTracks) => {
    console.log("[rtc] onLocalTracksChanged", tracks)
    const { videoTrack, audioTrack, screenTrack } = tracks
    setVideoTrack(videoTrack)
    setScreenTrack(screenTrack)
    if (audioTrack) {
      setAudioTrack(audioTrack)
    }
  }

  const onTextChanged = (text: IChatItem) => {
    console.log("[rtc] onTextChanged", text)
    dispatch(
      addChatItem(text),
    )
  }

  const onVoiceChange = (value: any) => {
    dispatch(setVoiceType(value))
  }

  const onVideoSourceTypeChange = async (value: VideoSourceType) => {
    await rtcManager.switchVideoSource(value)
    setVideoSourceType(value)
  }

  return (
    <div className={cn("flex h-full flex-col min-h-0", className)}>
      {/* Scrollable top region (Avatar or ChatCard) */}
      <div className="min-h-0 overflow-y-auto z-10">
        {useTrulienceAvatar ? (
          !avatarInLargeWindow ? (
            <div className="h-60 w-full p-1">
              <Avatar localAudioTrack={audioTrack} audioTrack={remoteuser?.audioTrack} />
            </div>
          ) : (
            !isCompactLayout &&
            <ChatCard
              className="m-0 w-full h-full rounded-b-lg bg-[#181a1d] md:rounded-lg"
            />
          )
        ) : (
          <AgentView  audioTrack={remoteuser?.audioTrack} />
        )}
      </div>

      {/* Bottom region for microphone and video blocks */}
      <div className="w-full space-y-2 px-2 py-2">
        <MicrophoneBlock audioTrack={audioTrack} />
        <VideoBlock
          cameraTrack={videoTrack}
          screenTrack={screenTrack}
          videoSourceType={videoSourceType}
          onVideoSourceChange={onVideoSourceTypeChange}
        />
      </div>
    </div>
  );
}



================================================
FILE: ai_agents/playground/src/components/Icon/index.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

export const GitHubIcon = (props: React.SVGProps<SVGSVGElement>) => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      fill="currentColor"
      viewBox="0 0 16 16"
      {...props}
    >
      <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0 0 16 8c0-4.42-3.58-8-8-8" />
    </svg>
  )
}

export const AnimatedSpinnerIcon = (props: React.SVGProps<SVGSVGElement>) => {
  const { className, ...rest } = props
  return (
    <svg
      className={cn("-ml-1 mr-3 h-5 w-5 animate-spin text-white", className)}
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      {...rest}
    >
      <circle
        className="opacity-25"
        cx="12"
        cy="12"
        r="10"
        stroke="currentColor"
        strokeWidth="4"
      ></circle>
      <path
        className="opacity-75"
        fill="currentColor"
        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
      ></path>
    </svg>
  )
}

export const LogoIcon = (props: React.SVGProps<SVGSVGElement>) => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 98 22"
      fill="none"
      {...props}
    >
      <path
        d="M20.0608 10.2196V1.78906H11.4839C14.5315 10.1796 11.5648 8.12814 20.0608 10.2196Z"
        fill="url(#paint0_linear_8452_794)"
      />
      <path
        d="M10.9207 21.6461H21.6822V11.3105C10.6466 14.2404 15.1169 10.9616 10.9207 21.6461Z"
        fill="url(#paint1_linear_8452_794)"
      />
      <path
        d="M1.62134 11.7246V20.1553H10.1984C7.15085 11.7647 10.1175 13.8162 1.62134 11.7246Z"
        fill="url(#paint2_linear_8452_794)"
      />
      <path
        d="M10.7403 0.353516H0V10.6344C11.0168 7.70963 6.58066 10.9722 10.7403 0.353516Z"
        fill="url(#paint3_linear_8452_794)"
      />
      <path
        d="M30.8442 17.7842H27L30.1964 4.35352H37.2371L40.4307 17.7842H36.5893L35.9841 14.9062H31.4494L30.8442 17.7842ZM33.0462 6.90464L31.86 12.5849H35.5735L34.3846 6.90464H33.0462Z"
        fill="white"
      />
      <path
        d="M42.0108 17.7842H51.3611L53.8614 15.5576V10.1096L45.6285 9.47707V7.15573H53.8614V4.35352H44.5086L42.0108 6.58013V11.8363L50.2411 12.4688V14.9821H42.0108V17.7842Z"
        fill="white"
      />
      <path
        d="M59.4509 17.7842H63.2801V7.03966H67.2922V4.35352H55.4415V7.03966H59.4509V17.7842Z"
        fill="white"
      />
      <path
        d="M78.734 4.35352L81.4548 6.69383V11.6255L79.7584 13.1036L82.303 17.7842H78.1088L76.2555 13.9848H72.6204V17.7842H68.8723V4.35352H78.734ZM72.6204 6.92359V11.4147H77.7068V6.92359H72.6204Z"
        fill="white"
      />
      <path
        d="M87.7273 17.7842H83.8831L87.0795 4.35352H94.1174L97.3138 17.7842H93.4696L92.8645 14.9062H88.3298L87.7273 17.7842ZM89.9293 6.90464L88.7403 12.5849H92.4539L91.2676 6.90464H89.9293Z"
        fill="white"
      />
      <defs>
        <linearGradient
          id="paint0_linear_8452_794"
          x1="11.4569"
          y1="1.76871"
          x2="20.0726"
          y2="9.77396"
          gradientUnits="userSpaceOnUse"
        >
          <stop stopColor="#44BBFE" />
          <stop offset="1" stopColor="#4D80FF" />
        </linearGradient>
        <linearGradient
          id="paint1_linear_8452_794"
          x1="21.9247"
          y1="10.9999"
          x2="10.8474"
          y2="21.4681"
          gradientUnits="userSpaceOnUse"
        >
          <stop stopColor="#4E7AFF" />
          <stop offset="1" stopColor="#5930FF" />
        </linearGradient>
        <linearGradient
          id="paint2_linear_8452_794"
          x1="0.988861"
          y1="11.6147"
          x2="10.22"
          y2="20.2357"
          gradientUnits="userSpaceOnUse"
        >
          <stop stopColor="#33D7B3" />
          <stop offset="1" stopColor="#23EE6E" />
        </linearGradient>
        <linearGradient
          id="paint3_linear_8452_794"
          x1="10.8411"
          y1="0.538082"
          x2="-0.236248"
          y2="11.0064"
          gradientUnits="userSpaceOnUse"
        >
          <stop stopColor="#43BEFB" />
          <stop offset="1" stopColor="#34D4BA" />
        </linearGradient>
      </defs>
    </svg>
  )
}

export const SmallLogoIcon = (props: React.SVGProps<SVGSVGElement>) => {
  return (
    <svg
      viewBox="0 0 22 22"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M20.3746 9.86607V1.43555H11.7977C14.8452 9.82607 11.8786 7.77462 20.3746 9.86607Z"
        fill="url(#paint0_linear_8450_1751)"
      />
      <path
        d="M11.2344 21.2925H21.996V10.957C10.9604 13.8869 15.4307 10.6081 11.2344 21.2925Z"
        fill="url(#paint1_linear_8450_1751)"
      />
      <path
        d="M1.93512 11.3711V19.8017H10.5122C7.46464 11.4112 10.4312 13.4627 1.93512 11.3711Z"
        fill="url(#paint2_linear_8450_1751)"
      />
      <path
        d="M11.0541 0H0.313782V10.2809C11.3306 7.35611 6.89444 10.6187 11.0541 0Z"
        fill="url(#paint3_linear_8450_1751)"
      />
      <defs>
        <linearGradient
          id="paint0_linear_8450_1751"
          x1="11.7707"
          y1="1.41519"
          x2="20.3864"
          y2="9.42044"
          gradientUnits="userSpaceOnUse"
        >
          <stop stopColor="#44BBFE" />
          <stop offset="1" stopColor="#4D80FF" />
        </linearGradient>
        <linearGradient
          id="paint1_linear_8450_1751"
          x1="22.2385"
          y1="10.6464"
          x2="11.1612"
          y2="21.1146"
          gradientUnits="userSpaceOnUse"
        >
          <stop stopColor="#4E7AFF" />
          <stop offset="1" stopColor="#5930FF" />
        </linearGradient>
        <linearGradient
          id="paint2_linear_8450_1751"
          x1="1.30264"
          y1="11.2612"
          x2="10.5338"
          y2="19.8822"
          gradientUnits="userSpaceOnUse"
        >
          <stop stopColor="#33D7B3" />
          <stop offset="1" stopColor="#23EE6E" />
        </linearGradient>
        <linearGradient
          id="paint3_linear_8450_1751"
          x1="11.1548"
          y1="0.184566"
          x2="0.0775336"
          y2="10.6529"
          gradientUnits="userSpaceOnUse"
        >
          <stop stopColor="#43BEFB" />
          <stop offset="1" stopColor="#34D4BA" />
        </linearGradient>
      </defs>
    </svg>
  )
}

export const InfoIcon = (props: React.SVGProps<SVGSVGElement>) => {
  return (
    <svg
      viewBox="0 0 20 20"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M6.33331 2.5C4.67646 2.5 3.33331 3.84315 3.33331 5.5V14.5C3.33331 16.1569 4.67646 17.5 6.33331 17.5H13.6666C15.3235 17.5 16.6666 16.1569 16.6666 14.5V5.5C16.6666 3.84315 15.3235 2.5 13.6666 2.5H6.33331ZM6.66665 5.83333C6.20641 5.83333 5.83331 6.20643 5.83331 6.66667C5.83331 7.1269 6.20641 7.5 6.66665 7.5H9.99998C10.4602 7.5 10.8333 7.1269 10.8333 6.66667C10.8333 6.20643 10.4602 5.83333 9.99998 5.83333H6.66665ZM6.66665 9.16667C6.20641 9.16667 5.83331 9.53976 5.83331 10C5.83331 10.4602 6.20641 10.8333 6.66665 10.8333H13.3333C13.7936 10.8333 14.1666 10.4602 14.1666 10C14.1666 9.53976 13.7936 9.16667 13.3333 9.16667H6.66665ZM6.66665 12.5C6.20641 12.5 5.83331 12.8731 5.83331 13.3333C5.83331 13.7936 6.20641 14.1667 6.66665 14.1667H13.3333C13.7936 14.1667 14.1666 13.7936 14.1666 13.3333C14.1666 12.8731 13.7936 12.5 13.3333 12.5H6.66665Z"
        fill="currentColor"
      />
    </svg>
  )
}

export const PaletteIcon = (props: React.SVGProps<SVGSVGElement>) => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      {...props}
    >
      <circle cx="13.5" cy="6.5" r=".5" fill="currentColor" />
      <circle cx="17.5" cy="10.5" r=".5" fill="currentColor" />
      <circle cx="8.5" cy="7.5" r=".5" fill="currentColor" />
      <circle cx="6.5" cy="12.5" r=".5" fill="currentColor" />
      <path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z" />
    </svg>
  )
}

export const NetworkAverageIcon = (props: React.SVGProps<SVGSVGElement>) => {
  return (
    <svg
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M9.49875 10.8689C10.1539 10.8689 10.685 11.3753 10.685 12V19.8689C10.685 20.4936 10.1539 21 9.49875 21C8.8436 21 8.3125 20.4936 8.3125 19.8689V12C8.3125 11.3753 8.8436 10.8689 9.49875 10.8689Z"
        fill="#FFAB08"
      />
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M4.18625 14.8033C4.84139 14.8033 5.37249 15.3097 5.37249 15.9344V19.8689C5.37249 20.4936 4.84139 21 4.18625 21C3.5311 21 3 20.4936 3 19.8689V15.9344C3 15.3097 3.5311 14.8033 4.18625 14.8033Z"
        fill="#FFAB08"
      />
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M14.656 7.91803C15.3111 7.91803 15.8422 8.42446 15.8422 9.04918V19.8688C15.8422 20.4936 15.3111 21 14.656 21C14.0008 21 13.4697 20.4936 13.4697 19.8688V9.04918C13.4697 8.42446 14.0008 7.91803 14.656 7.91803Z"
        fill="#D0D5DD"
      />
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M19.8137 3C20.4688 3 20.9999 3.50643 20.9999 4.13115V19.8689C20.9999 20.4936 20.4688 21 19.8137 21C19.1585 21 18.6274 20.4936 18.6274 19.8689V4.13115C18.6274 3.50643 19.1585 3 19.8137 3Z"
        fill="#D0D5DD"
      />
    </svg>
  )
}

export const NetworkDisconnectedIcon = (
  props: React.SVGProps<SVGSVGElement>,
) => {
  return (
    <svg
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M21 4.13115C21 3.50643 20.4689 3 19.8138 3C19.1586 3 18.6275 3.50643 18.6275 4.13115V19.8689C18.6275 20.4936 19.1586 21 19.8138 21C20.4689 21 21 20.4936 21 19.8689V4.13115ZM14.6562 7.91803C15.3113 7.91803 15.8424 8.42447 15.8424 9.04918V19.8689C15.8424 20.4936 15.3113 21 14.6562 21C14.001 21 13.4699 20.4936 13.4699 19.8689V9.04918C13.4699 8.42447 14.001 7.91803 14.6562 7.91803ZM10.6848 12C10.6848 11.3753 10.1537 10.8689 9.49856 10.8689C8.84342 10.8689 8.31232 11.3753 8.31232 12V19.8689C8.31232 20.4936 8.84342 21 9.49856 21C10.1537 21 10.6848 20.4936 10.6848 19.8689V12ZM5.37249 15.9344C5.37249 15.3097 4.84139 14.8033 4.18625 14.8033C3.5311 14.8033 3 15.3097 3 15.9344V19.8689C3 20.4936 3.5311 21 4.18625 21C4.84139 21 5.37249 20.4936 5.37249 19.8689V15.9344Z"
        fill="#D0D5DD"
      />
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M13.2441 12.2441C13.5695 11.9186 14.0972 11.9186 14.4226 12.2441L18 15.8215L21.5774 12.2441C21.9028 11.9186 22.4305 11.9186 22.7559 12.2441C23.0814 12.5695 23.0814 13.0972 22.7559 13.4226L19.1785 17L22.7559 20.5774C23.0814 20.9028 23.0814 21.4305 22.7559 21.7559C22.4305 22.0814 21.9028 22.0814 21.5774 21.7559L18 18.1785L14.4226 21.7559C14.0972 22.0814 13.5695 22.0814 13.2441 21.7559C12.9186 21.4305 12.9186 20.9028 13.2441 20.5774L16.8215 17L13.2441 13.4226C12.9186 13.0972 12.9186 12.5695 13.2441 12.2441Z"
        fill="#DF1642"
      />
    </svg>
  )
}

export const NetworkExcellentIcon = (props: React.SVGProps<SVGSVGElement>) => {
  return (
    <svg
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M21 4.13115C21 3.50643 20.4689 3 19.8138 3C19.1586 3 18.6275 3.50643 18.6275 4.13115V19.8689C18.6275 20.4936 19.1586 21 19.8138 21C20.4689 21 21 20.4936 21 19.8689V4.13115ZM14.6562 7.91803C15.3113 7.91803 15.8424 8.42447 15.8424 9.04918V19.8689C15.8424 20.4936 15.3113 21 14.6562 21C14.001 21 13.4699 20.4936 13.4699 19.8689V9.04918C13.4699 8.42447 14.001 7.91803 14.6562 7.91803ZM10.6848 12C10.6848 11.3753 10.1537 10.8689 9.49856 10.8689C8.84342 10.8689 8.31232 11.3753 8.31232 12V19.8689C8.31232 20.4936 8.84342 21 9.49856 21C10.1537 21 10.6848 20.4936 10.6848 19.8689V12ZM5.37249 15.9344C5.37249 15.3097 4.84139 14.8033 4.18625 14.8033C3.5311 14.8033 3 15.3097 3 15.9344V19.8689C3 20.4936 3.5311 21 4.18625 21C4.84139 21 5.37249 20.4936 5.37249 19.8689V15.9344Z"
        fill="#18A957"
      />
    </svg>
  )
}

export const NetworkGoodIcon = (props: React.SVGProps<SVGSVGElement>) => {
  return (
    <svg
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M9.49875 10.8689C10.1539 10.8689 10.685 11.3753 10.685 12V19.8689C10.685 20.4936 10.1539 21 9.49875 21C8.8436 21 8.3125 20.4936 8.3125 19.8689V12C8.3125 11.3753 8.8436 10.8689 9.49875 10.8689Z"
        fill="#18A957"
      />
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M4.18625 14.8033C4.84139 14.8033 5.37249 15.3097 5.37249 15.9344V19.8689C5.37249 20.4936 4.84139 21 4.18625 21C3.5311 21 3 20.4936 3 19.8689V15.9344C3 15.3097 3.5311 14.8033 4.18625 14.8033Z"
        fill="#18A957"
      />
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M14.656 7.91803C15.3111 7.91803 15.8422 8.42446 15.8422 9.04918V19.8688C15.8422 20.4936 15.3111 21 14.656 21C14.0008 21 13.4697 20.4936 13.4697 19.8688V9.04918C13.4697 8.42446 14.0008 7.91803 14.656 7.91803Z"
        fill="#18A957"
      />
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M19.8137 3C20.4688 3 20.9999 3.50643 20.9999 4.13115V19.8689C20.9999 20.4936 20.4688 21 19.8137 21C19.1585 21 18.6274 20.4936 18.6274 19.8689V4.13115C18.6274 3.50643 19.1585 3 19.8137 3Z"
        fill="#D0D5DD"
      />
    </svg>
  )
}

export const NetworkPoorIcon = (props: React.SVGProps<SVGSVGElement>) => {
  return (
    <svg
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M9.49875 10.8689C10.1539 10.8689 10.685 11.3753 10.685 12V19.8689C10.685 20.4936 10.1539 21 9.49875 21C8.8436 21 8.3125 20.4936 8.3125 19.8689V12C8.3125 11.3753 8.8436 10.8689 9.49875 10.8689Z"
        fill="#D0D5DD"
      />
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M4.18625 14.8033C4.84139 14.8033 5.37249 15.3097 5.37249 15.9344V19.8689C5.37249 20.4936 4.84139 21 4.18625 21C3.5311 21 3 20.4936 3 19.8689V15.9344C3 15.3097 3.5311 14.8033 4.18625 14.8033Z"
        fill="#DF1642"
      />
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M14.656 7.91803C15.3111 7.91803 15.8422 8.42446 15.8422 9.04918V19.8688C15.8422 20.4936 15.3111 21 14.656 21C14.0008 21 13.4697 20.4936 13.4697 19.8688V9.04918C13.4697 8.42446 14.0008 7.91803 14.656 7.91803Z"
        fill="#D0D5DD"
      />
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M19.8137 3C20.4688 3 20.9999 3.50643 20.9999 4.13115V19.8689C20.9999 20.4936 20.4688 21 19.8137 21C19.1585 21 18.6274 20.4936 18.6274 19.8689V4.13115C18.6274 3.50643 19.1585 3 19.8137 3Z"
        fill="#D0D5DD"
      />
    </svg>
  )
}

export const NetworkIconByLevel = (
  props: React.SVGProps<SVGSVGElement> & { level?: number },
) => {
  const { level, ...rest } = props
  switch (level) {
    case 0:
      return <NetworkDisconnectedIcon {...rest} />
    case 1:
      return <NetworkExcellentIcon {...rest} />
    case 2:
      return <NetworkGoodIcon {...rest} />
    case 3:
    case 4:
      return <NetworkAverageIcon {...rest} />
    case 5:
      return <NetworkPoorIcon {...rest} />
    case 6:
    default:
      return <NetworkDisconnectedIcon {...rest} />
  }
}

export const VoiceIcon = (props: React.SVGProps<SVGSVGElement>) => {
  return (
    <svg
      viewBox="0 0 20 20"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M16.625 13.2913L15.3333 11.9997C15.9444 11.4302 16.4236 10.7566 16.7708 9.97884C17.118 9.20106 17.2916 8.37467 17.2916 7.49967C17.2916 6.62467 17.118 5.80523 16.7708 5.04134C16.4236 4.27745 15.9444 3.61079 15.3333 3.04134L16.625 1.70801C17.4028 2.44412 18.0208 3.31217 18.4791 4.31217C18.9375 5.31217 19.1666 6.37467 19.1666 7.49967C19.1666 8.62467 18.9375 9.68717 18.4791 10.6872C18.0208 11.6872 17.4028 12.5552 16.625 13.2913ZM13.9583 10.6247L12.625 9.29134C12.875 9.05523 13.0764 8.78787 13.2291 8.48926C13.3819 8.19065 13.4583 7.86079 13.4583 7.49967C13.4583 7.13856 13.3819 6.8087 13.2291 6.51009C13.0764 6.21148 12.875 5.94412 12.625 5.70801L13.9583 4.37467C14.4028 4.77745 14.75 5.2462 15 5.78092C15.25 6.31565 15.375 6.88856 15.375 7.49967C15.375 8.11079 15.25 8.6837 15 9.21842C14.75 9.75315 14.4028 10.2219 13.9583 10.6247ZM7.49998 10.833C6.58331 10.833 5.79859 10.5066 5.14581 9.85384C4.49303 9.20106 4.16665 8.41634 4.16665 7.49967C4.16665 6.58301 4.49303 5.79829 5.14581 5.14551C5.79859 4.49273 6.58331 4.16634 7.49998 4.16634C8.41665 4.16634 9.20137 4.49273 9.85415 5.14551C10.5069 5.79829 10.8333 6.58301 10.8333 7.49967C10.8333 8.41634 10.5069 9.20106 9.85415 9.85384C9.20137 10.5066 8.41665 10.833 7.49998 10.833ZM0.833313 17.4997V15.1663C0.833313 14.708 0.951369 14.2775 1.18748 13.8747C1.42359 13.4719 1.74998 13.1663 2.16665 12.958C2.87498 12.5969 3.67359 12.2913 4.56248 12.0413C5.45137 11.7913 6.43053 11.6663 7.49998 11.6663C8.56942 11.6663 9.54859 11.7913 10.4375 12.0413C11.3264 12.2913 12.125 12.5969 12.8333 12.958C13.25 13.1663 13.5764 13.4719 13.8125 13.8747C14.0486 14.2775 14.1666 14.708 14.1666 15.1663V17.4997H0.833313Z"
        fill="currentColor"
      />
    </svg>
  )
}

export const MicMuteIcon = (props: React.SVGProps<SVGSVGElement>) => {
  return (
    <svg
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M6.3 7.92635L3.33683 4.96317C2.88772 4.51407 2.88772 3.78593 3.33683 3.33683C3.78593 2.88772 4.51407 2.88772 4.96317 3.33683L21.9632 20.3368C22.4123 20.7859 22.4123 21.5141 21.9632 21.9632C21.5141 22.4123 20.7859 22.4123 20.3368 21.9632L18.8367 20.463C13.6456 24.5199 5.41626 23.2537 2.12166 16.6645C1.83762 16.0965 2.06788 15.4057 2.63596 15.1217C3.20403 14.8376 3.89481 15.0679 4.17884 15.636C6.74084 20.7599 13.0699 21.8205 17.1912 18.8176L15.7744 17.4008C14.7706 18.2621 13.4656 18.7826 12.0391 18.7826C8.8695 18.7826 6.3 16.2131 6.3 13.0435V7.92635ZM14.1401 15.7664C13.559 16.2154 12.8303 16.4826 12.0391 16.4826C10.1398 16.4826 8.6 14.9428 8.6 13.0435V10.2263L14.1401 15.7664ZM17.6882 14.0618L15.4783 11.8519V6.78259C15.4783 4.88321 13.9385 3.34346 12.0391 3.34346C10.6683 3.34346 9.48479 4.1455 8.93227 5.30592L7.2481 3.62175C8.27509 2.06823 10.0374 1.04346 12.0391 1.04346C15.2088 1.04346 17.7783 3.61295 17.7783 6.78259V13.0435C17.7783 13.391 17.7474 13.7313 17.6882 14.0618ZM19.6535 16.0272L21.3305 17.7041C21.5404 17.3737 21.7366 17.0272 21.918 16.6645C22.202 16.0965 21.9718 15.4057 21.4037 15.1217C20.8356 14.8376 20.1448 15.0679 19.8608 15.636C19.7942 15.7691 19.7251 15.8995 19.6535 16.0272Z"
        fill="currentColor"
      />
    </svg>
  )
}

export const MicActiveIcon = (props: React.SVGProps<SVGSVGElement>) => {
  return (
    <svg
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M12.0391 1.04346C8.86948 1.04346 6.29999 3.61295 6.29999 6.78259V13.0435C6.29999 16.2131 8.86948 18.7826 12.0391 18.7826C15.2088 18.7826 17.7782 16.2131 17.7782 13.0435V6.78259C17.7782 3.61295 15.2088 1.04346 12.0391 1.04346ZM4.17884 15.6596C3.89481 15.0916 3.20403 14.8613 2.63596 15.1453C2.06788 15.4294 1.83762 16.1202 2.12166 16.6882C6.19993 24.8448 17.8397 24.8448 21.918 16.6882C22.202 16.1202 21.9718 15.4294 21.4037 15.1453C20.8356 14.8613 20.1448 15.0916 19.8608 15.6596C16.6301 22.121 7.4095 22.121 4.17884 15.6596Z"
        fill="currentColor"
      />
    </svg>
  )
}

export const MicIconByStatus = (
  props: React.SVGProps<SVGSVGElement> & { active?: boolean; color?: string },
) => {
  const { active, color, ...rest } = props
  if (active) {
    return <MicActiveIcon color={color || "#3D53F5"} {...rest} />
  }
  return <MicMuteIcon color={color || "#667085"} {...rest} />
}

export const CameraDisabledIcon = (props: React.SVGProps<SVGSVGElement>) => {
  return (
    <svg
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M4.96317 1.33683C4.51407 0.887724 3.78593 0.887724 3.33683 1.33683C2.88772 1.78593 2.88772 2.51407 3.33683 2.96317L4.80982 4.43617C3.76782 5.81737 3.14999 7.53655 3.14999 9.40002C3.14999 13.4792 6.11045 16.8668 10 17.5317V20.85H6.14999C5.51486 20.85 4.99999 21.3648 4.99999 22C4.99999 22.6351 5.51486 23.15 6.14999 23.15H16.15C16.7851 23.15 17.3 22.6351 17.3 22C17.3 21.3648 16.7851 20.85 16.15 20.85H12.3V17.6015C13.8156 17.4371 15.2081 16.8621 16.3639 15.9902L18.3368 17.9632C18.7859 18.4123 19.5141 18.4123 19.9632 17.9632C20.4123 17.5141 20.4123 16.7859 19.9632 16.3368L4.96317 1.33683ZM14.7152 14.3416L12.9999 12.6263C12.5601 12.8339 12.0686 12.95 11.55 12.95C9.67223 12.95 8.14999 11.4278 8.14999 9.55002C8.14999 9.03141 8.26611 8.53991 8.47376 8.10011L6.45844 6.08478C5.8216 7.03215 5.44999 8.17269 5.44999 9.40002C5.44999 12.6861 8.1139 15.35 11.4 15.35C12.6273 15.35 13.7679 14.9784 14.7152 14.3416ZM11.7843 6.15797L14.942 9.3157C14.8269 7.62466 13.4754 6.27308 11.7843 6.15797ZM17.35 9.40002C17.35 10.0959 17.2305 10.7639 17.011 11.3846L18.7592 13.1328C19.3289 12.012 19.65 10.7435 19.65 9.40002C19.65 4.84368 15.9563 1.15002 11.4 1.15002C10.0565 1.15002 8.78807 1.47115 7.66718 2.04083L9.41539 3.78904C10.0361 3.56949 10.7041 3.45002 11.4 3.45002C14.6861 3.45002 17.35 6.11393 17.35 9.40002Z"
        fill="currentColor"
      />
    </svg>
  )
}

export const CameraActiveIcon = (props: React.SVGProps<SVGSVGElement>) => {
  return (
    <svg
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M17.3499 9.40002C17.3499 12.6861 14.686 15.35 11.3999 15.35C8.11381 15.35 5.4499 12.6861 5.4499 9.40002C5.4499 6.11393 8.11381 3.45002 11.3999 3.45002C14.686 3.45002 17.3499 6.11393 17.3499 9.40002ZM19.6499 9.40002C19.6499 13.6522 16.4329 17.1531 12.2999 17.6015V20.85H16.1499C16.785 20.85 17.2999 21.3648 17.2999 22C17.2999 22.6351 16.785 23.15 16.1499 23.15H6.1499C5.51477 23.15 4.9999 22.6351 4.9999 22C4.9999 21.3648 5.51477 20.85 6.1499 20.85H9.99991V17.5317C6.11036 16.8668 3.1499 13.4792 3.1499 9.40002C3.1499 4.84368 6.84355 1.15002 11.3999 1.15002C15.9563 1.15002 19.6499 4.84368 19.6499 9.40002ZM11.5499 12.95C13.4277 12.95 14.9499 11.4278 14.9499 9.55002C14.9499 7.67226 13.4277 6.15002 11.5499 6.15002C9.67213 6.15002 8.1499 7.67226 8.1499 9.55002C8.1499 11.4278 9.67213 12.95 11.5499 12.95Z"
        fill="currentColor"
      />
    </svg>
  )
}

export const CamIconByStatus = (
  props: React.SVGProps<SVGSVGElement> & { active?: boolean; color?: string },
) => {
  const { active, color, ...rest } = props
  if (active) {
    return <CameraActiveIcon color={color || "#3D53F5"} {...rest} />
  }
  return <CameraDisabledIcon color={color || "#667085"} {...rest} />
}



================================================
FILE: ai_agents/playground/src/components/icons/index.tsx
================================================
export * from "./mic"
export * from "./cam"
export * from "./network"
export * from "./github"
export * from "./transcription"
export * from "./logo"
export * from "./info"
export * from "./colorPicker"
export * from "./voice"
export * from "./pdf"



================================================
FILE: ai_agents/playground/src/components/icons/types.ts
================================================
export interface IconProps {
  width?: number
  height?: number
  color?: string
  viewBox?: string
  size?: "small" | "default"
  // style?: React.CSSProperties
  transform?: string
  onClick?: () => void
}



================================================
FILE: ai_agents/playground/src/components/icons/cam/index.tsx
================================================
import camMuteSvg from "@/assets/cam_mute.svg"
import camUnMuteSvg from "@/assets/cam_unmute.svg"
import { IconProps } from "../types"

interface ICamIconProps extends IconProps {
  active?: boolean
}

export const CamIcon = (props: ICamIconProps) => {
  const { active, ...rest } = props

  if (active) {
    return camUnMuteSvg(rest)
  } else {
    return camMuteSvg(rest)
  }
}



================================================
FILE: ai_agents/playground/src/components/icons/colorPicker/index.tsx
================================================
import { IconProps } from "../types"
import ColorPickerSvg from "@/assets/color_picker.svg"

export const ColorPickerIcon = (props: IconProps) => {
  return <ColorPickerSvg {...props}></ColorPickerSvg>
}



================================================
FILE: ai_agents/playground/src/components/icons/github/index.tsx
================================================
import { IconProps } from "../types"
import GithubSvg from "@/assets/github.svg"

export const GithubIcon = (props: IconProps) => {
  return <GithubSvg {...props}></GithubSvg>
}



================================================
FILE: ai_agents/playground/src/components/icons/info/index.tsx
================================================
import { IconProps } from "../types"
import InfoSvg from "@/assets/info.svg"

export const InfoIcon = (props: IconProps) => {
  return <InfoSvg {...props}></InfoSvg>
}



================================================
FILE: ai_agents/playground/src/components/icons/logo/index.tsx
================================================
import { IconProps } from "../types"
import LogoSvg from "@/assets/logo.svg"
import SmallLogoSvg from "@/assets/logo_small.svg"

export const LogoIcon = (props: IconProps) => {
  const { size = "default" } = props
  return size == "small" ? <SmallLogoSvg {...props}></SmallLogoSvg> : <LogoSvg {...props}></LogoSvg>
}



================================================
FILE: ai_agents/playground/src/components/icons/mic/index.tsx
================================================
import { IconProps } from "../types"
import micMuteSvg from "@/assets/mic_mute.svg"
import micUnMuteSvg from "@/assets/mic_unmute.svg"

interface IMicIconProps extends IconProps {
  active?: boolean
}

export const MicIcon = (props: IMicIconProps) => {
  const { active, color, ...rest } = props

  if (active) {
    return micUnMuteSvg({
      color: color || "#3D53F5",
      ...rest,
    })
  } else {
    return micMuteSvg({
      color: color || "#667085",
      ...rest,
    })
  }
}



================================================
FILE: ai_agents/playground/src/components/icons/network/index.tsx
================================================
import averageSvg from "@/assets/network/average.svg"
import goodSvg from "@/assets/network/good.svg"
import poorSvg from "@/assets/network/poor.svg"
import disconnectedSvg from "@/assets/network/disconnected.svg"
import excellentSvg from "@/assets/network/excellent.svg"

import { IconProps } from "../types"

interface INetworkIconProps extends IconProps {
  level?: number
}

export const NetworkIcon = (props: INetworkIconProps) => {
  const { level, ...rest } = props
  switch (level) {
    case 0:
      return disconnectedSvg(rest)
    case 1:
      return excellentSvg(rest)
    case 2:
      return goodSvg(rest)
    case 3:
      return averageSvg(rest)
    case 4:
      return averageSvg(rest)
    case 5:
      return poorSvg(rest)
    case 6:
      return disconnectedSvg(rest)
    default:
      return disconnectedSvg(rest)
  }
}



================================================
FILE: ai_agents/playground/src/components/icons/pdf/index.tsx
================================================
import { IconProps } from "../types"
import PdfSvg from "@/assets/pdf.svg"

export const PdfIcon = (props: IconProps) => {
  return <PdfSvg {...props}></PdfSvg>
}



================================================
FILE: ai_agents/playground/src/components/icons/transcription/index.tsx
================================================
import { IconProps } from "../types"
import TranscriptionSvg from "@/assets/transcription.svg"

export const TranscriptionIcon = (props: IconProps) => {
  return <TranscriptionSvg {...props}></TranscriptionSvg>
}



================================================
FILE: ai_agents/playground/src/components/icons/voice/index.tsx
================================================
import { IconProps } from "../types"
import VoiceSvg from "@/assets/voice.svg"

export const VoiceIcon = (props: IconProps) => {
  return <VoiceSvg {...props}></VoiceSvg>
}



================================================
FILE: ai_agents/playground/src/components/Layout/Action.tsx
================================================
"use client";

import * as React from "react";

import { LoadingButton } from "@/components/Button/LoadingButton";
import { setAgentConnected, setMobileActiveTab } from "@/store/reducers/global";
import {
  useAppDispatch,
  useAppSelector,
  apiPing,
  apiStartService,
  apiStopService,
  MOBILE_ACTIVE_TAB_MAP,
  EMobileActiveTab,
  isEditModeOn,
  useGraphs,
} from "@/common";
import { toast } from "sonner";
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { cn } from "@/lib/utils";
import { RemotePropertyCfgSheet } from "@/components/Chat/ChatCfgPropertySelect";
import { RemoteGraphSelect } from "@/components/Chat/ChatCfgGraphSelect";
import { RemoteModuleCfgSheet } from "@/components/Chat/ChatCfgModuleSelect";
import { TrulienceCfgSheet } from "../Chat/ChatCfgTrulienceSetting";

let intervalId: NodeJS.Timeout | null = null;

export default function Action(props: { className?: string }) {
  const { className } = props;
  const dispatch = useAppDispatch();
  const agentConnected = useAppSelector((state) => state.global.agentConnected);
  const channel = useAppSelector((state) => state.global.options.channel);
  const userId = useAppSelector((state) => state.global.options.userId);
  const language = useAppSelector((state) => state.global.language);
  const voiceType = useAppSelector((state) => state.global.voiceType);
  const selectedGraphId = useAppSelector(
    (state) => state.global.selectedGraphId
  );
  const graphList = useAppSelector((state) => state.global.graphList);
  const mobileActiveTab = useAppSelector(
    (state) => state.global.mobileActiveTab
  );
  const [loading, setLoading] = React.useState(false);

  React.useEffect(() => {
    if (channel) {
      checkAgentConnected();
    }
  }, [channel]);

  const checkAgentConnected = async () => {
    const res: any = await apiPing(channel);
    if (res?.code == 0) {
      dispatch(setAgentConnected(true));
    }
  };

  const onClickConnect = async () => {
    if (loading) {
      return;
    }
    setLoading(true);
    if (agentConnected) {
      await apiStopService(channel);
      dispatch(setAgentConnected(false));
      toast.success("Agent disconnected");
      stopPing();
    } else {
      const selectedGraph = graphList.find(
        (graph) => graph.uuid === selectedGraphId
      );
      if (!selectedGraph) {
        toast.error("Please select a graph first");
        setLoading(false);
        return;
      }

      const res = await apiStartService({
        channel,
        userId,
        graphName: selectedGraph.name,
        language,
        voiceType,
      });
      const { code, msg } = res || {};
      if (code != 0) {
        if (code == "10001") {
          toast.error(
            "The number of users experiencing the program simultaneously has exceeded the limit. Please try again later."
          );
        } else {
          toast.error(`code:${code},msg:${msg}`);
        }
        setLoading(false);
        throw new Error(msg);
      }
      dispatch(setAgentConnected(true));
      toast.success("Agent connected");
      startPing();
    }
    setLoading(false);
  };

  const startPing = () => {
    if (intervalId) {
      stopPing();
    }
    intervalId = setInterval(() => {
      apiPing(channel);
    }, 3000);
  };

  const stopPing = () => {
    if (intervalId) {
      clearInterval(intervalId);
      intervalId = null;
    }
  };

  const onChangeMobileActiveTab = (tab: string) => {
    dispatch(setMobileActiveTab(tab as EMobileActiveTab));
  };

  return (
    <>
      {/* Action Bar */}
      <div
        className={cn(
          "mx-2 mt-2 flex items-center justify-between rounded-t-lg bg-[#181a1d] p-2 md:m-2 md:rounded-lg",
          className
        )}
      >
        {/* -- Description Part */}
        <div className="hidden md:block">
          <span className="text-sm font-bold">Description</span>
          <span className="ml-2 text-xs text-muted-foreground whitespace-nowrap">
            A Realtime Conversational AI Agent powered by TEN
          </span>

        </div>

        <div className="flex w-full flex-col md:flex-row md:items-center justify-between md:justify-end">
          {/* -- Tabs Section */}
          <Tabs
            defaultValue={mobileActiveTab}
            className="md:hidden w-full md:flex-row"
            onValueChange={onChangeMobileActiveTab}
          >
            <TabsList className="flex justify-center md:justify-start">
              {Object.values(EMobileActiveTab).map((tab) => (
                <TabsTrigger key={tab} value={tab} className="w-24 text-sm">
                  {MOBILE_ACTIVE_TAB_MAP[tab]}
                </TabsTrigger>
              ))}
            </TabsList>
          </Tabs>

          {/* -- Graph Select Part */}
          <div className="flex flex-wrap items-center justify-between w-full md:w-auto gap-2 mt-2 md:mt-0">
            <RemoteGraphSelect />
            {isEditModeOn && (
              <>
                <TrulienceCfgSheet />
                <RemoteModuleCfgSheet />
                <RemotePropertyCfgSheet />
              </>
            )}

            {/* -- Action Button */}
            <div className="ml-auto flex items-center gap-2">
              <LoadingButton
                onClick={onClickConnect}
                variant={!agentConnected ? "default" : "destructive"}
                size="sm"
                disabled={!selectedGraphId && !agentConnected}
                className="w-fit min-w-24"
                loading={loading}
                svgProps={{ className: "h-4 w-4 text-muted-foreground" }}
              >
                {loading
                  ? "Connecting"
                  : !agentConnected
                    ? "Connect"
                    : "Disconnect"}
              </LoadingButton>
            </div>
          </div>
        </div>
      </div>
    </>
  );
}



================================================
FILE: ai_agents/playground/src/components/Layout/Header.module.css
================================================
.colorPicker :global(.react-colorful) {
  width: 220px;
  height: 8px;
}

.colorPicker :global(.react-colorful__saturation) {
  display: none;
}

.colorPicker :global(.react-colorful__hue) {
  border-radius: 8px !important;
  height: 8px;
}

.colorPicker :global(.react-colorful__pointer) {
  width: 24px;
  height: 24px;
}



================================================
FILE: ai_agents/playground/src/components/Layout/Header.tsx
================================================
import { LogoIcon, SmallLogoIcon } from "@/components/Icon"
import { HeaderRoomInfo, HeaderActions } from "./HeaderComponents"
import { cn } from "@/lib/utils"

export default function Header(props: { className?: string }) {
  const { className } = props
  return (
    <>
      {/* Header */}
      <header
        className={cn(
          "flex items-center justify-between bg-[#181a1d] p-2 md:p-4",
          className,
        )}
      >
        <div className="flex items-center space-x-2">
          {/* <LogoIcon className="hidden h-5 md:block" />
          <SmallLogoIcon className="block h-4 md:hidden" /> */}
          <h1 className="text-sm font-bold md:text-xl">TEN Agent</h1>
        </div>
        <HeaderRoomInfo />
        <HeaderActions />
      </header>
    </>
  )
}



================================================
FILE: ai_agents/playground/src/components/Layout/HeaderComponents.tsx
================================================
"use client"

import * as React from "react"
import NextLink from "next/link"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover"
import { InfoIcon, GitHubIcon, PaletteIcon } from "@/components/Icon"
import {
  useAppSelector,
  useAppDispatch,
  GITHUB_URL,
  COLOR_LIST,
} from "@/common"
import { setThemeColor } from "@/store/reducers/global"
import { cn } from "@/lib/utils"
import { HexColorPicker } from "react-colorful"
import dynamic from "next/dynamic"

import styles from "./Header.module.css"

export function HeaderRoomInfo() {
  const options = useAppSelector((state) => state.global.options)
  const { channel, userId } = options

  const roomConnected = useAppSelector((state) => state.global.roomConnected)
  const agentConnected = useAppSelector((state) => state.global.agentConnected)

  const roomConnectedText = React.useMemo(() => {
    return roomConnected ? "TRUE" : "FALSE"
  }, [roomConnected])

  const agentConnectedText = React.useMemo(() => {
    return agentConnected ? "TRUE" : "FALSE"
  }, [agentConnected])

  return (
    <>
      <TooltipProvider delayDuration={200}>
        <Tooltip>
          <TooltipTrigger className="flex items-center space-x-2 text-lg font-semibold">
            <InfoIcon className="h-4 w-4 md:h-5 md:w-5" />
            <span className="hidden text-sm md:inline-block">
              Channel Name:{" "}
            </span>
            <span className="max-w-24 text-sm md:text-base">
              {channel}
            </span>
          </TooltipTrigger>
          <TooltipContent className="bg-[var(--background-color,#1C1E22)] text-gray-600">
            <table className="border-collapse">
              <tbody>
                <tr>
                  <td className="pr-2 font-bold text-primary">INFO</td>
                  <td></td>
                </tr>
                <tr>
                  <td className="pr-2">Room:</td>
                  <td className="text-[#0888FF]">{channel}</td>
                </tr>
                <tr>
                  <td className="pr-2">Participant:</td>
                  <td className="text-[#0888FF]">{userId}</td>
                </tr>
                <tr>
                  <td colSpan={2}>
                    <hr className="my-2 border-t border-gray-600" />
                  </td>
                </tr>
                <tr>
                  <td className="pr-2 font-bold text-primary" colSpan={2}>
                    STATUS
                  </td>
                </tr>
                <tr>
                  <td className="pr-2">Room connected:</td>
                  <td className="text-[#0888FF]">{roomConnectedText}</td>
                </tr>
                <tr>
                  <td className="pr-2">Agent connected:</td>
                  <td className="text-[#0888FF]">{agentConnectedText}</td>
                </tr>
              </tbody>
            </table>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    </>
  )
}

export function HeaderActions() {
  return (
    <div className="flex space-x-2 md:space-x-4">
      <NextLink href={GITHUB_URL} target="_blank">
        <GitHubIcon className="h-4 w-4 md:h-5 md:w-5" />
        <span className="sr-only">GitHub</span>
      </NextLink>
      <ThemePalettePopover />
      <NetworkIndicator />
    </div>
  )
}

export const ThemePalettePopover = () => {
  const themeColor = useAppSelector((state) => state.global.themeColor)
  const dispatch = useAppDispatch()

  const onMainClickSelect = (index: number) => {
    const target = COLOR_LIST[index]
    if (target.active !== themeColor) {
      dispatch(setThemeColor(target.active))
    }
  }

  const onColorSliderChange = (color: string) => {
    console.log(color)
    dispatch(setThemeColor(color))
  }

  return (
    <>
      <Popover>
        <PopoverTrigger>
          <PaletteIcon className="h-4 w-4 md:h-5 md:w-5" color={themeColor} />
        </PopoverTrigger>
        <PopoverContent className="space-y-2 border-none bg-[var(--background-color,#1C1E22)]">
          <div className="text-sm font-semibold text-[var(--Grey-300,#EAECF0)]">
            STYLE
          </div>
          <div className="mt-4 flex gap-3">
            {COLOR_LIST.map((item, index) => {
              const isSelected = item.active === themeColor
              return (
                <button
                  onClick={() => onMainClickSelect(index)}
                  className={cn(
                    "relative h-7 w-7 rounded-full",
                    {
                      "ring-2 ring-offset-2": isSelected,
                    },
                    "transition-all duration-200 ease-in-out",
                  )}
                  style={{
                    backgroundColor: item.default,
                    ...(isSelected && { ringColor: item.active }),
                  }}
                  key={index}
                >
                  <span
                    className="absolute inset-1 rounded-full"
                    style={{
                      backgroundColor: item.active,
                    }}
                  ></span>
                </button>
              )
            })}
          </div>
          <div className={cn("flex h-6 items-center", styles.colorPicker)}>
            <HexColorPicker color={themeColor} onChange={onColorSliderChange} />
          </div>
        </PopoverContent>
      </Popover>
    </>
  )
}

// export const Network = () => {
//   const [networkQuality, setNetworkQuality] = React.useState<NetworkQuality>()

//   React.useEffect(() => {
//     rtcManager.on("networkQuality", onNetworkQuality)

//     return () => {
//       rtcManager.off("networkQuality", onNetworkQuality)
//     }
//   }, [])

//   const onNetworkQuality = (quality: NetworkQuality) => {
//     setNetworkQuality(quality)
//   }

//   return (
//     <NetworkIconByLevel
//       level={networkQuality?.uplinkNetworkQuality}
//       className="h-5 w-5"
//     />
//   )
// }

const NetworkIndicator = dynamic(
  () => import("@/components/Dynamic/NetworkIndicator"),
  {
    ssr: false,
  },
)



================================================
FILE: ai_agents/playground/src/components/ui/avatar.tsx
================================================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }



================================================
FILE: ai_agents/playground/src/components/ui/button.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }



================================================
FILE: ai_agents/playground/src/components/ui/card.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }



================================================
FILE: ai_agents/playground/src/components/ui/checkbox.tsx
================================================
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }



================================================
FILE: ai_agents/playground/src/components/ui/dialog.tsx
================================================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}



================================================
FILE: ai_agents/playground/src/components/ui/dropdown.tsx
================================================
"use client";

import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";

import { cn } from "@/lib/utils";
import { CheckIcon, ChevronRightIcon } from "lucide-react";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, align = "start", sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-48 rounded-md border bg-popover p-2 text-menu-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    icon?: React.ReactNode; // Allow passing a custom icon
  }
>(({ className, children, icon, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    {children}
    <div className="absolute right-3">
      {icon}
    </div>
  </DropdownMenuPrimitive.Item>
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    icon?: React.ReactNode; // Allow passing a custom icon
  }
>(({ className, children, icon, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center justify-between rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    {children}
    <div className="absolute right-3">
      {icon}
    </div>
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, sideOffset = 0, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.SubContent
      ref={ref}
      sideOffset={4} // Reduce the gap between trigger and content
      className={cn(
        "relative z-50 p-2 min-w-[12rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md transition-transform duration-100 ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;



const DropdownMenuPortal = DropdownMenuPrimitive.Portal;


const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, checked, children, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    {children}
    <span className="absolute right-2 flex items-center">
      {checked && <CheckIcon size={15} />}
    </span>
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
  DropdownMenuPortal,
  DropdownMenuCheckboxItem,
};



================================================
FILE: ai_agents/playground/src/components/ui/form.tsx
================================================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-[0.8rem] text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-[0.8rem] font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}



================================================
FILE: ai_agents/playground/src/components/ui/input.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }



================================================
FILE: ai_agents/playground/src/components/ui/label.tsx
================================================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }



================================================
FILE: ai_agents/playground/src/components/ui/popover.tsx
================================================
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverAnchor = PopoverPrimitive.Anchor

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }



================================================
FILE: ai_agents/playground/src/components/ui/progress.tsx
================================================
import * as ProgressPrimitive from "@radix-ui/react-progress";


const Progress = ProgressPrimitive.Root;
const ProgressIndicator = ProgressPrimitive.Indicator;

export { Progress, ProgressIndicator };


================================================
FILE: ai_agents/playground/src/components/ui/select.tsx
================================================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}



================================================
FILE: ai_agents/playground/src/components/ui/sheet.tsx
================================================
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500 data-[state=open]:animate-in data-[state=closed]:animate-out",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
      {children}
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}



================================================
FILE: ai_agents/playground/src/components/ui/sonner.tsx
================================================
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}

export { Toaster }



================================================
FILE: ai_agents/playground/src/components/ui/switch.tsx
================================================
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }



================================================
FILE: ai_agents/playground/src/components/ui/tabs.tsx
================================================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }



================================================
FILE: ai_agents/playground/src/components/ui/textarea.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-base shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }



================================================
FILE: ai_agents/playground/src/components/ui/tooltip.tsx
================================================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Portal>
    <TooltipPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </TooltipPrimitive.Portal>
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }



================================================
FILE: ai_agents/playground/src/lib/utils.ts
================================================
import * as React from "react";
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function useIsMobileScreen(breakpoint?: string) {
  const [isMobileScreen, setIsMobileScreen] = React.useState(false);

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${breakpoint ?? "768px"})`);
    setIsMobileScreen(mql.matches);
    const listener = () => setIsMobileScreen(mql.matches);
    mql.addEventListener("change", listener);

    return () => mql.removeEventListener("change", listener);
  }, [breakpoint]);

  return isMobileScreen;
}



================================================
FILE: ai_agents/playground/src/manager/events.ts
================================================
import { EventHandler } from "./types"

export class AGEventEmitter<T> {
  private readonly _eventMap: Map<keyof T, EventHandler<any[]>[]> = new Map()

  once<Key extends keyof T>(evt: Key, cb: T[Key]) {
    const wrapper = (...args: any[]) => {
      this.off(evt, wrapper as any)
      ;(cb as any)(...args)
    }
    this.on(evt, wrapper as any)
    return this
  }

  on<Key extends keyof T>(evt: Key, cb: T[Key]) {
    const cbs = this._eventMap.get(evt) ?? []
    cbs.push(cb as any)
    this._eventMap.set(evt, cbs)
    return this
  }

  off<Key extends keyof T>(evt: Key, cb: T[Key]) {
    const cbs = this._eventMap.get(evt)
    if (cbs) {
      this._eventMap.set(
        evt,
        cbs.filter((it) => it !== cb),
      )
    }
    return this
  }

  removeAllEventListeners(): void {
    this._eventMap.clear()
  }

  emit<Key extends keyof T>(evt: Key, ...args: any[]) {
    const cbs = this._eventMap.get(evt) ?? []
    for (const cb of cbs) {
      try {
        cb && cb(...args)
      } catch (e) {
        // cb exception should not affect other callbacks
        const error = e as Error
        const details = error.stack || error.message
        console.error(`[event] handling event ${evt.toString()} fail: ${details}`)
      }
    }
    return this
  }
}



================================================
FILE: ai_agents/playground/src/manager/index.ts
================================================
export * from "./rtc";
export * from "./rtm";



================================================
FILE: ai_agents/playground/src/manager/types.ts
================================================
export type EventHandler<T extends any[]> = (...data: T) => void



================================================
FILE: ai_agents/playground/src/manager/rtc/index.ts
================================================
export * from "./rtc"
export * from "./types"



================================================
FILE: ai_agents/playground/src/manager/rtc/rtc.ts
================================================
"use client";

import AgoraRTC, {
  IAgoraRTCClient,
  IMicrophoneAudioTrack,
  IRemoteAudioTrack,
  UID,
} from "agora-rtc-sdk-ng";
import { EMessageDataType, EMessageType, IChatItem, ITextItem } from "@/types";
import { AGEventEmitter } from "../events";
import { RtcEvents, IUserTracks } from "./types";
import { apiGenAgoraData, VideoSourceType } from "@/common";

const TIMEOUT_MS = 5000; // Timeout for incomplete messages

interface TextDataChunk {
  message_id: string;
  part_index: number;
  total_parts: number;
  content: string;
}

export class RtcManager extends AGEventEmitter<RtcEvents> {
  private _joined;
  client: IAgoraRTCClient;
  localTracks: IUserTracks;
  appId: string | null = null;
  token: string | null = null;
  userId: number | null = null;

  constructor() {
    super();
    this._joined = false;
    this.localTracks = {};
    this.client = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });
    this._listenRtcEvents();
  }

  async join({ channel, userId }: { channel: string; userId: number }) {
    if (!this._joined) {
      const res = await apiGenAgoraData({ channel, userId });
      const { code, data } = res;
      if (code != 0) {
        throw new Error("Failed to get Agora token");
      }
      const { appId, token } = data;
      this.appId = appId;
      this.token = token;
      this.userId = userId;
      await this.client?.join(appId, channel, token, userId);
      this._joined = true;
    }
  }

  async createCameraTracks() {
    try {
      const videoTrack = await AgoraRTC.createCameraVideoTrack();
      this.localTracks.videoTrack = videoTrack;
    } catch (err) {
      console.error("Failed to create video track", err);
    }
    this.emit("localTracksChanged", this.localTracks);
  }

  async createMicrophoneAudioTrack() {
    try {
      const audioTrack = await AgoraRTC.createMicrophoneAudioTrack();
      this.localTracks.audioTrack = audioTrack;
    } catch (err) {
      console.error("Failed to create audio track", err);
    }
    this.emit("localTracksChanged", this.localTracks);
  }

  async createScreenShareTrack() {
    try {
      const screenTrack = await AgoraRTC.createScreenVideoTrack({
        encoderConfig: {
          width: 1200,
          height: 800,
          frameRate: 5
        }
      }, "disable");
      this.localTracks.screenTrack = screenTrack;
    } catch (err) {
      console.error("Failed to create screen track", err);
    }
    this.emit("localTracksChanged", this.localTracks);
  }

  async switchVideoSource(type: VideoSourceType) {
    if (type === VideoSourceType.SCREEN) {
      await this.createScreenShareTrack();
      if (this.localTracks.screenTrack) {
        this.client.unpublish(this.localTracks.videoTrack);
        this.localTracks.videoTrack?.close();
        this.localTracks.videoTrack = undefined;
        this.client.publish(this.localTracks.screenTrack);
        this.emit("localTracksChanged", this.localTracks);
      }
    } else if (type === VideoSourceType.CAMERA) {
      await this.createCameraTracks();
      if (this.localTracks.videoTrack) {
        this.client.unpublish(this.localTracks.screenTrack);
        this.localTracks.screenTrack?.close();
        this.localTracks.screenTrack = undefined;
        this.client.publish(this.localTracks.videoTrack);
        this.emit("localTracksChanged", this.localTracks);
      }
    }
  }

  async publish() {
    const tracks = [];
    if (this.localTracks.videoTrack) {
      tracks.push(this.localTracks.videoTrack);
    }
    if (this.localTracks.audioTrack) {
      tracks.push(this.localTracks.audioTrack);
    }
    if (tracks.length) {
      await this.client.publish(tracks);
    }
  }

  async destroy() {
    this.localTracks?.audioTrack?.close();
    this.localTracks?.videoTrack?.close();
    if (this._joined) {
      await this.client?.leave();
    }
    this._resetData();
  }

  // ----------- public methods ------------

  // -------------- private methods --------------
  private _listenRtcEvents() {
    this.client.on("network-quality", (quality) => {
      this.emit("networkQuality", quality);
    });
    this.client.on("user-published", async (user, mediaType) => {
      await this.client.subscribe(user, mediaType);
      if (mediaType === "audio") {
        this._playAudio(user.audioTrack);
      }
      this.emit("remoteUserChanged", {
        userId: user.uid,
        audioTrack: user.audioTrack,
        videoTrack: user.videoTrack,
      });
    });
    this.client.on("user-unpublished", async (user, mediaType) => {
      await this.client.unsubscribe(user, mediaType);
      this.emit("remoteUserChanged", {
        userId: user.uid,
        audioTrack: user.audioTrack,
        videoTrack: user.videoTrack,
      });
    });
    this.client.on("stream-message", (uid: UID, stream: any) => {
      this._parseData(stream);
    });
  }

  private _parseData(data: any): ITextItem | void {
    let decoder = new TextDecoder("utf-8");
    let decodedMessage = decoder.decode(data);

    console.log("[test] textstream raw data", decodedMessage);

    // const { stream_id, is_final, text, text_ts, data_type, message_id, part_number, total_parts } = textstream;

    // if (total_parts > 0) {
    //   // If message is split, handle it accordingly
    //   this._handleSplitMessage(message_id, part_number, total_parts, stream_id, is_final, text, text_ts);
    // } else {
    //   // If there is no message_id, treat it as a complete message
    //   this._handleCompleteMessage(stream_id, is_final, text, text_ts);
    // }

    this.handleChunk(decodedMessage);
  }

  private messageCache: { [key: string]: TextDataChunk[] } = {};

  // Function to process received chunk via event emitter
  handleChunk(formattedChunk: string) {
    try {
      // Split the chunk by the delimiter "|"
      const [message_id, partIndexStr, totalPartsStr, content] =
        formattedChunk.split("|");

      const part_index = parseInt(partIndexStr, 10);
      const total_parts =
        totalPartsStr === "???" ? -1 : parseInt(totalPartsStr, 10); // -1 means total parts unknown

      // Ensure total_parts is known before processing further
      if (total_parts === -1) {
        console.warn(
          `Total parts for message ${message_id} unknown, waiting for further parts.`
        );
        return;
      }

      const chunkData: TextDataChunk = {
        message_id,
        part_index,
        total_parts,
        content,
      };

      // Check if we already have an entry for this message
      if (!this.messageCache[message_id]) {
        this.messageCache[message_id] = [];
        // Set a timeout to discard incomplete messages
        setTimeout(() => {
          if (this.messageCache[message_id]?.length !== total_parts) {
            console.warn(`Incomplete message with ID ${message_id} discarded`);
            delete this.messageCache[message_id]; // Discard incomplete message
          }
        }, TIMEOUT_MS);
      }

      // Cache this chunk by message_id
      this.messageCache[message_id].push(chunkData);

      // If all parts are received, reconstruct the message
      if (this.messageCache[message_id].length === total_parts) {
        const completeMessage = this.reconstructMessage(
          this.messageCache[message_id]
        );
        const { stream_id, is_final, text, text_ts, data_type } = JSON.parse(
          atob(completeMessage)
        );
        console.log(`[test] message_id: ${message_id} stream_id: ${stream_id}, text: ${text}, data_type: ${data_type}`);
        const isAgent = Number(stream_id) != Number(this.userId)
        let textItem: IChatItem = {
          type: isAgent ? EMessageType.AGENT : EMessageType.USER,
          time: text_ts,
          text: text,
          data_type: EMessageDataType.TEXT,
          userId: stream_id,
          isFinal: is_final,
        };;

        if (data_type === "raw") {
          let { data, type } = JSON.parse(text);
          if (type === "image_url") {
            textItem = {
              ...textItem,
              data_type: EMessageDataType.IMAGE,
              text: data.image_url,
            };
          } else if (type === "reasoning") {
            textItem = {
              ...textItem,
              data_type: EMessageDataType.REASON,
              text: data.text,
            };
          } else if (type === "action") {
            const { action, data: actionData } = data
            if (action === "browse_website") {
              console.log("Opening website", actionData.url)
              window.open(actionData.url, "_blank")
              return
            }
          }
        }

        if (text.trim().length > 0) {
          this.emit("textChanged", textItem);
        }

        // Clean up the cache
        delete this.messageCache[message_id];
      }
    } catch (error) {
      console.error("Error processing chunk:", error);
    }
  }

  // Function to reconstruct the full message from chunks
  reconstructMessage(chunks: TextDataChunk[]): string {
    // Sort chunks by their part index
    chunks.sort((a, b) => a.part_index - b.part_index);

    // Concatenate all chunks to form the full message
    return chunks.map((chunk) => chunk.content).join("");
  }

  _playAudio(
    audioTrack: IMicrophoneAudioTrack | IRemoteAudioTrack | undefined
  ) {
    if (audioTrack && !audioTrack.isPlaying) {
      audioTrack.play();
    }
  }

  private _resetData() {
    this.localTracks = {};
    this._joined = false;
  }
}

export const rtcManager = new RtcManager();



================================================
FILE: ai_agents/playground/src/manager/rtc/types.ts
================================================
import {
  UID,
  IAgoraRTCRemoteUser,
  IAgoraRTCClient,
  ICameraVideoTrack,
  IMicrophoneAudioTrack,
  NetworkQuality,
  ILocalVideoTrack,
} from "agora-rtc-sdk-ng"
import { IChatItem, ITextItem } from "@/types"

export interface IRtcUser extends IUserTracks {
  userId: UID
}

export interface RtcEvents {
  remoteUserChanged: (user: IRtcUser) => void
  localTracksChanged: (tracks: IUserTracks) => void
  networkQuality: (quality: NetworkQuality) => void
  textChanged: (text: IChatItem) => void
}

export interface IUserTracks {
  videoTrack?: ICameraVideoTrack
  screenTrack?: ILocalVideoTrack
  audioTrack?: IMicrophoneAudioTrack
}



================================================
FILE: ai_agents/playground/src/manager/rtm/index.ts
================================================
"use client"

import AgoraRTM, { type RTMClient, type RTMStreamChannel } from "agora-rtm"
import { AGEventEmitter } from "../events"
import { apiGenAgoraData } from "@/common"
import { type IRTMTextItem, ERTMTextType } from "@/types"

export interface IRtmEvents {
  rtmMessage: (text: any) => void // TODO: update type
}

export type TRTMMessageEvent = {
  channelType: "STREAM" | "MESSAGE" | "USER"
  channelName: string
  topicName?: string
  messageType: "STRING" | "BINARY"
  customType?: string
  publisher: string
  message: string | Uint8Array
  timestamp: number
}

export class RtmManager extends AGEventEmitter<IRtmEvents> {
  private _joined: boolean
  _client: RTMClient | null
  channel: string = ""
  userId: number = 0
  appId: string = ""
  token: string = ""

  constructor() {
    super()
    this._joined = false
    this._client = null
  }

  async init({
    channel,
    userId,
    appId,
    token,
  }: {
    channel: string
    userId: number
    appId: string
    token: string
  }) {
    if (this._joined) {
      return
    }
    this.channel = channel
    this.userId = userId
    this.appId = appId
    this.token = token
    const rtm = new AgoraRTM.RTM(appId, String(userId), {
      logLevel: "debug", // TODO: use INFO
      // update config: https://doc.shengwang.cn/api-ref/rtm2/javascript/toc-configuration/configuration#rtmConfig
    })
    await rtm.login({ token })
    try {
      // subscribe message channel(will be created automatically)
      const subscribeResult = await rtm.subscribe(channel, {
        withMessage: true,
        withPresence: true,
        beQuiet: false,
        withMetadata: true,
        withLock: true,
      })
      console.log("[RTM] Subscribe Message Channel success!: ", subscribeResult)

      this._joined = true
      this._client = rtm

      // listen events
      this._listenRtmEvents()
    } catch (status) {
      console.error("Failed to Create/Join Message Channel", status)
    }
  }

  private _listenRtmEvents() {
    this._client!.addEventListener("message", this.handleRtmMessage.bind(this))
    // tmp add presence
    this._client!.addEventListener(
      "presence",
      this.handleRtmPresence.bind(this),
    )
    console.log("[RTM] Listen RTM events success!")
  }

  async handleRtmMessage(e: TRTMMessageEvent) {
    console.log("[RTM] [TRTMMessageEvent] RAW", JSON.stringify(e))
    const { message, messageType } = e
    if (messageType === "STRING") {
      const msg: IRTMTextItem = JSON.parse(message as string)
      if (msg) {
        console.log("[RTM] Emitting rtmMessage event with msg:", msg)
        this.emit("rtmMessage", msg)
      }
    }
    if (messageType === "BINARY") {
      const decoder = new TextDecoder("utf-8")
      const decodedMessage = decoder.decode(message as Uint8Array)
      const msg: IRTMTextItem = JSON.parse(decodedMessage)
      this.emit("rtmMessage", msg)
    }
  }

  async handleRtmPresence(e: any) {
    console.log("[RTM] [TRTMPresenceEvent] RAW", JSON.stringify(e))
  }

  async sendText(text: string) {
    const msg: IRTMTextItem = {
      is_final: true,
      ts: Date.now(),
      text,
      type: ERTMTextType.INPUT_TEXT,
      stream_id: String(this.userId),
    }
    await this._client?.publish(this.channel, JSON.stringify(msg), {
      customType: "PainTxt",
    })
    this.emit("rtmMessage", msg)
  }

  async destroy() {
    // remove listener
    this._client?.removeEventListener(
      "message",
      this.handleRtmMessage.bind(this),
    )
    this._client?.removeEventListener(
      "presence",
      this.handleRtmPresence.bind(this),
    )
    // unsubscribe
    await this._client?.unsubscribe(this.channel)
    // logout
    await this._client?.logout()

    this._client = null
    this._joined = false
  }
}

export const rtmManager = new RtmManager()



================================================
FILE: ai_agents/playground/src/protobuf/SttMessage.js
================================================
[Empty file]


================================================
FILE: ai_agents/playground/src/protobuf/SttMessage.proto
================================================
syntax = "proto3";

package Agora.SpeechToText;

option objc_class_prefix = "Stt";

option csharp_namespace = "AgoraSTTSample.Protobuf";

option java_package = "io.agora.rtc.speech2text";
option java_outer_classname = "AgoraSpeech2TextProtobuffer";

message Text {
  int32 vendor = 1;
  int32 version = 2;
  int32 seqnum = 3;
  int64 uid = 4;
  int32 flag = 5;
  int64 time = 6;
  int32 lang = 7;
  int32 starttime = 8;
  int32 offtime = 9;
  repeated Word words = 10;
  bool end_of_segment = 11;
  int32 duration_ms = 12;
  string data_type = 13; // transcribe ,translate
  repeated Translation trans = 14;
  string culture = 15;
}
message Word {
  string text = 1;
  int32 start_ms = 2;
  int32 duration_ms = 3;
  bool is_final = 4;
  double confidence = 5;
}
message Translation {
  bool is_final = 1;
  string lang = 2; // 翻译语言
  repeated string texts = 3;
}



================================================
FILE: ai_agents/playground/src/protobuf/SttMessage_es6.js
================================================
/* eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars */
import * as $protobuf from "protobufjs/light"

const $root = ($protobuf.roots.default || ($protobuf.roots.default = new $protobuf.Root())).addJSON(
  {
    Agora: {
      nested: {
        SpeechToText: {
          options: {
            objc_class_prefix: "Stt",
            csharp_namespace: "AgoraSTTSample.Protobuf",
            java_package: "io.agora.rtc.speech2text",
            java_outer_classname: "AgoraSpeech2TextProtobuffer",
          },
          nested: {
            Text: {
              fields: {
                vendor: {
                  type: "int32",
                  id: 1,
                },
                version: {
                  type: "int32",
                  id: 2,
                },
                seqnum: {
                  type: "int32",
                  id: 3,
                },
                uid: {
                  type: "uint32",
                  id: 4,
                },
                flag: {
                  type: "int32",
                  id: 5,
                },
                time: {
                  type: "int64",
                  id: 6,
                },
                lang: {
                  type: "int32",
                  id: 7,
                },
                starttime: {
                  type: "int32",
                  id: 8,
                },
                offtime: {
                  type: "int32",
                  id: 9,
                },
                words: {
                  rule: "repeated",
                  type: "Word",
                  id: 10,
                },
                endOfSegment: {
                  type: "bool",
                  id: 11,
                },
                durationMs: {
                  type: "int32",
                  id: 12,
                },
                dataType: {
                  type: "string",
                  id: 13,
                },
                trans: {
                  rule: "repeated",
                  type: "Translation",
                  id: 14,
                },
                culture: {
                  type: "string",
                  id: 15,
                },
                textTs: {
                  type: "int64",
                  id: 16,
                },
              },
            },
            Word: {
              fields: {
                text: {
                  type: "string",
                  id: 1,
                },
                startMs: {
                  type: "int32",
                  id: 2,
                },
                durationMs: {
                  type: "int32",
                  id: 3,
                },
                isFinal: {
                  type: "bool",
                  id: 4,
                },
                confidence: {
                  type: "double",
                  id: 5,
                },
              },
            },
            Translation: {
              fields: {
                isFinal: {
                  type: "bool",
                  id: 1,
                },
                lang: {
                  type: "string",
                  id: 2,
                },
                texts: {
                  rule: "repeated",
                  type: "string",
                  id: 3,
                },
              },
            },
          },
        },
      },
    },
  },
)

export { $root as default }



================================================
FILE: ai_agents/playground/src/store/index.ts
================================================
"use client"

import globalReducer from "./reducers/global"
import { configureStore } from '@reduxjs/toolkit'

export * from "./provider"

export const makeStore = () => {
  return configureStore({
    reducer: {
      global: globalReducer,
    },
    devTools: process.env.NODE_ENV !== "production",
  })
}

// Infer the type of makeStore
export type AppStore = ReturnType<typeof makeStore>
// Infer the `RootState` and `AppDispatch` types from the store itself
export type RootState = ReturnType<AppStore['getState']>
export type AppDispatch = AppStore['dispatch']



================================================
FILE: ai_agents/playground/src/store/provider/index.tsx
================================================
"use client";

import { useRef } from 'react'
import { Provider } from 'react-redux'
import { makeStore, AppStore } from '..'

export function StoreProvider({
  children
}: {
  children: React.ReactNode
}) {
  const storeRef = useRef<AppStore>()
  
  if (!storeRef.current) {
    // Create the store instance the first time this renders
    storeRef.current = makeStore()
  }

  return <Provider store={storeRef.current}>{children}</Provider>
}




================================================
FILE: ai_agents/playground/src/store/reducers/global.ts
================================================
import {
  IOptions,
  IChatItem,
  Language,
  VoiceType,
  ITrulienceSettings,
} from "@/types";
import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
import {
  EMobileActiveTab,
  DEFAULT_OPTIONS,
  COLOR_LIST,
  isEditModeOn,
  DEFAULT_TRULIENCE_OPTIONS
} from "@/common/constant";
import {
  apiReloadPackage,
  apiFetchGraphs,
  apiFetchInstalledAddons,
  apiFetchGraphDetails,
  apiUpdateGraph,
  apiSaveProperty,
  apiLoadApp,
} from "@/common/request"
import {
  setOptionsToLocal,
  setTrulienceSettingsToLocal,
} from "@/common/storage"
import { AddonDef, Graph } from "@/common/graph";
import { useAppSelector } from "@/common/hooks";

export interface InitialState {
  options: IOptions;
  roomConnected: boolean;
  agentConnected: boolean;
  rtmConnected: boolean;
  themeColor: string;
  language: Language;
  voiceType: VoiceType;
  chatItems: IChatItem[];
  selectedGraphId: string;
  graphList: Graph[];
  graphMap: Record<string, Graph>;
  addonModules: AddonDef.Module[]; // addon modules
  mobileActiveTab: EMobileActiveTab;
  trulienceSettings: ITrulienceSettings;
}

const getInitialState = (): InitialState => {
  return {
    options: DEFAULT_OPTIONS,
    themeColor: COLOR_LIST[0].active,
    roomConnected: false,
    agentConnected: false,
    rtmConnected: false,
    language: "en-US",
    voiceType: "male",
    chatItems: [],
    selectedGraphId: "",
    graphList: [],
    graphMap: {},
    addonModules: [],
    mobileActiveTab: EMobileActiveTab.AGENT,
    trulienceSettings: DEFAULT_TRULIENCE_OPTIONS,
  };
};

export const globalSlice = createSlice({
  name: "global",
  initialState: getInitialState(),
  reducers: {
    setOptions: (state, action: PayloadAction<Partial<IOptions>>) => {
      state.options = { ...state.options, ...action.payload };
      setOptionsToLocal(state.options);
    },
    setTrulienceSettings: (state, action: PayloadAction<ITrulienceSettings>) => {
      state.trulienceSettings = { ...state.trulienceSettings, ...action.payload };
      setTrulienceSettingsToLocal(state.trulienceSettings);
    },
    setThemeColor: (state, action: PayloadAction<string>) => {
      state.themeColor = action.payload;
      document.documentElement.style.setProperty(
        "--theme-color",
        action.payload
      );
    },
    setRoomConnected: (state, action: PayloadAction<boolean>) => {
      state.roomConnected = action.payload;
    },
    setRtmConnected: (state, action: PayloadAction<boolean>) => {
      state.rtmConnected = action.payload;
    },
    addChatItem: (state, action: PayloadAction<IChatItem>) => {
      const { userId, text, isFinal, type, time } = action.payload;
      const LastFinalIndex = state.chatItems.findLastIndex((el) => {
        return el.userId == userId && el.isFinal;
      });
      const LastNonFinalIndex = state.chatItems.findLastIndex((el) => {
        return el.userId == userId && !el.isFinal;
      });
      let LastFinalItem = state.chatItems[LastFinalIndex];
      let LastNonFinalItem = state.chatItems[LastNonFinalIndex];
      if (LastFinalItem) {
        // has last final Item
        if (time <= LastFinalItem.time) {
          // discard
          console.log(
            "[test] addChatItem, time < last final item, discard!:",
            text,
            isFinal,
            type
          );
          return;
        } else {
          if (LastNonFinalItem) {
            console.log(
              "[test] addChatItem, update last item(none final):",
              text,
              isFinal,
              type
            );
            state.chatItems[LastNonFinalIndex] = action.payload;
          } else {
            console.log(
              "[test] addChatItem, add new item:",
              text,
              isFinal,
              type
            );
            state.chatItems.push(action.payload);
          }
        }
      } else {
        // no last final Item
        if (LastNonFinalItem) {
          console.log(
            "[test] addChatItem, update last item(none final):",
            text,
            isFinal,
            type
          );
          state.chatItems[LastNonFinalIndex] = action.payload;
        } else {
          console.log("[test] addChatItem, add new item:", text, isFinal, type);
          state.chatItems.push(action.payload);
        }
      }
      state.chatItems.sort((a, b) => a.time - b.time);
    },
    setAgentConnected: (state, action: PayloadAction<boolean>) => {
      state.agentConnected = action.payload;
    },
    setLanguage: (state, action: PayloadAction<Language>) => {
      state.language = action.payload;
    },
    setSelectedGraphId: (state, action: PayloadAction<string>) => {
      state.selectedGraphId = action.payload;
    },
    setGraphList: (state, action: PayloadAction<Graph[]>) => {
      state.graphList = action.payload;
    },
    setVoiceType: (state, action: PayloadAction<VoiceType>) => {
      state.voiceType = action.payload;
    },
    setMobileActiveTab: (state, action: PayloadAction<EMobileActiveTab>) => {
      state.mobileActiveTab = action.payload;
    },
    reset: (state) => {
      Object.assign(state, getInitialState());
      document.documentElement.style.setProperty(
        "--theme-color",
        COLOR_LIST[0].active
      );
    },
    setGraph: (state, action: PayloadAction<Graph>) => {
      let graphMap = JSON.parse(JSON.stringify(state.graphMap));
      graphMap[action.payload.uuid] = action.payload;
      state.graphMap = graphMap;
    },
    setAddonModules: (state, action: PayloadAction<Record<string, any>[]>) => {
      state.addonModules = JSON.parse(JSON.stringify(action.payload));
    }
  },
});

// Initialize graph data
let initializeGraphData: any;
// Fetch graph details
let fetchGraphDetails: any;

if (isEditModeOn) {
  // only for development, below requests depend on dev-server
  initializeGraphData = createAsyncThunk(
    "global/initializeGraphData",
    async (_, { dispatch }) => {
      await apiReloadPackage();
      await apiLoadApp();
      const [fetchedGraphs, modules] = await Promise.all([
        apiFetchGraphs(),
        apiFetchInstalledAddons(),
      ]);
      dispatch(setGraphList(fetchedGraphs.map((graph) => graph)));
      dispatch(setAddonModules(modules));
    }
  );
  fetchGraphDetails = createAsyncThunk(
    "global/fetchGraphDetails",
    async (graph: Graph, { dispatch }) => {
      const updatedGraph = await apiFetchGraphDetails(graph);
      dispatch(setGraph(updatedGraph));
    }
  );
} else {
  initializeGraphData = createAsyncThunk(
    "global/initializeGraphData",
    async (_, { dispatch }) => {
      const fetchedGraphs = await apiFetchGraphs();
      dispatch(setGraphList(fetchedGraphs.map((graph) => graph)));
    }
  );
  fetchGraphDetails = createAsyncThunk(
    "global/fetchGraphDetails",
    async (graphId: string, { dispatch }) => {
      // Do nothing in production
      return
    }
  );
}

// Update a graph
export const updateGraph = createAsyncThunk(
  "global/updateGraph",
  async (
    { graph, updates }: { graph: Graph; updates: Partial<Graph> },
    { dispatch, rejectWithValue }
  ) => {
    try {
      await apiUpdateGraph(graph.uuid, updates);
      // await apiSaveProperty();
      const updatedGraph = await apiFetchGraphDetails(graph);
      dispatch(setGraph(updatedGraph));
      return updatedGraph; // Optionally return the updated graph
    } catch (error: any) {
      // Handle error gracefully
      console.error("Error updating graph:", error);
      return rejectWithValue(error.response?.data || error.message);
    }
  }
);

export const {
  reset,
  setOptions,
  setRoomConnected,
  setAgentConnected,
  setRtmConnected,
  setVoiceType,
  addChatItem,
  setThemeColor,
  setLanguage,
  setSelectedGraphId,
  setGraphList,
  setMobileActiveTab,
  setGraph,
  setAddonModules,
  setTrulienceSettings,
} = globalSlice.actions;

export {
  initializeGraphData, fetchGraphDetails
}

export default globalSlice.reducer;



================================================
FILE: ai_agents/playground/src/types/index.ts
================================================
export type Language = "en-US" | "zh-CN" | "ja-JP" | "ko-KR";
export type VoiceType = "male" | "female";

export interface ColorItem {
  active: string;
  default: string;
}

export interface IOptions {
  channel: string;
  userName: string;
  userId: number;
  appId: string;
  token: string;
}

export interface IAgentSettings {
  prompt: string;
  greeting: string;
}

export interface ITrulienceSettings {
  enabled: boolean;
  avatarToken: string;
  avatarId: string;
  avatarDesktopLargeWindow: boolean;
  animationURL: string;
  trulienceSDK: string;
}

export enum EMessageType {
  AGENT = "agent",
  USER = "user",
}

export enum EMessageDataType {
  TEXT = "text",
  REASON = "reason",
  IMAGE = "image",
}

export interface IChatItem {
  userId: number | string;
  userName?: string;
  text: string;
  data_type: EMessageDataType;
  type: EMessageType;
  isFinal?: boolean;
  time: number;
}

/** @deprecated */
export interface ITextItem {
  dataType: "transcribe" | "translate" | "image_url";
  uid: string;
  time: number;
  text: string;
  isFinal: boolean;
}

export enum ERTMTextType {
  TRANSCRIBE = "transcribe",
  TRANSLATE = "translate",
  INPUT_TEXT = "input_text",
  INPUT_IMAGE = "input_image",
  INPUT_AUDIO = "input_audio",
  INPUT_FILE = "input_file",
}

export interface IRTMTextItem {
  is_final: boolean;
  type: ERTMTextType;
  ts: number;
  text: string;
  stream_id: string;
}

export interface GraphOptionItem {
  label: string;
  value: string;
}

export interface LanguageOptionItem {
  label: string;
  value: Language;
}

export interface VoiceOptionItem {
  label: string;
  value: VoiceType;
}

export interface OptionType {
  value: string;
  label: string;
}

export interface IPdfData {
  fileName: string;
  collection: string;
}


