Directory structure:
└── ten-framework-ten-vad/
    ├── README.md
    ├── LICENSE
    ├── NOTICES
    ├── requirements.txt
    ├── setup.py
    ├── examples/
    │   ├── build-and-deploy-android.sh
    │   ├── build-and-deploy-ios.sh
    │   ├── build-and-deploy-linux.sh
    │   ├── build-and-deploy-mac.sh
    │   ├── build-and-deploy-windows.bat
    │   ├── CMakeLists.txt
    │   ├── main.c
    │   ├── plot_pr_curves.py
    │   ├── requirements.txt
    │   ├── test.py
    │   └── test_node.js
    ├── examples_onnx/
    │   ├── build-and-deploy-linux.sh
    │   └── CMakeLists.txt
    ├── include/
    │   ├── ten_vad.h
    │   └── ten_vad.py
    ├── lib/
    │   ├── iOS/
    │   │   └── ten_vad.framework/
    │   │       ├── Info.plist
    │   │       ├── Headers/
    │   │       │   └── ten_vad.h
    │   │       └── Modules/
    │   │           └── module.modulemap
    │   ├── macOS/
    │   │   └── ten_vad.framework/
    │   │       ├── Headers -> Headers
    │   │       ├── Resources -> Resources
    │   │       ├── ten_vad -> ten_vad
    │   │       └── Versions/
    │   │           ├── A/
    │   │           │   ├── Headers/
    │   │           │   │   └── ten_vad.h
    │   │           │   └── Resources/
    │   │           │       └── Info.plist
    │   │           └── Current -> A
    │   └── Web/
    │       ├── ten_vad.d.ts
    │       └── ten_vad.js
    ├── src/
    │   ├── aed.cc
    │   ├── aed.h
    │   ├── aed_st.h
    │   ├── biquad.cc
    │   ├── biquad.h
    │   ├── biquad_st.h
    │   ├── coeff.h
    │   ├── fftw.h
    │   ├── fscvrt.cc
    │   ├── fscvrt.h
    │   ├── fscvrt_st.h
    │   ├── pitch_est.cc
    │   ├── pitch_est.h
    │   ├── pitch_est_st.h
    │   ├── stft.cc
    │   ├── stft.h
    │   ├── stft_st.h
    │   └── ten_vad.cc
    ├── testset/
    │   ├── testset-audio-01.scv
    │   ├── testset-audio-02.scv
    │   ├── testset-audio-03.scv
    │   ├── testset-audio-04.scv
    │   ├── testset-audio-05.scv
    │   ├── testset-audio-06.scv
    │   ├── testset-audio-07.scv
    │   ├── testset-audio-08.scv
    │   ├── testset-audio-09.scv
    │   ├── testset-audio-10.scv
    │   ├── testset-audio-11.scv
    │   ├── testset-audio-12.scv
    │   ├── testset-audio-13.scv
    │   ├── testset-audio-14.scv
    │   ├── testset-audio-15.scv
    │   ├── testset-audio-16.scv
    │   ├── testset-audio-17.scv
    │   ├── testset-audio-18.scv
    │   ├── testset-audio-19.scv
    │   ├── testset-audio-20.scv
    │   ├── testset-audio-21.scv
    │   ├── testset-audio-22.scv
    │   ├── testset-audio-23.scv
    │   ├── testset-audio-24.scv
    │   ├── testset-audio-25.scv
    │   ├── testset-audio-26.scv
    │   ├── testset-audio-27.scv
    │   ├── testset-audio-28.scv
    │   ├── testset-audio-29.scv
    │   └── testset-audio-30.scv
    └── .github/
        └── workflows/
            └── test-platforms.yml

================================================
FILE: README.md
================================================
![TEN VAD banner][ten-vad-banner]

[![TEN Releases]( https://img.shields.io/github/v/release/ten-framework/ten-vad?color=369eff&labelColor=gray&logo=github&style=flat-square )](https://github.com/TEN-framework/ten-vad/releases)
[![Release Date](https://img.shields.io/github/release-date/ten-framework/ten-vad?labelColor=gray&style=flat-square)](https://github.com/TEN-framework/ten-vad/releases)
[![Discussion posts](https://img.shields.io/github/discussions/TEN-framework/ten-vad?labelColor=gray&color=%20%23f79009)](https://github.com/TEN-framework/ten-vad/discussions/)
[![Commits](https://img.shields.io/github/commit-activity/m/TEN-framework/ten-vad?labelColor=gray&color=pink)](https://github.com/TEN-framework/ten-vad/graphs/commit-activity)
[![Issues closed](https://img.shields.io/github/issues-search?query=repo%3ATEN-framework%2Ften-vad%20is%3Aclosed&label=issues%20closed&labelColor=gray&color=green)](https://github.com/TEN-framework/ten-vad/issues)
![](https://img.shields.io/github/contributors/ten-framework/ten-vad?color=c4f042&labelColor=gray&style=flat-square)
[![PRs Welcome](https://img.shields.io/badge/PRs-welcome!-brightgreen.svg?style=flat-square)](https://github.com/TEN-framework/ten-vad/pulls)
[![HuggingFace TEN VAD](https://img.shields.io/badge/Hugging%20Face-TEN%20VAD-yellow?style=flat&logo=huggingface)](https://huggingface.co/TEN-framework/ten-vad)
[![GitHub license](https://img.shields.io/badge/License-Apache_2.0_with_certain_conditions-blue.svg?labelColor=%20%23155EEF&color=%20%23528bff)](https://github.com/TEN-framework/ten-vad/blob/main/LICENSE)
[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/TEN-framework/TEN-vad)
[![ReadmeX](https://raw.githubusercontent.com/CodePhiliaX/resource-trusteeship/main/readmex.svg)](https://readmex.com/TEN-framework/ten-vad)

[![GitHub watchers](https://img.shields.io/github/watchers/TEN-framework/ten-vad?style=social&label=Watch)](https://GitHub.com/TEN-framework/ten-vad/watchers/?WT.mc_id=academic-105485-koreyst)
[![GitHub forks](https://img.shields.io/github/forks/TEN-framework/ten-vad?style=social&label=Fork)](https://GitHub.com/TEN-framework/ten-vad/network/?WT.mc_id=academic-105485-koreyst)
[![GitHub stars](https://img.shields.io/github/stars/TEN-framework/ten-vad?style=social&label=Star)](https://GitHub.com/TEN-framework/ten-vad/stargazers/?WT.mc_id=academic-105485-koreyst)

<br>

## Latest News 🔥
- [2025/07] 🎉 Exciting news! **TEN VAD** is now **integrated** into [**k2-fsa/sherpa-onnx**](https://github.com/k2-fsa/sherpa-onnx), thanks to the fantastic work by [Fangjun Kuang](https://github.com/csukuangfj)! You can now achieve more precise speech segment extraction and enjoy an enhanced ASR experience! Refer to the [documentation](https://k2-fsa.github.io/sherpa/onnx/vad/ten-vad.html#) and give it a try!
- [2025/07] We supported **Python inference** on **macOS** and **Windows** with usage of the prebuilt-lib!
- [2025/06] We **finally** released and **open-sourced** the **ONNX** model and the corresponding **preprocessing code**! Now you can deploy **TEN VAD** on **any platform** and **any hardware architecture**!
- [2025/06] We are excited to announce the release of **WASM+JS** for Web WASM Support.

<br>

## Table of Contents

- [Welcome to TEN](#welcome-to-ten)
- [TEN Hugging Face Space](#ten-hugging-face-space)
- [Introduction](#introduction)
- [Key Features](#key-features)
  - [High-Performance](#1-high-performance)
  - [Agent-Friendly](#2-agent-friendly)
  - [Lightweight](#3-lightweight)
  - [Multiple Programming Languages and Platforms](#4-multiple-programming-languages-and-platforms)
  - [Supported Sampling Rate and Hop Size](#5-supproted-sampling-rate-and-hop-size)
- [Installation](#installation)
- [Quick Start](#quick-start)
  - [Python Usage](#python-usage)
    - [Linux](#1-linux)
  - [JS Usage](#js-usage)
    - [Web](#1-web)
  - [C Usage](#c-usage)
    - [Linux](#1-linux-1)
    - [Windows](#2-windows)
    - [macOS](#3-macos)
    - [Android](#4-android)
    - [iOS](#5-ios)
- [TEN Ecosystem](#ten-ecosystem)
- [Ask Questions](#ask-questions)
- [Citations](#citations)
- [License](#license)

<br>

## Welcome to TEN

TEN is a comprehensive open-source ecosystem for creating, customizing, and deploying real-time conversational AI agents with multimodal capabilities including voice, vision, and avatar interactions.

TEN includes [TEN Framework](https://github.com/ten-framework/ten-framework), [TEN Turn Detection](https://github.com/ten-framework/ten-turn-detection), [TEN VAD](https://github.com/ten-framework/ten-vad), [TEN Agent](https://github.com/TEN-framework/ten-framework/tree/main/ai_agents/demo), [TMAN Designer](https://github.com/TEN-framework/ten-framework/tree/main/core/src/ten_manager/designer_frontend), and [TEN Portal](https://github.com/ten-framework/portal). Check out [TEN Ecosystem](#ten-ecosystem) for more details.

<br>

| Community Channel                                                                                                                                                                      | Purpose                                                          |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- |
| [![Follow on X](https://img.shields.io/twitter/follow/TenFramework?logo=X&color=%20%23f5f5f5)](https://twitter.com/intent/follow?screen_name=TenFramework)                             | Follow TEN Framework on X for updates and announcements          |
| [![Follow on LinkedIn](https://custom-icon-badges.demolab.com/badge/LinkedIn-TEN_Framework-0A66C2?logo=linkedin-white&logoColor=fff)](https://www.linkedin.com/company/ten-framework)  | Follow TEN Framework on LinkedIn for updates and announcements   |
| [![Discord TEN Community](https://dcbadge.vercel.app/api/server/VnPftUzAMJ?&style=flat&theme=light&color=lightgray)](https://discord.gg/VnPftUzAMJ)                                    | Join our Discord community to connect with developers            |
| [![Hugging Face Space](https://img.shields.io/badge/Hugging%20Face-TEN%20Framework-yellow?style=flat&logo=huggingface)](https://huggingface.co/TEN-framework)                          | Join our Hugging Face community to explore our spaces and models |
| [![WeChat](https://img.shields.io/badge/TEN_Framework-WeChat_Group-%2307C160?logo=wechat&labelColor=darkgreen&color=gray)](https://github.com/TEN-framework/ten-agent/discussions/170) | Join our WeChat group for Chinese community discussions          |

<br>

> \[!IMPORTANT]
>
> **Star TEN Repositories** ⭐️
>
> Get instant notifications for new releases and updates. Your support helps us grow and improve TEN!

<br>

![TEN star us gif](https://github.com/user-attachments/assets/eeebe996-8c14-4bf7-82ae-f1a1f7e30705)

<br>

## TEN Hugging Face Space

<https://github.com/user-attachments/assets/725a8318-d679-4b17-b9e4-e3dce999b298>

You are more than welcome to [Visit TEN Hugging Face Space](https://huggingface.co/spaces/TEN-framework/ten-agent-demo) to try VAD and Turn Detection together.

<br>

## **Introduction**

**TEN VAD** is a real-time voice activity detection system designed for enterprise use, providing accurate frame-level speech activity detection. It shows superior precision compared to both WebRTC VAD and Silero VAD, which are commonly used in the industry. Additionally, TEN VAD offers lower computational complexity and reduced memory usage compared to Silero VAD. Meanwhile, the architecture's temporal efficiency enables rapid voice activity detection, significantly reducing end-to-end response and turn detection latency in conversational AI systems.

<br>

## **Key Features**

### **1. High-Performance:**

The precision-recall curves comparing the performance of WebRTC VAD (pitch-based), Silero VAD, and TEN VAD are shown below. The evaluation is conducted on the precisely manually annotated testset. The audio files are from librispeech, gigaspeech, DNS Challenge etc. As demonstrated, TEN VAD achieves the best performance. Additionally, cross-validation experiments conducted on large internal real-world datasets demonstrate the reproducibility of these findings. The **testset with annotated labels** is released in directory "testset" of this repository.

 <br>

<div style="text-align:">
  <img src="./examples/images/PR_Curves_testset.png" width="800">
</div>

Note that the default threshold of 0.5 is used to generate binary speech indicators (0 for non-speech signal, 1 for speech signal). This threshold needs to be tuned according to your domain-specific task. The precision-recall curve can be obtained by executing the following script on Linux x64. The output figure will be saved in the same directory as the script.

```
cd ./examples
python plot_pr_curves.py
```

<br>

### **2. Agent-Friendly:**

As illustrated in the figure below, TEN VAD rapidly detects speech-to-non-speech transitions, whereas Silero VAD suffers from a delay of several hundred milliseconds, resulting in increased end-to-end latency in human-agent interaction systems. In addition, as demonstrated in the 6.5s-7.0s audio segment, Silero VAD fails to identify short silent durations between adjacent speech segments.

<div style="text-align:">
  <img src="./examples/images/Agent-Friendly-image.png" width="800">
</div>
<br>

### **3. Lightweight:**

We evaluated the RTF (Real-Time Factor) across five distinct platforms, each equipped with varying CPUs. TEN VAD demonstrates much lower computational complexity and smaller library size than Silero VAD.

<table>
  <tr>
    <th align="center" rowspan="2" valign="middle"> Platform </th>
    <th align="center" rowspan="2" valign="middle"> CPU </th>
    <th align="center" colspan="2"> RTF </th>
    <th align="center" colspan="2"> Lib Size </th>

  </tr>
  <tr>
    <th align="center" style="white-space: nowrap;"> TEN VAD </th>
    <th align="center" style="white-space: nowrap;"> Silero VAD </th>
    <th align="center"> TEN VAD </th>
    <th align="center"> Silero VAD </th>
  </tr>
  <tr>
    <th align="center" rowspan="3"> Linux </th>
    <td style="white-space: nowrap;"> AMD Ryzen 9 5900X 12-Core </td>
    <td align="center"> 0.0150 </td>
    <td align="center" rowspan="2" valign="middle"> / </td>
    <td align="center" rowspan="3" valign="middle"> 306KB </td>
    <td align="center" rowspan="10" style="white-space: nowrap;" valign="middle"> 2.16MB(JIT) / 2.22MB(ONNX) </td>
  </tr>
  <tr>
    <td style="white-space: nowrap;"> Intel(R) Xeon(R) Platinum 8253 </td>
    <td align="center"> 0.0136 </td>
  </tr>
  <tr>
    <td style="white-space: nowrap;"> Intel(R) Xeon(R) Gold 6348 CPU @ 2.60GHz </td>
    <td align="center"> 0.0086 </td>
    <td align="center"> 0.0127 </td>
  </tr>
  <tr>
    <th align="center"> Windows </th>
    <td> Intel i7-10710U </td>
    <td align="center"> 0.0150 </td>
    <td align="center" rowspan="7" valign="middle"> / </td>
    <td align="center" style="white-space: nowrap;"> 464KB(x86) / 508KB(x64) </td>
  </tr>
  <tr>
    <th align="center"> macOS </th>
    <td> M1 </td>
    <td align="center"> 0.0160 </td>
    <td align="center"> 731KB </td>
  </tr>
  <tr>
    <th align="center"> Web </th>
    <td> macOS(M1) </td>
    <td align="center"> 0.010 </td>
    <td align="center"> 277KB </td>
  </tr>
  <tr>
    <th align="center" rowspan="2"> Android </th>
    <td> Galaxy J6+ (32bit, 425) </td>
    <td align="center"> 0.0570 </td>
    <td align="center" rowspan="2" style="white-space: nowrap;"> 373KB(v7a) / 532KB(v8a)</td>
  </tr>
  <tr>
    <td> Oppo A3s (450) </td>
    <td align="center"> 0.0490 </td>
  </tr>
  <tr>
    <th align="center" rowspan="2"> iOS </th>
    <td> iPhone6 (A8) </td>
    <td align="center"> 0.0210 </td>
    <td align="center" rowspan="2"> 320KB</td>
  </tr>
  <tr>
    <td> iPhone8 (A11) </td>
    <td align="center"> 0.0050 </td>
  </tr> 
</table>
<br>

### **4. Multiple programming languages and platforms:**

TEN VAD provides cross-platform C compatibility across five operating systems (Linux x64, Windows, macOS, Android, iOS), with Python bindings optimized for Linux x64, with wasm for Web.
<br>
<br>

### **5. Supproted sampling rate and hop size:**

TEN VAD operates on 16kHz audio input with configurable hop sizes (optimized frame configurations: 160/256 samples=10/16ms). Other sampling rates must be resampled to 16kHz.
<br>
<br>

## **Installation**

```
git clone https://github.com/TEN-framework/ten-vad.git
```

<br>

## **Quick Start**

The project supports five major platforms with dynamic library linking.

<table>
  <tr>
    <th align="center"> Platform </th>
    <th align="center"> Dynamic Lib </th>
    <th align="center"> Supported Arch </th>
    <th align="center"> Interface Language </th>
    <th align="center"> Header </th>
    <th align="center"> Comment </v>
  </tr>
  <tr>
    <th align="center"> Linux </th>
    <td align="center"> libten_vad.so </td>
    <td align="center"> x64 </td>
    <td align="center"> Python, C </td>
    <td rowspan="6">ten_vad.h <br> ten_vad.py <br> ten_vad.js</td>
    <td>  </td>
  </tr>
  <tr>
    <th align="center"> Windows </th>
    <td align="center"> ten_vad.dll </td>
    <td align="center"> x64, x86 </td>
    <td align="center"> C </td>
    <td>  </td>
  </tr>
  <tr>
    <th align="center"> macOS </th>
    <td align="center"> ten_vad.framework </td>
    <td align="center"> arm64, x86_64 </td>
    <td align="center"> C </td>
    <td>  </td>
  </tr>
  <tr>
    <th align="center"> Web </th>
    <td align="center"> ten_vad.wasm </td>
    <td align="center"> / </td>
    <td align="center"> JS </td>
    <td>  </td>
  </tr>
  <tr>
    <th align="center"> Android </th>
    <td align="center"> libten_vad.so </td>
    <td align="center"> arm64-v8a, armeabi-v7a </td>
    <td align="center"> C </td>
    <td>  </td>
  </tr>
  <tr>
    <th align="center"> iOS </th>
    <td align="center"> ten_vad.framework </td>
    <td align="center"> arm64 </td>
    <td align="center"> C </td>
    <td> 1. not simulator <br> 2. not iPad </td>
  </tr>

</table>
<br>

### **Python Usage**

#### **1. Linux / macOS / Windows**

#### **Requirements**

- numpy (Version 1.17.4/1.26.4 verified)
- scipy (Version >= 1.5.0)
- scikit-learn (Version 1.2.2/1.5.0 verified, for plotting PR curves)
- matplotlib (Version 3.1.3/3.10.0 verified, for plotting PR curves)
- torchaudio (Version 2.2.2 verified, for plotting PR curves)

- Python version 3.8.19/3.10.14 verified

Note: You could use other versions of above packages, but we didn't test other versions.

<br>

The **lib** only depend on numpy, you have to install the dependency via requirements.txt:

`pip install -r requirements.txt`

For **running demo or plotting PR curves**, you have to install the dependencies:

`pip install -r ./examples/requirements.txt`

Note that if you did not install **libc++1** (Linux), you have to run the code below to install it:

```
sudo apt update
sudo apt install libc++1
```

<br>

#### **Usage**

Note: For usage in python, you can either use it by **git clone** or **pip**.

##### **By using git clone:**

1. Clone the repository

```
git clone https://github.com/TEN-framework/ten-vad.git
```

2. Enter examples directory

```
cd ./examples
```

3. Test

```
python test.py s0724-s0730.wav out.txt
```

<br>

##### **By using pip:**

1. Install via pip

```
pip install -U --force-reinstall -v git+https://github.com/TEN-framework/ten-vad.git
```

2. Write your own use cases and import the class, the attributes of class TenVAD you can refer to ten_vad.py

```
from ten_vad import TenVad
```

<br>

### **JS Usage**

#### **1. Web**

##### **Requirements**

- Node.js (macOS v14.18.2, Linux v16.20.2 verified)
- Terminal

##### **Usage**

```
1) cd ./examples
2) node test_node.js s0724-s0730.wav out.txt
```

<br>

### **C Usage**

#### **Build Scripts**

Located in examples/ directory or examples_onnx/ (for **ONNX** usage on Linux):

- Linux: build-and-deploy-linux.sh
- Windows: build-and-deploy-windows.bat
- macOS: build-and-deploy-mac.sh
- Android: build-and-deploy-android.sh
- iOS: build-and-deploy-ios.sh

#### **Dynamic Library Configuration**

Runtime library path configuration:

- Linux/Android: LD_LIBRARY_PATH
- macOS: DYLD_FRAMEWORK_PATH
- Windows: DLL in executable directory or system PATH

#### **Customization**

- Modify platform-specific build scripts
- Adjust CMakeLists.txt
- Configure toolchain and architecture settings

#### **Overview of Usage**

- Navigate to examples/ or examples_onnx/ (for **ONNX** usage on Linux)
- Execute platform-specific build script
- Configure dynamic library path
- Run demo with sample audio s0724-s0730.wav
- Processed results saved to out.txt

<br>

The detailed usage methods of each platform are as follows <br>

#### **1. Linux**

##### **Requirements**

- Clang (e.g. 6.0.0-1ubuntu2 verified)
- CMake
- Terminal

Note that if you did not install **libc++1**, you have to run the code below to install it:

```
sudo apt update
sudo apt install libc++1
```

##### **Usage (prebuilt-lib)**

```
1) cd ./examples
2) ./build-and-deploy-linux.sh
```

##### **Usage (ONNX)**

You have to download the **onnxruntime** packages from the [microsoft official onnxruntime github website](https://github.com/microsoft/onnxruntime). Note that the version of onnxruntime must be higher than or equal to 1.17.1 (e.g. onnxruntime-linux-x64-1.17.1.tgz).
<br>
<br>
You can check the official **ONNX Runtime releases** from [this website](https://github.com/microsoft/onnxruntime/tags). And for example, to download version 1.17.1 (Linux x64), use [this link](https://github.com/microsoft/onnxruntime/releases/download/v1.17.1/onnxruntime-linux-x64-1.17.1.tgz). After extracting the compressed file, you'll find two important directories:`include/` - header files, `lib/` - library files

```
1) cd examples_onnx/
2) ./build-and-deploy-linux.sh --ort-path /absolute/path/to/your/onnxruntime/root/dir
```

**Note 1**: If executing the onnx demo from a different directory than the one used when running build-and-deploy-linux.sh, ensure to create a symbolic link to src/onnx_model/ to prevent ONNX model file loading failures.
<br>
**Note 2**: The **ONNX model** locates in `src/onnx_model` directory.

<br>

#### **2. Windows**

##### **Requirements**

- Visual Studio (2017, 2019, 2022 verified)
- CMake (3.26.0-rc6 verified)
- Terminal (MINGW64 or powershell)

##### **Usage**

```
1) cd ./examples
2) Configure "build-and-deploy-windows.bat" with your preferred:
    - Architecture (default: x64)
    - Visual Studio version (default: 2019)
3) ./build-and-deploy-windows.bat
```

<br>

#### **3. macOS**

##### **Requirements**

- Xcode (15.2 verified)
- CMake (3.19.2 verified)

##### **Usage**

```
1) cd ./examples
2) Configure "build-and-deploy-mac.sh" with your target architecture:
  - Default: arm64 (Apple Silicon)
  - Alternative: x86_64 (Intel)
3) ./build-and-deploy-mac.sh
```

<br>

#### **4. Android**

##### **Requirements**

- NDK (r25b, macOS verified)
- CMake (3.19.2, macOS verified)
- adb (1.0.41, macOS verified)

##### **Usage**

```
1) cd ./examples
2) export ANDROID_NDK=/path/to/android-ndk  # Replace it with your NDK installation path
3) Configure "build-and-deploy-android.sh" with your build settings:
  - Architecture: arm64-v8a (default) or armeabi-v7a
  - Toolchain: aarch64-linux-android-clang (default) or custom NDK toolchain
4) ./build-and-deploy-android.sh
```

<br>

#### **5. iOS**

##### **Requirements**

Xcode (15.2, macOS verified)
CMake (3.19.2, macOS verified)

##### **Usage**

1. Enter examples directory

```
cd ./examples
```

2. Creates Xcode project files for iOS build

```
./build-and-deploy-ios.sh
```

3.  Follow the steps below to build and test on iOS device:

    3.1. Use Xcode to open .xcodeproj files: a) cd ./build-ios, b) open ./ten_vad_demo.xcodeproj

    3.2. In Xcode IDE, select ten_vad_demo target (should check: Edit Scheme → Run → Release), then select your iOS Device (not simulator).

    <div style="text-align:">
      <img src="./examples/images/ios_image_1.jpg" width="800">
    </div>

    3.3. Drag ten_vad/lib/iOS/ten_vad.framework to "Frameworks, Libraries, and Embedded Content"

    - (in TARGETS → ten_vad_demo → ten_vad_demo → General, should set Embed to "Embed & Sign").

    - or add it directly in this way: "Frameworks, Libraries, and Embedded Content" → "+" → Add Other... → Add Files →...

    - Note: If this step is not completed, you may encounter the following runtime error: "dyld: Library not loaded: @rpath/ten_vad.framework/ten_vad".

          <div style="text-align:">
            <img src="./examples/images/ios_image_2.png" width="800">
          </div>

      3.4. Configure iOS device Signature

    - in TARGETS → ten_vad_demo → Signing & Capabilities → Signing

      - Modify Bundle Identifier: modify "com.yourcompany" to yours;

      - Specify Provisioning Profile

    - In TARGETS → ten_vad_demo → Build Settings → Signing → Code Signing Identity:

      - Specify your Certification

        3.5. Build in Xcode and run demo on your device.

<br>

## TEN Ecosystem

| Project | Preview |
|---------|---------|
| [**🏚️ TEN Framework**][ten-framework-link]<br>TEN is an open-source framework for real-time, multimodal conversational AI.<br><br>![][ten-framework-shield] | ![][ten-framework-banner] |
| [**️🔂 TEN Turn Detection**][ten-turn-detection-link]<br>TEN is for full-duplex dialogue communication.<br><br>![][ten-turn-detection-shield] | ![][ten-turn-detection-banner] |
| [**🔉 TEN VAD**][ten-vad-link]<br>TEN VAD is a low-latency, lightweight and high-performance streaming voice activity detector (VAD).<br><br>![][ten-vad-shield] | ![][ten-vad-banner] |
| [**🎙️ TEN Agent**][ten-agent-link]<br>TEN Agent is a showcase of TEN Framewrok.<br><br> | ![][ten-agent-banner] |
| [**🎨 TMAN Designer**][tman-designer-link]<br>TMAN Designer is low/no code option to make a voice agent with easy to use workflow UI.<br><br> | ![][tman-designer-banner] |
| [**📒 TEN Portal**][ten-portal-link]<br>The official site of TEN framework, it has documentation and blog.<br><br>![][ten-portal-shield] | ![][ten-portal-banner] |

<br>

## Ask Questions

TEN VAD is available on these AI-powered Q&A platforms. They can help you find answers quickly and accurately in multiple languages, covering everything from basic setup to advanced implementation details.

| Service | Link |
| ------- | ---- |
| DeepWiki | [![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/TEN-framework/TEN-vad) |
| ReadmeX | [![ReadmeX](https://raw.githubusercontent.com/CodePhiliaX/resource-trusteeship/main/readmex.svg)](https://readmex.com/TEN-framework/ten-vad) |

<br>

## **Citations**

```
@misc{TEN VAD,
  author = {TEN Team},
  title = {TEN VAD: A Low-Latency, Lightweight and High-Performance Streaming Voice Activity Detector (VAD)},
  year = {2025},
  publisher = {GitHub},
  journal = {GitHub repository},
  howpublished = {https://github.com/TEN-framework/ten-vad.git},
  email = {developer@ten.ai}
}
```

<br>

## License

This project is licensed under Apache 2.0 with certain conditions. Refer to the "LICENSE" file in the root directory for detailed information. Note that `pitch_est.cc` contains modified code derived from [LPCNet](https://github.com/xiph/LPCNet), which is [BSD-2-Clause](https://spdx.org/licenses/BSD-2-Clause.html) and [BSD-3-Clause](https://spdx.org/licenses/BSD-3-Clause.html) licensed, refer to the NOTICES file in the root directory for detailed information.

<br>

[back-to-top]: https://img.shields.io/badge/-Back_to_top-gray?style=flat-square
[ten-framework-shield]: https://img.shields.io/github/stars/ten-framework/ten_framework?color=ffcb47&labelColor=gray&style=flat-square&logo=github
[ten-framework-banner]: https://github.com/user-attachments/assets/7c8f72d7-3993-4d01-8504-b71578a22944
[ten-framework-link]: https://github.com/ten-framework/ten_framework
[ten-vad-link]: https://github.com/ten-framework/ten-vad
[ten-vad-shield]: https://img.shields.io/github/stars/ten-framework/ten-vad?color=ffcb47&labelColor=gray&style=flat-square&logo=github
[ten-vad-banner]: https://github.com/user-attachments/assets/d45870e4-9453-4047-8163-08737f82863f
[ten-turn-detection-link]: https://github.com/ten-framework/ten-turn-detection
[ten-turn-detection-shield]: https://img.shields.io/github/stars/ten-framework/ten-turn-detection?color=ffcb47&labelColor=gray&style=flat-square&logo=github
[ten-turn-detection-banner]: https://github.com/user-attachments/assets/8d0ec716-5d0e-43e4-ad9a-d97b17305658
[ten-agent-link]: https://github.com/TEN-framework/ten-framework/tree/main/ai_agents
[ten-agent-banner]: https://github.com/user-attachments/assets/38de2207-939b-4702-a0aa-04491f5b5275
[tman-designer-banner]: https://github.com/user-attachments/assets/804c3543-0a47-42b7-b40b-ef32b742fb8f
[tman-designer-link]: https://github.com/TEN-framework/ten-framework/tree/main/core/src/ten_manager/designer_frontend
[ten-portal-link]: https://github.com/ten-framework/portal
[ten-portal-shield]: https://img.shields.io/github/stars/ten-framework/portal?color=ffcb47&labelColor=gray&style=flat-square&logo=github
[ten-portal-banner]: https://github.com/user-attachments/assets/e17d8aaa-5928-45dd-ac71-814928e26a89



================================================
FILE: LICENSE
================================================
Open Source License

The ten-vad is licensed pursuant to the Apache License v2.0, with the
following additional conditions. You may reproduce, prepare Derivative Works
of, publicly display, publicly perform, sublicense, distribute, or otherwise
make available (together, "Deploy") the ten-vad, for commercial or
non-commercial purposes, provided that you agree to abide by the terms below:

    1. You may not Deploy the ten-vad in a way that competes with Agora's
       offerings and/or that allows others to compete with Agora's offerings,
       including without limitation enabling any third party to develop or
       deploy Applications.
    
    2. You may Deploy the ten-vad solely to create and enable deployment
       of your Application(s) solely for your benefit and the benefit of your
       direct End Users. If you prefer, you may include the following notice in
       the documentation of your Application(s): "Powered by ten-vad".

    3. Derivative Works of the ten-vad remain subject to this Open Source
       License.

    4. "End Users" shall mean the end-users of your Application(s) who access
       the ten-vad solely to the extent necessary to access and use the
       Application(s) you create or deploy using ten-vad.

    5. "Application(s)" shall mean your software programs designed or developed
       by using the ten-vad or where deployment is enabled by the ten-vad.

  Copyright © 2025 Agora

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

=======================================================================================

  Note that the project contains derived code from other open source project
  with BSD-3-Clause and BSD-2-Clause license, refer to the "NOTICES" 
  file in the root directory for detailed information.



================================================
FILE: NOTICES
================================================
This project includes modified code from the following third-party component:

1. File: lpcnet_enc.c
   - Source: LPCNet (https:github.com/xiph/LPCNet)
   - License: BSD-2-Clause
   - Copyright: 2017-2019, Mozilla
   - Original License Text:
        Copyright (c) 2017-2019 Mozilla

        Redistribution and use in source and binary forms, with or without modification,
        are permitted provided that the following conditions are met:

        - Redistributions of source code must retain the above copyright notice, 
          this list of conditions and the following disclaimer.

        - Redistributions in binary form must reproduce the above copyright notice,
          this list of conditions and the following disclaimer in the documentation
          and/or other materials provided with the distribution.

        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
        A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR
        CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
        EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
        PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
        PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
        LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
        NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

2. Project: LPCNet
    - Source: LPCNet (https:github.com/xiph/LPCNet)
    - License: BSD-3-Clause
    - Copyright: 2017-2018, Mozilla, 2007-2017, Jean-Marc Valin, 2005-2017, Xiph.Org Foundation, 2003-2004, Mark Borgerding
    - Original License Text of LPCNet open source project:
        Copyright (c) 2017-2018, Mozilla
        Copyright (c) 2007-2017, Jean-Marc Valin
        Copyright (c) 2005-2017, Xiph.Org Foundation
        Copyright (c) 2003-2004, Mark Borgerding

        Redistribution and use in source and binary forms, with or without
        modification, are permitted provided that the following conditions
        are met:

        - Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

        - Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

        - Neither the name of the Xiph.Org Foundation nor the names of its
        contributors may be used to endorse or promote products derived from
        this software without specific prior written permission.

        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
        A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION
        OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
        LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
        THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
        OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        



================================================
FILE: requirements.txt
================================================
numpy



================================================
FILE: setup.py
================================================
#
#  Copyright © 2025 Agora
#  This file is part of TEN Framework, an open source project.
#  Licensed under the Apache License, Version 2.0, with certain conditions.
#  Refer to the "LICENSE" file in the root directory for more information.
#
from setuptools import setup
import os, shutil, platform
from setuptools.command.install import install

class custom_install_command(install):
    def run(self):
        install.run(self)
        target_dir = os.path.join(self.install_lib, "ten_vad_library")
        os.makedirs(target_dir, exist_ok=True)
        
        if platform.system() == "Linux" and platform.machine() == "x86_64":
            shutil.copy("lib/Linux/x64/libten_vad.so", target_dir)
            print(f"Linux x64 library installed to: {target_dir}")
        elif platform.system() == "Darwin":
            shutil.copy("lib/macOS/ten_vad.framework/Versions/A/ten_vad", 
                       os.path.join(target_dir, "libten_vad"))
            print(f"macOS library installed to: {target_dir}")
        elif platform.system().upper() == 'WINDOWS':
            if platform.machine().upper() in ['X64', 'X86_64', 'AMD64']:
                shutil.copy("lib/Windows/x64/ten_vad.dll", 
                       os.path.join(target_dir, "ten_vad.dll"))
                print(f"Windows x64 library installed to: {target_dir}")
            else:
                shutil.copy("lib/Windows/x86/ten_vad.dll", 
                       os.path.join(target_dir, "ten_vad.dll"))
                print(f"Windows x86 library installed to: {target_dir}")
        else:
            raise NotImplementedError(f"Unsupported platform: {platform.system()} {platform.machine()}")

root_dir = os.path.dirname(os.path.abspath(__file__))
shutil.copy(f"{root_dir}/include/ten_vad.py", f"{root_dir}/ten_vad.py")
setup(
    name="ten_vad",
    version="1.0",
    py_modules=["ten_vad"],
    cmdclass={
        "install": custom_install_command,
    },
)
os.remove(f"{root_dir}/ten_vad.py")


================================================
FILE: examples/build-and-deploy-android.sh
================================================
#!/bin/bash
#
#  Copyright © 2025 Agora
#  This file is part of TEN Framework, an open source project.
#  Licensed under the Apache License, Version 2.0, with certain conditions.
#  Refer to the "LICENSE" file in the root directory for more information.
#
set -eo pipefail

# Customize the arch and toolchain
arch=arm64-v8a
toolchain=aarch64-linux-android-clang

# arch=armeabi-v7a
# toolchain=arm-linux-android-clang

build_dir=build-android/$arch
rm -rf $build_dir
mkdir -p $build_dir
cd $build_dir

# Step 1: Build the demo
cmake ../../ \
  -DANDROID_TOOLCHAIN_NAME=$toolchain \
  -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK/build/cmake/android.toolchain.cmake \
  -G "Unix Makefiles"

cmake --build . --config Release


# Step 2: Run the demo
adb push ../../s0724-s0730.wav /data/local/tmp/
adb push ../../../lib/Android/${arch}/libten_vad.so /data/local/tmp/libten_vad.so &&
  adb push ten_vad_demo /data/local/tmp/ &&
  adb shell "cd /data/local/tmp && chmod +x ten_vad_demo && \
LD_LIBRARY_PATH=/data/local/tmp ./ten_vad_demo ./s0724-s0730.wav ./out.txt && \
exit 0"

adb pull /data/local/tmp/out.txt ./
cd ../../



================================================
FILE: examples/build-and-deploy-ios.sh
================================================
#!/usr/bin/env bash
#
#  Copyright © 2025 Agora
#  This file is part of TEN Framework, an open source project.
#  Licensed under the Apache License, Version 2.0, with certain conditions.
#  Refer to the "LICENSE" file in the root directory for more information.
#
set -euo pipefail

work_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
build_dir="${work_dir}/build-ios"

mkdir -p "${build_dir}"
cd "${build_dir}"

# Step 1: Generate Xcode project for iOS device
echo "[Info] Generating Xcode project"
cmake "${work_dir}" \
  -DCMAKE_SYSTEM_NAME=iOS \
  -DCMAKE_OSX_SYSROOT="iphoneos" \
  -DCMAKE_OSX_ARCHITECTURES="arm64" \
  -DCMAKE_XCODE_ATTRIBUTE_CODE_SIGN_IDENTITY="Apple Development" \
  -DCMAKE_OSX_DEPLOYMENT_TARGET=12.1 \
  -DCMAKE_INSTALL_RPATH="@executable_path/Frameworks" \
  -DCMAKE_BUILD_WITH_INSTALL_RPATH=ON \
  -G Xcode


# Step 2: Use Xcode to open the project in build-ios directory
# Step 3: Build and run the project in Xcode IDE


================================================
FILE: examples/build-and-deploy-linux.sh
================================================
#!/bin/bash
#
#  Copyright © 2025 Agora
#  This file is part of TEN Framework, an open source project.
#  Licensed under the Apache License, Version 2.0, with certain conditions.
#  Refer to the "LICENSE" file in the root directory for more information.
#
set -euo pipefail

arch=x64
build_dir=build-linux/$arch
rm -rf $build_dir
mkdir -p $build_dir
cd $build_dir

# Step 1: Build the demo
cmake ../../
cmake --build . --config Release


# Step 2: Run the demo
export LD_LIBRARY_PATH=../../../lib/Linux/$arch
./ten_vad_demo ../../s0724-s0730.wav out.txt

cd ../../



================================================
FILE: examples/build-and-deploy-mac.sh
================================================
#!/bin/bash
#
#  Copyright © 2025 Agora
#  This file is part of TEN Framework, an open source project.
#  Licensed under the Apache License, Version 2.0, with certain conditions.
#  Refer to the "LICENSE" file in the root directory for more information.
#
set -euo pipefail

# Customize the arch
arch=arm64
# arch=x86_64

build_dir=build-mac/$arch
rm -rf $build_dir
mkdir -p $build_dir
cd $build_dir

# Step 1: Build the demo
cmake ../../ \
  -DCMAKE_CXX_COMPILER=/usr/bin/clang++ \
  -DCMAKE_C_COMPILER=/usr/bin/clang \
  -DCMAKE_OSX_ARCHITECTURES=${arch} \
  -G Xcode

cmake --build . --config Release -- -UseModernBuildSystem=NO


# Step 2: Run the demo
export DYLD_FRAMEWORK_PATH="../../../lib/macOS/"
Release/ten_vad_demo ../../s0724-s0730.wav out.txt
cd ../../


================================================
FILE: examples/build-and-deploy-windows.bat
================================================
@echo off
setlocal

@REM
@REM  Copyright © 2025 Agora
@REM  This file is part of TEN Framework, an open source project.
@REM  Licensed under the Apache License, Version 2.0, with certain conditions.
@REM  Refer to the "LICENSE" file in the root directory for more information.
@REM

@REM Customize the arch
set arch=x64
@REM set arch=x86

@REM step 1: Build the demo
set "build_dir=%~dp0\build-windows"
if exist "%build_dir%" rmdir /s /q "%build_dir%"
mkdir "%build_dir%"
cd /d "%build_dir%"

@REM Customize the Visual Studio version
@REM REM VS 2017
@REM if %arch% == x64 (
@REM   cmake .. -G "Visual Studio 15 2017" -A x64
@REM ) else if %arch% == x86 (
@REM   cmake .. -G "Visual Studio 15 2017" -A Win32
@REM )

REM VS 2019
if %arch% == x64 (
  cmake .. -G "Visual Studio 16 2019" -A x64
) else if %arch% == x86 (
  cmake .. -G "Visual Studio 16 2019" -A Win32
)

@REM REM VS 2022
@REM if %arch% == x64 (
@REM   cmake .. -G "Visual Studio 17 2022" -A x64
@REM ) else if %arch% == x86 (
@REM   cmake .. -G "Visual Studio 17 2022" -A Win32
@REM )

cmake --build . --config Release
cd ..


@REM step 2: Run the demo
pushd "%~dp0"
copy /Y "s0724-s0730.wav" "%build_dir%\Release"
copy /Y "..\lib\Windows\%arch%\ten_vad.dll" "%build_dir%\Release"
if errorlevel 1 (
  echo [Error] copy file failed
  popd
  exit /b 1
)
cd /d "%build_dir%\Release"
if not exist "ten_vad_demo.exe" (
    echo Error: ten_vad_demo.exe not found
    exit /b 1
)
if not exist "s0724-s0730.wav" (
    echo Error: s0724-s0730.wav not found
    exit /b 1
)

ten_vad_demo.exe "s0724-s0730.wav" out.txt
if errorlevel 1 (
    echo Error: ten_vad_demo.exe failed
    exit /b 1
)

cd /d "%~dp0"
popd
exit /b 0



================================================
FILE: examples/CMakeLists.txt
================================================
#
#  Copyright © 2025 Agora
#  This file is part of TEN Framework, an open source project.
#  Licensed under the Apache License, Version 2.0, with certain conditions.
#  Refer to the "LICENSE" file in the root directory for more information.
#
cmake_minimum_required(VERSION 3.10)
get_filename_component(ROOT ${CMAKE_CURRENT_SOURCE_DIR}/../ ABSOLUTE)

project(ten_vad_demo)

add_executable(ten_vad_demo ${ROOT}/examples/main.c)
target_include_directories(ten_vad_demo PRIVATE "${ROOT}/include")

if(WIN32)
  if(CMAKE_SIZEOF_VOID_P EQUAL 8)
    target_link_libraries(ten_vad_demo "${ROOT}/lib/Windows/x64/ten_vad.lib")
  else()
    target_link_libraries(ten_vad_demo "${ROOT}/lib/Windows/x86/ten_vad.lib")
  endif()
elseif(ANDROID)
  if(CMAKE_SYSTEM_PROCESSOR STREQUAL "aarch64")
    target_link_libraries(ten_vad_demo "${ROOT}/lib/Android/arm64-v8a/libten_vad.so")
  else()
    target_link_libraries(ten_vad_demo "${ROOT}/lib/Android/armeabi-v7a/libten_vad.so")
  endif()
elseif(IOS)
  target_link_libraries(ten_vad_demo "${ROOT}/lib/iOS/ten_vad.framework")
  set_target_properties(ten_vad_demo PROPERTIES
    XCODE_ATTRIBUTE_FRAMEWORK_SEARCH_PATHS "${ROOT}/lib/iOS"
    XCODE_ATTRIBUTE_LD_RUNPATH_SEARCH_PATHS "@executable_path/Frameworks"
    XCODE_ATTRIBUTE_CODE_SIGN_STYLE "Manual"
    XCODE_ATTRIBUTE_DEVELOPMENT_TEAM "${CMAKE_XCODE_ATTRIBUTE_DEVELOPMENT_TEAM}"
    XCODE_ATTRIBUTE_PRODUCT_BUNDLE_IDENTIFIER "com.yourcompany.ten_vad_demo"
    XCODE_ATTRIBUTE_SUPPORTED_PLATFORMS "iphoneos"
    XCODE_ATTRIBUTE_ARCHS "arm64"
  )
elseif(APPLE)
  target_link_libraries(ten_vad_demo "${ROOT}/lib/macOS/ten_vad.framework")
  set_target_properties(ten_vad_demo PROPERTIES
    INSTALL_RPATH "@loader_path"
    BUILD_WITH_INSTALL_RPATH TRUE
  )
elseif(UNIX)
  target_link_libraries(ten_vad_demo "${ROOT}/lib/Linux/x64/libten_vad.so")
endif()



================================================
FILE: examples/main.c
================================================
//
// Copyright © 2025 Agora
// This file is part of TEN Framework, an open source project.
// Licensed under the Apache License, Version 2.0, with certain conditions.
// Refer to the "LICENSE" file in the root directory for more information.
//
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <time.h>
#include <inttypes.h>
#include <string.h> // memcmp
#ifdef _WIN32
#include <windows.h>
#endif

#include "ten_vad.h"

#if defined(__APPLE__)
#include <TargetConditionals.h>
#if TARGET_OS_IPHONE
#include "sample_array.h"
#endif
#endif

const int hop_size = 256; // 16 ms per frame

uint64_t get_timestamp_ms()
{
#ifdef _WIN32
  LARGE_INTEGER frequency;
  LARGE_INTEGER counter;
  QueryPerformanceFrequency(&frequency);
  QueryPerformanceCounter(&counter);
  return (uint64_t)(counter.QuadPart * 1000 / frequency.QuadPart);
#else
  struct timespec ts;
  uint64_t millis;
  clock_gettime(CLOCK_MONOTONIC, &ts);
  millis = ts.tv_sec * 1000 + ts.tv_nsec / 1000000;
  return millis;
#endif
}

// define RIFF header
#pragma pack(push, 1)
typedef struct
{
  char chunk_id[4];    // should be "RIFF"
  uint32_t chunk_size; // file total size - 8
  char format[4];      // should be "WAVE"
} riff_header_t;

// define each sub chunk header
typedef struct
{
  char id[4];    // should be "fmt " or "data"
  uint32_t size; // chunk data size
} chunk_header_t;
#pragma pack(pop)

// define WAV file info we care about
typedef struct
{
  uint16_t audio_format;    // audio format (e.g. PCM=1)
  uint16_t num_channels;    // number of channels
  uint32_t sample_rate;     // sample rate
  uint32_t byte_rate;       // byte rate
  uint16_t block_align;     // block align
  uint16_t bits_per_sample; // bits per sample
  uint32_t data_size;       // data size
  long data_offset;         // data offset in file
} wav_info_t;

int read_wav_file(FILE *fp, wav_info_t *info);

int vad_process(int16_t *input_buf, uint32_t frame_num,
                float *out_probs, int32_t *out_flags,
                float *use_time)
{
  printf("tenvadsrc version: %s\n", ten_vad_get_version());
  void *ten_vad_handle = NULL;
  float voice_threshold = 0.5f;
  ten_vad_create(&ten_vad_handle, hop_size, voice_threshold);

  uint64_t start = get_timestamp_ms();
  for (int i = 0; i < frame_num; ++i)
  {
    int16_t *audio_data = input_buf + i * hop_size;
    int res = ten_vad_process(ten_vad_handle, audio_data, hop_size,
                              &out_probs[i], &out_flags[i]);
    if (res == 0)
    {
      printf("[%d] %0.6f, %d\n", i, out_probs[i], out_flags[i]);
    }
    else
    {
      printf("ten_vad_process failed res %d\n", res);
    }
  }
  uint64_t end = get_timestamp_ms();
  *use_time = (float)(end - start);

  ten_vad_destroy(&ten_vad_handle);
  ten_vad_handle = NULL;
  return 0;
}

int test_with_wav(int argc, char *argv[])
{
  if (argc < 3)
  {
    printf("Warning: Test.exe input.wav output.txt\n");
    return 0;
  }
  char *input_file = argv[1];
  char *out_file = argv[2];

  FILE *fp = fopen(input_file, "rb");
  if (fp == NULL)
  {
    printf("Failed to open input file: %s\n", input_file);
    return 1;
  }
  fseek(fp, 0, SEEK_SET);
  wav_info_t info;
  if (read_wav_file(fp, &info) != 0)
  {
    printf("Failed to read WAV file header\n");
    fclose(fp);
    return 1;
  }

  uint32_t byte_num = info.data_size;
  printf("WAV file byte num: %d\n", byte_num);
  char *input_buf = (char *)malloc(byte_num);
  fseek(fp, info.data_offset, SEEK_SET);
  fread(input_buf, 1, byte_num, fp);
  fclose(fp);
  fp = NULL;

  uint32_t sample_num = byte_num / sizeof(int16_t);
  float total_audio_time = (float)sample_num / 16.0;
  printf("total_audio_time: %.2f(ms)\n", total_audio_time);
  uint32_t frame_num = sample_num / hop_size;
  printf("Audio frame Num: %d\n", frame_num);
  float *out_probs = (float *)malloc(frame_num * sizeof(float));
  int32_t *out_flags = (int32_t *)malloc(frame_num * sizeof(int32_t));  // Output flags are binary speech indicators (0 for non-speech signal, 1 for speech signal)
  float use_time = .0;
  vad_process((int16_t *)input_buf, frame_num,
               out_probs, out_flags,
               &use_time);
  float rtf = use_time / total_audio_time;
  printf("Consuming time: %f(ms), audio-time: %.2f(ms), =====> RTF: %0.6f\n",
          use_time, total_audio_time, rtf);

  FILE *fout = fopen(out_file, "w");
  if (fout != NULL)
  {
    for (int i = 0; i < frame_num; i++)
    {
      fprintf(fout, "[%d] %0.6f, %d\n", i, out_probs[i], out_flags[i]);
    }
    fclose(fout);
    fout = NULL;
  }

  free(input_buf);
  free(out_probs);
  free(out_flags);
  return 0;
}

#if TARGET_OS_IPHONE
// Used for iOS APP demo
int test_with_array()
{
  char *input_buf = (char *)sample_array;
  uint32_t byte_num = sizeof(sample_array) / sizeof(sample_array[0]);
  printf("WAV file byte num: %d\n", byte_num);

  uint32_t sample_num = byte_num / sizeof(int16_t);
  float total_audio_time = (float)sample_num / 16.0;
  printf("total_audio_time: %.2f(ms)\n", total_audio_time);
  uint32_t frame_num = sample_num / hop_size;
  printf("Audio frame Num: %d\n", frame_num);
  float *out_probs = (float *)malloc(frame_num * sizeof(float));
  int32_t *out_flags = (int32_t *)malloc(frame_num * sizeof(int32_t));
  float use_time = .0;
  vad_process((int16_t *)input_buf, frame_num,
               out_probs, out_flags,
               &use_time);
  float rtf = use_time / total_audio_time;
  printf("Consuming time: %f(ms), audio-time: %.2f(ms), =====> RTF: %0.6f\n",
          use_time, total_audio_time, rtf);

  return 0;
}
#endif

int main(int argc, char *argv[])
{
#if TARGET_OS_IPHONE
  return test_with_array();
#else
  return test_with_wav(argc, argv);
#endif
}

// function to read WAV file info
int read_wav_file(FILE *fp, wav_info_t *info)
{
  if (fp == NULL || info == NULL)
    return -1;
  // save current file position
  long orig_pos = ftell(fp);
  fseek(fp, 0, SEEK_SET);
  // read RIFF header
  riff_header_t riff;
  if (fread(&riff, sizeof(riff_header_t), 1, fp) != 1)
  {
    fprintf(stderr, "Can not read RIFF head\n");
    fseek(fp, orig_pos, SEEK_SET);
    return -1;
  }
  // verify RIFF/WAVE format
  if (memcmp(riff.chunk_id, "RIFF", 4) != 0 ||
      memcmp(riff.format, "WAVE", 4) != 0)
  {
    fprintf(stderr, "not a valid RIFF/WAVE file\n");
    fseek(fp, orig_pos, SEEK_SET);
    return -1;
  }
  // initialize, mark chunks not found yet
  int fmt_found = 0, data_found = 0;
  memset(info, 0, sizeof(wav_info_t));

  // iterate all chunks
  while (!feof(fp))
  {
    chunk_header_t chunk;
    if (fread(&chunk, sizeof(chunk_header_t), 1, fp) != 1)
    {
      break; // read failed, maybe end of file
    }
    // check if it's fmt chunk
    if (memcmp(chunk.id, "fmt ", 4) == 0)
    {
      // read fmt data
      fmt_found = 1;
      if (chunk.size < 16)
      {
        fprintf(stderr, "fmt chunk size is abnormal\n");
        fseek(fp, orig_pos, SEEK_SET);
        return -1;
      }
      // read fmt parameters
      if (fread(&info->audio_format, 2, 1, fp) != 1 ||
          fread(&info->num_channels, 2, 1, fp) != 1 ||
          fread(&info->sample_rate, 4, 1, fp) != 1 ||
          fread(&info->byte_rate, 4, 1, fp) != 1 ||
          fread(&info->block_align, 2, 1, fp) != 1 ||
          fread(&info->bits_per_sample, 2, 1, fp) != 1)
      {
        fprintf(stderr, "failed to read fmt data\n");
        fseek(fp, orig_pos, SEEK_SET);
        return -1;
      }
      // skip fmt extension data
      if (chunk.size > 16)
      {
        fseek(fp, chunk.size - 16, SEEK_CUR);
      }
    }
    // check if it's data chunk
    else if (memcmp(chunk.id, "data", 4) == 0)
    {
      data_found = 1;
      info->data_size = chunk.size;
      info->data_offset = ftell(fp); // record data start position
      break;                         // found data chunk, can exit loop
    }
    // other chunks, skip
    else
    {
      // consider byte alignment, pad odd size
      fseek(fp, (chunk.size + (chunk.size % 2)), SEEK_CUR);
    }
  }
  // check if necessary chunks are found
  if (!fmt_found)
  {
    fprintf(stderr, "fmt chunk not found\n");
    fseek(fp, orig_pos, SEEK_SET);
    return -1;
  }
  if (!data_found)
  {
    fprintf(stderr, "data chunk not found\n");
    fseek(fp, orig_pos, SEEK_SET);
    return -1;
  }
  // restore original file position
  fseek(fp, orig_pos, SEEK_SET);
  return 0;
}



================================================
FILE: examples/plot_pr_curves.py
================================================
#
#  Copyright © 2025 Agora
#  This file is part of TEN Framework, an open source project.
#  Licensed under the Apache License, Version 2.0, with certain conditions.
#  Refer to the "LICENSE" file in the root directory for more information.
#
import os, glob, sys, torchaudio
import numpy as np
import scipy.io.wavfile as Wavfile
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix

os.system('git clone https://github.com/snakers4/silero-vad.git')  # Clone the silero-vad repo, using Silero V5
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "./silero-vad/src")))
from silero_vad.utils_vad import VADIterator, init_jit_model

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "../include")))
from ten_vad import TenVad

def convert_label_to_framewise(label_file, hop_size):
    frame_duration = hop_size / 16000
    with open(label_file, "r") as f:
        lines = f.readlines()
    content = lines[0].strip().split(",")[1:]
    start = np.array(
        content[::3], dtype=float
    )  # Start point of each audio segment
    end = np.array(
        content[1:][::3], dtype=float
    )  # End point of each audio segment
    lab_manual = np.array(
        content[2:][::3], dtype=int
    )  # label, 0/1 stands for non-speech or speech, respectively
    assert (
        len(start) == len(end) 
        and len(start) == len(lab_manual) 
        and len(end) == len(lab_manual)
    )
    
    num = np.array(
        np.round(((end - start) / frame_duration)), dtype=np.int32
    )  # get number of frames of each audio segment
    label_framewise = np.array([])
    for segment_idx in range(len(num)):
        cur_lab = int(lab_manual[segment_idx])
        num_segment = num[segment_idx]

        if cur_lab == 1:
            vad_result_this_segment = np.ones(num_segment)
        elif cur_lab == 0:
            vad_result_this_segment = np.zeros(num_segment)
        label_framewise = np.append(label_framewise, vad_result_this_segment)
    frame_num = min(
        label_framewise.__len__(), int((end[-1] - start[0]) / frame_duration)
    )
    label_framewise = label_framewise[:frame_num]

    return label_framewise


def read_file(file_path):
    with open(file_path, "r") as f:
        lines = f.readlines()
    lines_arr = np.array([])
    for line in lines:
        lines_arr = np.append(lines_arr, float(line.strip()))

    return lines_arr

def get_precision_recall(VAD_result, label, threshold):
    vad_result_hard = np.where(VAD_result >= threshold, 1, 0)

    # Compute confusion matrix
    TN, FP, FN, TP = confusion_matrix(label, vad_result_hard).ravel()

    # Compute precision, recall, false positive rate and false negative rate
    precision = TP / (TP + FP) if (TP + FP) > 0 else 0
    recall = TP / (TP + FN) if (TP + FN) > 0 else 0
    FPR = FP / (FP + TN) if (FP + TN) > 0 else 0
    FNR = FN / (TP + FN) if (TP + FN) > 0 else 0

    return precision, recall, FPR, FNR

def silero_vad_inference_single_file(wav_path):
    current_directory = os.path.dirname(os.path.abspath(__file__))
    model = init_jit_model(f'{current_directory}/silero-vad/src/silero_vad/data/silero_vad.jit')
    vad_iterator = VADIterator(model)
    window_size_samples = 512
    speech_probs = np.array([])
    
    wav, sr = torchaudio.load(wav_path)
    wav = wav.squeeze(0)
    for i in range(0, len(wav), window_size_samples):
        chunk = wav[i: i+ window_size_samples]
        if len(chunk) < window_size_samples:
            break
        speech_prob = model(chunk, sr).item()
        speech_probs = np.append(speech_probs, speech_prob)
    vad_iterator.reset_states()  # reset model states after each audio
    
    return speech_probs, window_size_samples

def ten_vad_process_wav(ten_vad_instance, wav_path, hop_size=256):
    _, data = Wavfile.read(wav_path)
    num_frames = data.shape[0] // hop_size
    voice_prob_arr = np.array([])
    for i in range(num_frames):
        input_data = data[i * hop_size: (i + 1) * hop_size]
        voice_prob, _ = ten_vad_instance.process(input_data)
        voice_prob_arr = np.append(voice_prob_arr, voice_prob)

    return voice_prob_arr

if __name__ == "__main__":
    # Get the directory of the script
    script_dir = os.path.dirname(os.path.abspath(__file__))

    # TEN-VAD-TestSet dir
    test_dir = f"{script_dir}/../testset"

    # Initialization
    hop_size = 256
    threshold = 0.5
    label_all, vad_result_ten_vad_all = np.array([]), np.array([])
    label_hop_512_all, vad_result_silero_vad_all = np.array([]), np.array([])
    wav_list = glob.glob(f"{test_dir}/*.wav")

    # The WebRTC VAD is from the latest version of WebRTC and is not plotted here
    print("Start processing")
    for wav_path in wav_list:
        # Running TEN VAD
        ten_vad_instance = TenVad(hop_size, threshold)
        label_file = wav_path.replace(".wav", ".scv")
        label = convert_label_to_framewise(
            label_file, hop_size=hop_size
        )  # Convert the VAD label to frame-wise one
        vad_result_ten_vad = ten_vad_process_wav(
            ten_vad_instance, wav_path, hop_size=hop_size
        )
        frame_num = min(label.__len__(), vad_result_ten_vad.__len__())
        vad_result_ten_vad_all = np.append(
            vad_result_ten_vad_all, vad_result_ten_vad[1:frame_num]
        )
        label_all = np.append(label_all, label[:frame_num - 1])
        del ten_vad_instance  # To prevent getting different results of each run

        # Running Silero VAD
        label_hop_512 = convert_label_to_framewise(
            label_file, hop_size=512
        )  # Convert the VAD label to frame-wise one for Silero VAD
        vad_result_silero_vad, _ = silero_vad_inference_single_file(wav_path)
        frame_num_silero_vad = min(label_hop_512.__len__(), vad_result_silero_vad.__len__())
        vad_result_silero_vad_all = np.append(vad_result_silero_vad_all, vad_result_silero_vad[:frame_num_silero_vad])
        label_hop_512_all = np.append(label_hop_512_all, label_hop_512[:frame_num_silero_vad])

    # Compute Precision and Recall  
    threshold_arr = np.arange(0, 1.01, 0.01)
    pr_data_arr = np.zeros((threshold_arr.__len__(), 3))
    pr_data_silero_vad_arr = np.zeros((threshold_arr.__len__(), 3))

    for ind, threshold in enumerate(threshold_arr):
        precision, recall, FPR, FNR = get_precision_recall(vad_result_ten_vad_all, label_all, threshold)
        pr_data_arr[ind] = precision, recall, threshold

        precision_silero_vad, recall_silero_vad, FPR_silero_vad, FNR_silero_vad = get_precision_recall(vad_result_silero_vad_all, label_hop_512_all, threshold)
        pr_data_silero_vad_arr[ind] = precision_silero_vad, recall_silero_vad, threshold

    # Plot PR Curve
    print("Plotting PR Curve")
    pr_data_arr_to_plot = pr_data_arr[:-1] 
    plt.plot(
        pr_data_arr_to_plot[:, 1],
        pr_data_arr_to_plot[:, 0],
        color="red",
        label="TEN VAD",
    )  # Precision on y-axis, Recall on x-axis
    pr_data_silero_vad_arr_to_plot = pr_data_silero_vad_arr[:-1]
    plt.plot(
        pr_data_silero_vad_arr_to_plot[:, 1],  # Recall (x-axis)
        pr_data_silero_vad_arr_to_plot[:, 0],  # Precision (y-axis)
        color="blue",
        label="Silero VAD",
    )

    plt.xlabel("Recall", fontsize=14, fontweight="bold", color="black")
    plt.ylabel("Precision", fontsize=14, fontweight="bold", color="black") 
    legend = plt.legend()
    legend.get_texts()[0].set_fontweight("bold")
    legend.get_texts()[1].set_fontweight("bold")
    plt.grid(True)
    plt.xlim(0.65, 1)
    plt.ylim(0.7, 1)
    plt.title(
        "Precision-Recall Curve of TEN VAD on TEN-VAD-TestSet",
        fontsize=12,
        color="black",
        fontweight="bold",
    )
    save_path = f"{script_dir}/PR_Curves.png"
    plt.savefig(save_path, dpi=300, bbox_inches="tight")
    print(f"PR Curves png file saved, save path: {save_path}")

    # Save the PR data to txt file
    pr_data_save_path = f"{script_dir}/PR_data_TEN_VAD.txt"
    with open(pr_data_save_path, "w") as f:
        for ind in range(pr_data_arr.shape[0]):
            precision, recall, threshold = (
                pr_data_arr[ind, 0],
                pr_data_arr[ind, 1],
                pr_data_arr[ind, 2],
            )
            f.write(f"{threshold:.2f} {precision:.4f} {recall:.4f}\n")
    print("Processing done!")





================================================
FILE: examples/requirements.txt
================================================
scipy>=1.5.0
scikit-learn
matplotlib
torchaudio



================================================
FILE: examples/test.py
================================================
#
#  Copyright © 2025 Agora
#  This file is part of TEN Framework, an open source project.
#  Licensed under the Apache License, Version 2.0, with certain conditions.
#  Refer to the "LICENSE" file in the root directory for more information.
#
import sys, os

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "../include")))
from ten_vad import TenVad
import scipy.io.wavfile as Wavfile


if __name__ == "__main__":
    input_file, out_path = sys.argv[1], sys.argv[2]
    sr, data = Wavfile.read(input_file)
    hop_size = 256  # 16 ms per frame
    threshold = 0.5
    ten_vad_instance = TenVad(hop_size, threshold)  # Create a TenVad instance
    num_frames = data.shape[0] // hop_size
    # Streaming inference
    with open(out_path, "w") as f:
        for i in range(num_frames):
            audio_data = data[i * hop_size: (i + 1) * hop_size]
            out_probability, out_flag = ten_vad_instance.process(audio_data) #  Out_flag is speech indicator (0 for non-speech signal, 1 for speech signal)
            print("[%d] %0.6f, %d" % (i, out_probability, out_flag))
            f.write("[%d] %0.6f, %d\n" % (i, out_probability, out_flag))



================================================
FILE: examples/test_node.js
================================================
#!/usr/bin/env node

//
// Copyright © 2025 Agora
// This file is part of TEN Framework, an open source project.
// Licensed under the Apache License, Version 2.0, with certain conditions.
// Refer to the "LICENSE" file in the root directory for more information.
//

/**
 * TEN VAD WebAssembly Node.js Test
 * Simplified and clean version based on main.c
 */

const fs = require('fs');
const path = require('path');

// Configuration
const HOP_SIZE = 256;          // 16ms per frame
const VOICE_THRESHOLD = 0.5;   // Voice detection threshold

// WASM module paths
const WASM_DIR = './../lib/Web';
const WASM_JS_FILE = path.join(WASM_DIR, 'ten_vad.js');
const WASM_BINARY_FILE = path.join(WASM_DIR, 'ten_vad.wasm');

// Global state
let vadModule = null;
let vadHandle = null;
let vadHandlePtr = null;

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

function getTimestamp() {
    return Date.now();
}

function addHelperFunctions() {
    if (!vadModule.getValue) {
        vadModule.getValue = function(ptr, type) {
            switch (type) {
                case 'i32': return vadModule.HEAP32[ptr >> 2];
                case 'float': return vadModule.HEAPF32[ptr >> 2];
                default: throw new Error(`Unsupported type: ${type}`);
            }
        };
    }
    
    if (!vadModule.UTF8ToString) {
        vadModule.UTF8ToString = function(ptr) {
            if (!ptr) return '';
            let result = '';
            let i = ptr;
            while (vadModule.HEAPU8[i]) {
                result += String.fromCharCode(vadModule.HEAPU8[i++]);
            }
            return result;
        };
    }
}

// ============================================================================
// AUDIO GENERATION
// ============================================================================

function generateTestAudio(durationMs = 5000) {
    const sampleRate = 16000;
    const totalSamples = Math.floor(durationMs * sampleRate / 1000);
    const audioData = new Int16Array(totalSamples);
    
    console.log(`Generating ${totalSamples} samples for ${durationMs}ms audio...`);
    
    for (let i = 0; i < totalSamples; i++) {
        const t = i / sampleRate;
        let sample = 0;
        
        if (t < 2.0) {
            // Voice frequencies (440Hz + 880Hz)
            sample = Math.sin(2 * Math.PI * 440 * t) * 8000 +
                    Math.sin(2 * Math.PI * 880 * t) * 4000;
        } else if (t < 3.0) {
            // Noise
            sample = (Math.random() - 0.5) * 3000;
        } else if (t < 4.0) {
            // Mixed voice (220Hz + 660Hz)
            sample = Math.sin(2 * Math.PI * 220 * t) * 6000 + 
                    Math.sin(2 * Math.PI * 660 * t) * 3000;
        } else {
            // Silence with minimal noise
            sample = Math.random() * 50;
        }
        
        audioData[i] = Math.max(-32768, Math.min(32767, Math.floor(sample)));
    }
    
    return audioData;
}

// ============================================================================
// VAD OPERATIONS
// ============================================================================

function getVADVersion() {
    if (!vadModule) return "unknown";
    try {
        const versionPtr = vadModule._ten_vad_get_version();
        return vadModule.UTF8ToString(versionPtr);
    } catch (error) {
        return "unknown";
    }
}

function createVADInstance() {
    try {
        vadHandlePtr = vadModule._malloc(4);
        const result = vadModule._ten_vad_create(vadHandlePtr, HOP_SIZE, VOICE_THRESHOLD);
        
        if (result === 0) {
            vadHandle = vadModule.getValue(vadHandlePtr, 'i32');
            return true;
        } else {
            console.error(`VAD creation failed with code: ${result}`);
            vadModule._free(vadHandlePtr);
            return false;
        }
    } catch (error) {
        console.error(`Error creating VAD instance: ${error.message}`);
        return false;
    }
}

function destroyVADInstance() {
    if (vadHandlePtr && vadModule) {
        vadModule._ten_vad_destroy(vadHandlePtr);
        vadModule._free(vadHandlePtr);
        vadHandlePtr = null;
        vadHandle = null;
    }
}

async function processAudio(inputBuf, frameNum, outProbs, outFlags) {
    console.log(`VAD version: ${getVADVersion()}`);
    
    if (!createVADInstance()) {
        return -1;
    }
    
    const startTime = getTimestamp();
    
    for (let i = 0; i < frameNum; i++) {
        const frameStart = i * HOP_SIZE;
        const frameData = inputBuf.slice(frameStart, frameStart + HOP_SIZE);
        
        const audioPtr = vadModule._malloc(HOP_SIZE * 2);
        const probPtr = vadModule._malloc(4);
        const flagPtr = vadModule._malloc(4);
        
        try {
            vadModule.HEAP16.set(frameData, audioPtr / 2);
            
            const result = vadModule._ten_vad_process(
                vadHandle, audioPtr, HOP_SIZE, probPtr, flagPtr
            );
            
            if (result === 0) {
                const probability = vadModule.getValue(probPtr, 'float');
                const flag = vadModule.getValue(flagPtr, 'i32');
                
                outProbs[i] = probability;
                outFlags[i] = flag;
                
                console.log(`[${i}] ${probability.toFixed(6)}, ${flag}`);
            } else {
                console.error(`Frame ${i} processing failed with code: ${result}`);
                outProbs[i] = 0.0;
                outFlags[i] = 0;
            }
        } finally {
            vadModule._free(audioPtr);
            vadModule._free(probPtr);
            vadModule._free(flagPtr);
        }
    }
    
    const endTime = getTimestamp();
    const processingTime = endTime - startTime;
    
    destroyVADInstance();
    return processingTime;
}

// ============================================================================
// RESULT HANDLING
// ============================================================================

function printResults(processingTime, totalAudioTime, outFlags, frameNum) {
    const rtf = processingTime / totalAudioTime;
    const voiceFrames = outFlags.filter(flag => flag === 1).length;
    const voicePercentage = (voiceFrames / frameNum * 100).toFixed(1);
    
    console.log(`\n=== Processing Results ===`);
    console.log(`Time: ${processingTime}ms, Audio: ${totalAudioTime.toFixed(2)}ms, RTF: ${rtf.toFixed(6)}`);
    console.log(`Voice frames: ${voiceFrames}/${frameNum} (${voicePercentage}%)`);
}

function saveResults(outProbs, outFlags, frameNum, filename = 'out.txt') {
    let output = '';
    for (let i = 0; i < frameNum; i++) {
        output += `[${i}] ${outProbs[i].toFixed(6)}, ${outFlags[i]}\n`;
    }
    
    try {
        fs.writeFileSync(filename, output);
        console.log(`Results saved to ${filename}`);
    } catch (error) {
        console.error(`Failed to save results: ${error.message}`);
    }
}

// ============================================================================
// TEST FUNCTIONS
// ============================================================================

async function testWithArray() {
    console.log("=== Array Test ===\n");
    
    const inputBuf = generateTestAudio(5000);
    const byteNum = inputBuf.byteLength;
    const sampleNum = byteNum / 2;
    const totalAudioTime = sampleNum / 16.0;
    const frameNum = Math.floor(sampleNum / HOP_SIZE);
    
    console.log(`Audio info: ${byteNum} bytes, ${frameNum} frames, ${totalAudioTime.toFixed(2)}ms`);
    
    const outProbs = new Float32Array(frameNum);
    const outFlags = new Int32Array(frameNum);
    
    const processingTime = await processAudio(inputBuf, frameNum, outProbs, outFlags);
    
    if (processingTime > 0) {
        printResults(processingTime, totalAudioTime, outFlags, frameNum);
    }
    
    return 0;
}

// WAV File parsing utilities
function parseWAVHeader(buffer) {
    if (buffer.length < 44) {
        throw new Error('Invalid WAV file: too small');
    }
    
    // Check RIFF header
    const riffHeader = buffer.toString('ascii', 0, 4);
    if (riffHeader !== 'RIFF') {
        throw new Error('Invalid WAV file: missing RIFF header');
    }
    
    // Check WAVE format
    const waveHeader = buffer.toString('ascii', 8, 12);
    if (waveHeader !== 'WAVE') {
        throw new Error('Invalid WAV file: not WAVE format');
    }
    
    let offset = 12;
    let dataOffset = -1;
    let dataSize = 0;
    let sampleRate = 0;
    let channels = 0;
    let bitsPerSample = 0;
    
    // Parse chunks
    while (offset < buffer.length - 8) {
        const chunkId = buffer.toString('ascii', offset, offset + 4);
        const chunkSize = buffer.readUInt32LE(offset + 4);
        
        if (chunkId === 'fmt ') {
            // Format chunk
            const audioFormat = buffer.readUInt16LE(offset + 8);
            channels = buffer.readUInt16LE(offset + 10);
            sampleRate = buffer.readUInt32LE(offset + 12);
            bitsPerSample = buffer.readUInt16LE(offset + 22);
            
            if (audioFormat !== 1) {
                throw new Error('Unsupported WAV format: only PCM is supported');
            }
            
            if (bitsPerSample !== 16) {
                throw new Error('Unsupported bit depth: only 16-bit is supported');
            }
        } else if (chunkId === 'data') {
            // Data chunk
            dataOffset = offset + 8;
            dataSize = chunkSize;
            break;
        }
        
        offset += 8 + chunkSize;
        // Align to even byte boundary
        if (chunkSize % 2 === 1) {
            offset++;
        }
    }
    
    if (dataOffset === -1) {
        throw new Error('Invalid WAV file: no data chunk found');
    }
    
    return {
        sampleRate,
        channels,
        bitsPerSample,
        dataOffset,
        dataSize,
        totalSamples: dataSize / (bitsPerSample / 8),
        samplesPerChannel: dataSize / (bitsPerSample / 8) / channels
    };
}

async function testWithWAV(inputFile, outputFile) {
    console.log("=== WAV File Test ===\n");
    
    if (!fs.existsSync(inputFile)) {
        console.error(`Input file not found: ${inputFile}`);
        return 1;
    }
    
    try {
        const buffer = fs.readFileSync(inputFile);
        
        // Parse WAV header properly
        const wavInfo = parseWAVHeader(buffer);
        console.log(`WAV Format: ${wavInfo.channels} channel(s), ${wavInfo.sampleRate}Hz, ${wavInfo.bitsPerSample}-bit`);
        console.log(`Total samples: ${wavInfo.totalSamples}, samples per channel: ${wavInfo.samplesPerChannel}`);
        
        // Validate format requirements
        if (wavInfo.sampleRate !== 16000) {
            console.warn(`Warning: Sample rate is ${wavInfo.sampleRate}Hz, expected 16000Hz`);
        }
        
        if (wavInfo.channels !== 1) {
            console.warn(`Warning: ${wavInfo.channels} channels detected, only first channel will be used`);
        }
        
        // Extract audio data
        const audioBuffer = buffer.slice(wavInfo.dataOffset, wavInfo.dataOffset + wavInfo.dataSize);
        const inputBuf = new Int16Array(audioBuffer.buffer.slice(audioBuffer.byteOffset));
        
        // Calculate correct sample number (for mono audio)
        const sampleNum = wavInfo.channels === 1 ? 
            wavInfo.samplesPerChannel : 
            Math.floor(wavInfo.samplesPerChannel); // Use only first channel if stereo
            
        const totalAudioTime = sampleNum / wavInfo.sampleRate * 1000; // in milliseconds
        const frameNum = Math.floor(sampleNum / HOP_SIZE);
        
        console.log(`Audio info: ${audioBuffer.length} bytes, ${sampleNum} samples, ${frameNum} frames, ${totalAudioTime.toFixed(2)}ms`);
        
        // If stereo, extract only the first channel
        let processedInput = inputBuf;
        if (wavInfo.channels > 1) {
            console.log(`Extracting mono from ${wavInfo.channels} channels...`);
            processedInput = new Int16Array(Math.floor(inputBuf.length / wavInfo.channels));
            for (let i = 0; i < processedInput.length; i++) {
                processedInput[i] = inputBuf[i * wavInfo.channels]; // Take first channel
            }
        }
        
        const outProbs = new Float32Array(frameNum);
        const outFlags = new Int32Array(frameNum);
        
        const processingTime = await processAudio(processedInput, frameNum, outProbs, outFlags);
        
        if (processingTime > 0) {
            printResults(processingTime, totalAudioTime, outFlags, frameNum);
            saveResults(outProbs, outFlags, frameNum, outputFile);
        }
        
        return 0;
    } catch (error) {
        console.error(`Error processing WAV file: ${error.message}`);
        return 1;
    }
}

async function runBenchmark() {
    console.log("=== Performance Benchmark ===\n");
    
    if (!createVADInstance()) return;
    
    const testData = new Int16Array(HOP_SIZE);
    for (let i = 0; i < HOP_SIZE; i++) {
        testData[i] = Math.sin(2 * Math.PI * 440 * i / 16000) * 8000;
    }
    
    const testCases = [100, 1000, 10000];
    
    for (const numFrames of testCases) {
        const audioPtr = vadModule._malloc(HOP_SIZE * 2);
        const probPtr = vadModule._malloc(4);
        const flagPtr = vadModule._malloc(4);
        
        vadModule.HEAP16.set(testData, audioPtr / 2);
        
        const startTime = getTimestamp();
        
        for (let i = 0; i < numFrames; i++) {
            vadModule._ten_vad_process(vadHandle, audioPtr, HOP_SIZE, probPtr, flagPtr);
        }
        
        const endTime = getTimestamp();
        const totalTime = endTime - startTime;
        const avgTime = totalTime / numFrames;
        
        // Calculate RTF (Real-time Factor)
        // Each frame represents 16ms of audio (HOP_SIZE=256 samples at 16kHz)
        const frameAudioTime = (HOP_SIZE / 16000) * 1000; // 16ms
        const totalAudioTime = numFrames * frameAudioTime;
        const rtf = totalTime / totalAudioTime;
        
        console.log(`${numFrames} frames: ${totalTime}ms total, ${avgTime.toFixed(3)}ms/frame, RTF: ${rtf.toFixed(3)}`);
        
        vadModule._free(audioPtr);
        vadModule._free(probPtr);
        vadModule._free(flagPtr);
    }
    
    destroyVADInstance();
}

// ============================================================================
// MODULE INITIALIZATION
// ============================================================================

async function loadModule() {
    try {
        console.log("Loading WebAssembly module...");
        
        if (!fs.existsSync(WASM_JS_FILE)) {
            throw new Error(`ten_vad.js not found at ${WASM_JS_FILE}`);
        }
        
        if (!fs.existsSync(WASM_BINARY_FILE)) {
            throw new Error(`ten_vad.wasm not found at ${WASM_BINARY_FILE}`);
        }
        
        // Read and modify the module file for Node.js compatibility
        const wasmJsContent = fs.readFileSync(WASM_JS_FILE, 'utf8');
        const modifiedContent = wasmJsContent
            .replace(/import\.meta\.url/g, `"${path.resolve(WASM_JS_FILE)}"`)
            .replace(/export default createVADModule;/, 'module.exports = createVADModule;');
        
        // Write temporary file
        const tempPath = './ten_vad_temp.js';
        fs.writeFileSync(tempPath, modifiedContent);
        
        // Load WASM binary
        const wasmBinary = fs.readFileSync(WASM_BINARY_FILE);
        
        // Load module
        const createVADModule = require(path.resolve(tempPath));
        vadModule = await createVADModule({
            wasmBinary: wasmBinary,
            locateFile: (filePath) => filePath.endsWith('.wasm') ? WASM_BINARY_FILE : filePath,
            noInitialRun: false,
            noExitRuntime: true
        });
        
        // Cleanup
        fs.unlinkSync(tempPath);
        
        // Add missing helper functions
        addHelperFunctions();
        
        console.log(`Module loaded successfully. Version: ${getVADVersion()}\n`);
        return true;
        
    } catch (error) {
        console.error(`Failed to load module: ${error.message}`);
        return false;
    }
}

// ============================================================================
// MAIN FUNCTION
// ============================================================================

async function main() {
    const args = process.argv.slice(2);
    
    // Initialize module
    if (!await loadModule()) {
        process.exit(1);
    }
    
    try {
        if (args.length >= 2) {
            // Test with WAV file
            const [inputFile, outputFile] = args;
            console.log(`Input: ${inputFile}, Output: ${outputFile}\n`);
            await testWithWAV(inputFile, outputFile);
        } else {
            // Test with generated array
            await testWithArray();
        }
        await runBenchmark();
        return 0;
    } catch (error) {
        console.error(`Test failed: ${error.message}`);
        return 1;
    }
}

// ============================================================================
// EXECUTION
// ============================================================================

if (require.main === module) {
    main().then(exitCode => {
        process.exit(exitCode);
    }).catch(error => {
        console.error(`Fatal error: ${error.message}`);
        process.exit(1);
    });
}

module.exports = { main, testWithArray, testWithWAV, runBenchmark }; 


================================================
FILE: examples_onnx/build-and-deploy-linux.sh
================================================
#!/bin/bash
#
#  Copyright © 2025 Agora
#  This file is part of TEN Framework, an open source project.
#  Licensed under the Apache License, Version 2.0, with certain conditions.
#  Refer to the "LICENSE" file in the root directory for more information.
#
set -euo pipefail

if [[ "$#" -lt 2 || "$1" != "--ort-path" ]]; then
    echo "usage: $0 --ort-path <path_to_onnxruntime>" >&2
    exit 1
fi

ORT_ROOT="$2"
shift 2

if [[ ! -d "$ORT_ROOT" || ! -d "$ORT_ROOT/lib" || ! -d "$ORT_ROOT/include" ]]; then
    echo "invalid onnxruntime library path: $ORT_ROOT" >&2
    exit 1
fi

arch=x64
build_dir=build-linux/$arch
rm -rf $build_dir
mkdir -p $build_dir
cd $build_dir

# Step 1: Build the demo
cmake ../../ -DORT_ROOT="$ORT_ROOT"
cmake --build . --config Release

# Step 2: Run the demo
ln -s ../../../src/onnx_model/
./ten_vad_demo ../../../examples/s0724-s0730.wav out.txt

cd ../../



================================================
FILE: examples_onnx/CMakeLists.txt
================================================
#
#  Copyright © 2025 Agora
#  This file is part of TEN Framework, an open source project.
#  Licensed under the Apache License, Version 2.0, with certain conditions.
#  Refer to the "LICENSE" file in the root directory for more information.
#
cmake_minimum_required(VERSION 3.10)
get_filename_component(ROOT ${CMAKE_CURRENT_SOURCE_DIR}/../ ABSOLUTE)

project(ten_vad)

set(CMAKE_BUILD_TYPE Release)
add_compile_options(-Wno-write-strings -Wno-unused-result)
include_directories(${ROOT}/src)
include_directories(${ROOT}/include)
include_directories(${ORT_ROOT}/include)
file(GLOB LIBRARY_SOURCES "${ROOT}/src/*.cc" "${ROOT}/src/*.c")
add_library(ten_vad SHARED ${LIBRARY_SOURCES})
link_directories(${ORT_ROOT}/lib)
target_link_libraries(ten_vad "${ORT_ROOT}/lib/libonnxruntime.so")

set(EXECUTABLE_SOURCES ${ROOT}/examples/main.c)
add_executable(ten_vad_demo ${EXECUTABLE_SOURCES})
target_link_libraries(ten_vad_demo ten_vad)



================================================
FILE: include/ten_vad.h
================================================
//
// Copyright © 2025 Agora
// This file is part of TEN Framework, an open source project.
// Licensed under the Apache License, Version 2.0, with certain conditions.
// Refer to the "LICENSE" file in the root directory for more information.
//
#ifndef TEN_VAD_H
#define TEN_VAD_H

#if defined(__APPLE__) || defined(__ANDROID__) || defined(__linux__)
#define TENVAD_API __attribute__((visibility("default")))
#elif defined(_WIN32) || defined(__CYGWIN__)
#ifdef TENVAD_EXPORTS
#define TENVAD_API __declspec(dllexport)
#else
#define TENVAD_API __declspec(dllimport)
#endif
#else
#define TENVAD_API
#endif

#include <stddef.h> /* size_t */
#include <stdint.h> /* int16_t */

#ifdef __cplusplus
extern "C"
{
#endif

  /**
   * @typedef ten_vad_handle
   * @brief Opaque handle for ten_vad instance.
   */
  typedef void *ten_vad_handle_t;

  /**
   * @brief Create and initialize a ten_vad instance.
   *
   * @param[out] handle       Pointer to receive the vad handle.
   * @param[in]  hop_size     The number of samples between the start points of
   * two consecutive analysis frames. (e.g., 256).
   * @param[in]  threshold    VAD detection threshold ranging from [0.0, 1.0]
   * This threshold is used to determine voice activity by comparing with the output probability.
   * When probability >= threshold, voice is detected.
   * @return 0 on success, or -1 error occurs.
   */
  TENVAD_API int ten_vad_create(ten_vad_handle_t *handle, size_t hop_size,
                                float threshold);

  /**
   * @brief Process one audio frame for voice activity detection.
   * Must call ten_vad_init() before calling this, and ten_vad_destroy() when done.
   *
   * @param[in]  handle           Valid VAD handle returned by ten_vad_create().
   * @param[in]  audio_data       Pointer to an array of int16_t samples,
   * buffer length must equal the hop size specified at ten_vad_create.
   * @param[in]  audio_data_length  size of audio_data buffer, here should be equal to hop_size.
   * @param[out] out_probability  Pointer to a float (size 1) that receives the
   * voice activity probability in the range [0.0, 1.0], where higher values indicate higher confidence in voice presence.
   * @param[out] out_flag         Pointer to an int (size 1) that receives the
   * binary voice activity decision: 0: no voice, 1: voice detected.
   * This flag is set to 1 when out_probability >= threshold, and 0 otherwise.
   * @return 0 on success, or -1 error occurs.
   */
  TENVAD_API int ten_vad_process(ten_vad_handle_t handle, const int16_t *audio_data, size_t audio_data_length,
                                 float *out_probability, int *out_flag);

  /**
   * @brief Destroy a ten_vad instance and release its resources.
   *
   * @param[in,out] handle Pointer to the ten_vad handle; set to NULL on return.
   * @return 0 on success, or -1 error occurs.
   */
  TENVAD_API int ten_vad_destroy(ten_vad_handle_t *handle);

  /**
   * @brief Get the ten_vad library version string.
   *
   * @return The version string (e.g., "1.0.0").
   */
  TENVAD_API const char *ten_vad_get_version(void);

#ifdef __cplusplus
}
#endif

#endif /* TEN_VAD_H */



================================================
FILE: include/ten_vad.py
================================================
#
#  Copyright © 2025 Agora
#  This file is part of TEN Framework, an open source project.
#  Licensed under the Apache License, Version 2.0, with certain conditions.
#  Refer to the "LICENSE" file in the root directory for more information.
#
from ctypes import c_int, c_int32, c_float, c_size_t, CDLL, c_void_p, POINTER
import numpy as np
import os
import platform

class TenVad:
    def __init__(self, hop_size: int = 256, threshold: float = 0.5):
        self.hop_size = hop_size
        self.threshold = threshold
        if platform.system() == "Linux" and platform.machine() == "x86_64":
            git_path = os.path.join(
                os.path.dirname(os.path.relpath(__file__)),
                "../lib/Linux/x64/libten_vad.so"
            )
            if os.path.exists(git_path):
                self.vad_library = CDLL(git_path)
            else:
                pip_path = os.path.join(
                    os.path.dirname(os.path.relpath(__file__)),
                    "./ten_vad_library/libten_vad.so"
                )
                self.vad_library = CDLL(pip_path)
                
        elif platform.system() == "Darwin":
            git_path = os.path.join(
                os.path.dirname(os.path.relpath(__file__)),
                "../lib/macOS/ten_vad.framework/Versions/A/ten_vad"
            )
            if os.path.exists(git_path):
                self.vad_library = CDLL(git_path)
            else:
                pip_path = os.path.join(
                    os.path.dirname(os.path.relpath(__file__)),
                    "./ten_vad_library/libten_vad"
                )
                self.vad_library = CDLL(pip_path)
        elif platform.system().upper() == 'WINDOWS':
            if platform.machine().upper() in ['X64', 'X86_64', 'AMD64']:
                git_path = os.path.join(
                    os.path.dirname(os.path.realpath(__file__)),
                    "../lib/Windows/x64/ten_vad.dll"
                )
                if os.path.exists(git_path):
                    self.vad_library = CDLL(git_path)
                else:
                    pip_path = os.path.join(
                        os.path.dirname(os.path.realpath(__file__)),
                        "./ten_vad_library/ten_vad.dll"
                    )
                    self.vad_library = CDLL(pip_path)
            else:
                git_path = os.path.join(
                    os.path.dirname(os.path.realpath(__file__)),
                    "../lib/Windows/x86/ten_vad.dll"
                )
                if os.path.exists(git_path):
                    self.vad_library = CDLL(git_path)
                else:
                    pip_path = os.path.join(
                        os.path.dirname(os.path.realpath(__file__)),
                        "./ten_vad_library/ten_vad.dll"
                    )
                    self.vad_library = CDLL(pip_path)
        else:
            raise NotImplementedError(f"Unsupported platform: {platform.system()} {platform.machine()}")
        self.vad_handler = c_void_p(0)
        self.out_probability = c_float()
        self.out_flags = c_int32()

        self.vad_library.ten_vad_create.argtypes = [
            POINTER(c_void_p),
            c_size_t,
            c_float,
        ]
        self.vad_library.ten_vad_create.restype = c_int

        self.vad_library.ten_vad_destroy.argtypes = [POINTER(c_void_p)]
        self.vad_library.ten_vad_destroy.restype = c_int

        self.vad_library.ten_vad_process.argtypes = [
            c_void_p,
            c_void_p,
            c_size_t,
            POINTER(c_float),
            POINTER(c_int32),
        ]
        self.vad_library.ten_vad_process.restype = c_int
        self.create_and_init_handler()
    
    def create_and_init_handler(self):
        assert (
            self.vad_library.ten_vad_create(
                POINTER(c_void_p)(self.vad_handler),
                c_size_t(self.hop_size),
                c_float(self.threshold),
            ) 
            == 0
        ), "[TEN VAD]: create handler failure!"

    def __del__(self):
        assert (
            self.vad_library.ten_vad_destroy(
                POINTER(c_void_p)(self.vad_handler)
            )
            == 0
        ), "[TEN VAD]: destroy handler failure!"
    
    def get_input_data(self, audio_data: np.ndarray):
        audio_data = np.squeeze(audio_data)
        assert (
            len(audio_data.shape) == 1 
            and audio_data.shape[0] == self.hop_size
        ), "[TEN VAD]: audio data shape should be [%d]" % (
            self.hop_size
        )
        assert (
            type(audio_data[0]) == np.int16
        ), "[TEN VAD]: audio data type error, must be int16"
        data_pointer = audio_data.__array_interface__["data"][0]
        return c_void_p(data_pointer)
    
    def process(self, audio_data: np.ndarray):
        input_pointer = self.get_input_data(audio_data)
        self.vad_library.ten_vad_process(
            self.vad_handler,
            input_pointer,
            c_size_t(self.hop_size),
            POINTER(c_float)(self.out_probability),
            POINTER(c_int32)(self.out_flags),
        )
        return self.out_probability.value, self.out_flags.value





================================================
FILE: lib/iOS/ten_vad.framework/Info.plist
================================================
[Binary file]


================================================
FILE: lib/iOS/ten_vad.framework/Headers/ten_vad.h
================================================
/*
 * @file ten_vad.h
 * @brief Ten Voice Activity Detection (ten_vad) C API
 * Version: 1.0.0
 *
 * Provides functions to create, process, and destroy a VAD instance.
 */
#ifndef TEN_VAD_H
#define TEN_VAD_H

#if defined(__APPLE__) || defined(__ANDROID__) || defined(__linux__)
#define TENVAD_API __attribute__((visibility("default")))
#elif defined(_WIN32) || defined(__CYGWIN__)
/**
 * @def TENVAD_API
 * @brief Export/import macro for ten_vad shared library symbols.
 */
#ifdef TENVAD_EXPORTS
#define TENVAD_API __declspec(dllexport)
#else
#define TENVAD_API __declspec(dllimport)
#endif
#else
#define TENVAD_API
#endif

#include <stddef.h> /* size_t */
#include <stdint.h> /* int16_t */

#ifdef __cplusplus
extern "C"
{
#endif

  /**
   * @typedef ten_vad_handle
   * @brief Opaque handle for ten_vad instance.
   */
  typedef void *ten_vad_handle_t;

  /**
   * @brief Create and initialize a ten_vad instance.
   *
   * @param[out] handle       Pointer to receive the vad handle.
   * @param[in]  hop_size     The number of samples between the start points of
   * two consecutive analysis frames. (e.g., 256).
   * @param[in]  threshold    VAD detection threshold ranging from [0.0, 1.0]
   * (default: 0.5).
   * @return 0 on success, or -1 error occurs.
   */
  TENVAD_API int ten_vad_create(ten_vad_handle_t *handle, size_t hop_size,
                                float threshold);

  /**
   * @brief Process one audio frame for voice activity detection.
   * Must call ten_vad_init() before calling this, and ten_vad_destroy() when done.
   *
   * @param[in]  handle           Valid VAD handle returned by ten_vad_create().
   * @param[in]  audio_data       Pointer to an array of int16_t samples,
   * buffer length must equal the hop size specified at ten_vad_create.
   * @param[in]  audio_data_length  size of audio_data buffer, here should be equal to hop_size.
   * @param[out] out_probability  Pointer to a float (size 1) that receives the
   * voice activity probability in the range [0.0, 1.0].
   * @param[out] out_flag         Pointer to an int (size 1) that receives the
   * detection result: 0 = no voice, 1 = voice detected.
   * @return 0 on success, or -1 error occurs.
   */
  TENVAD_API int ten_vad_process(ten_vad_handle_t handle, const int16_t *audio_data, size_t audio_data_length,
                                 float *out_probability, int *out_flag);

  /**
   * @brief Destroy a ten_vad instance and release its resources.
   *
   * @param[in,out] handle Pointer to the ten_vad handle; set to NULL on return.
   * @return 0 on success, or -1 error occurs.
   */
  TENVAD_API int ten_vad_destroy(ten_vad_handle_t *handle);

  /**
   * @brief Get the ten_vad library version string.
   *
   * @return The version string (e.g., "1.0.0").
   */
  TENVAD_API const char *ten_vad_get_version(void);

#ifdef __cplusplus
}
#endif

#endif /* TEN_VAD_H */


================================================
FILE: lib/iOS/ten_vad.framework/Modules/module.modulemap
================================================
framework module ten_vad {
        umbrella header "ten_vad.h"
        export *
        module * { export * }
    }


================================================
SYMLINK: lib/macOS/ten_vad.framework/Headers -> Headers
================================================



================================================
SYMLINK: lib/macOS/ten_vad.framework/Resources -> Resources
================================================



================================================
SYMLINK: lib/macOS/ten_vad.framework/ten_vad -> ten_vad
================================================



================================================
FILE: lib/macOS/ten_vad.framework/Versions/A/Headers/ten_vad.h
================================================
/*
 * @file ten_vad.h
 * @brief Ten Voice Activity Detection (ten_vad) C API
 * Version: 1.0.0
 *
 * Provides functions to create, process, and destroy a VAD instance.
 */
#ifndef TEN_VAD_H
#define TEN_VAD_H

#if defined(__APPLE__) || defined(__ANDROID__) || defined(__linux__)
#define TENVAD_API __attribute__((visibility("default")))
#elif defined(_WIN32) || defined(__CYGWIN__)
/**
 * @def TENVAD_API
 * @brief Export/import macro for ten_vad shared library symbols.
 */
#ifdef TENVAD_EXPORTS
#define TENVAD_API __declspec(dllexport)
#else
#define TENVAD_API __declspec(dllimport)
#endif
#else
#define TENVAD_API
#endif

#include <stddef.h> /* size_t */
#include <stdint.h> /* int16_t */

#ifdef __cplusplus
extern "C"
{
#endif

  /**
   * @typedef ten_vad_handle
   * @brief Opaque handle for ten_vad instance.
   */
  typedef void *ten_vad_handle_t;

  /**
   * @brief Create and initialize a ten_vad instance.
   *
   * @param[out] handle       Pointer to receive the vad handle.
   * @param[in]  hop_size     The number of samples between the start points of
   * two consecutive analysis frames. (e.g., 256).
   * @param[in]  threshold    VAD detection threshold ranging from [0.0, 1.0]
   * (default: 0.5).
   * @return 0 on success, or -1 error occurs.
   */
  TENVAD_API int ten_vad_create(ten_vad_handle_t *handle, size_t hop_size,
                                float threshold);

  /**
   * @brief Process one audio frame for voice activity detection.
   * Must call ten_vad_init() before calling this, and ten_vad_destroy() when done.
   *
   * @param[in]  handle           Valid VAD handle returned by ten_vad_create().
   * @param[in]  audio_data       Pointer to an array of int16_t samples,
   * buffer length must equal the hop size specified at ten_vad_create.
   * @param[in]  audio_data_length  size of audio_data buffer, here should be equal to hop_size.
   * @param[out] out_probability  Pointer to a float (size 1) that receives the
   * voice activity probability in the range [0.0, 1.0].
   * @param[out] out_flag         Pointer to an int (size 1) that receives the
   * detection result: 0 = no voice, 1 = voice detected.
   * @return 0 on success, or -1 error occurs.
   */
  TENVAD_API int ten_vad_process(ten_vad_handle_t handle, const int16_t *audio_data, size_t audio_data_length,
                                 float *out_probability, int *out_flag);

  /**
   * @brief Destroy a ten_vad instance and release its resources.
   *
   * @param[in,out] handle Pointer to the ten_vad handle; set to NULL on return.
   * @return 0 on success, or -1 error occurs.
   */
  TENVAD_API int ten_vad_destroy(ten_vad_handle_t *handle);

  /**
   * @brief Get the ten_vad library version string.
   *
   * @return The version string (e.g., "1.0.0").
   */
  TENVAD_API const char *ten_vad_get_version(void);

#ifdef __cplusplus
}
#endif

#endif /* TEN_VAD_H */


================================================
FILE: lib/macOS/ten_vad.framework/Versions/A/Resources/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>BuildMachineOSBuild</key>
	<string>23D60</string>
	<key>CFBundleDevelopmentRegion</key>
	<string>English</string>
	<key>CFBundleExecutable</key>
	<string>ten_vad</string>
	<key>CFBundleIdentifier</key>
	<string>com.yourcompany.ten_vad</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundlePackageType</key>
	<string>FMWK</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleSupportedPlatforms</key>
	<array>
		<string>MacOSX</string>
	</array>
	<key>CSResourcesFileMapped</key>
	<true/>
	<key>DTCompiler</key>
	<string>com.apple.compilers.llvm.clang.1_0</string>
	<key>DTPlatformBuild</key>
	<string></string>
	<key>DTPlatformName</key>
	<string>macosx</string>
	<key>DTPlatformVersion</key>
	<string>14.2</string>
	<key>DTSDKBuild</key>
	<string>23C53</string>
	<key>DTSDKName</key>
	<string>macosx14.2</string>
	<key>DTXcode</key>
	<string>1520</string>
	<key>DTXcodeBuild</key>
	<string>15C500b</string>
	<key>LSMinimumSystemVersion</key>
	<string>10.10</string>
</dict>
</plist>



================================================
SYMLINK: lib/macOS/ten_vad.framework/Versions/Current -> A
================================================



================================================
FILE: lib/Web/ten_vad.d.ts
================================================
/**
 * This file is part of TEN Framework, an open source project.
 * Licensed under the Apache License, Version 2.0.
 * See the LICENSE file for more information.
 * 
 * TEN VAD (Voice Activity Detection) WebAssembly Module
 * TypeScript type definitions
 */

export interface TenVADModule {
  /**
   * Create and initialize a VAD instance
   * @param handlePtr Pointer to store the VAD handle
   * @param hopSize Number of samples between consecutive analysis frames (e.g., 256)
   * @param threshold VAD detection threshold [0.0, 1.0]
   * @returns 0 on success, -1 on error
   */
  _ten_vad_create(handlePtr: number, hopSize: number, threshold: number): number;

  /**
   * Process audio frame for voice activity detection
   * @param handle Valid VAD handle from ten_vad_create
   * @param audioDataPtr Pointer to int16 audio samples array
   * @param audioDataLength Length of audio data (should equal hopSize)
   * @param outProbabilityPtr Pointer to output probability [0.0, 1.0]
   * @param outFlagPtr Pointer to output flag (0: no voice, 1: voice detected)
   * @returns 0 on success, -1 on error
   */
  _ten_vad_process(
    handle: number,
    audioDataPtr: number,
    audioDataLength: number,
    outProbabilityPtr: number,
    outFlagPtr: number
  ): number;

  /**
   * Destroy VAD instance and release resources
   * @param handlePtr Pointer to the VAD handle
   * @returns 0 on success, -1 on error
   */
  _ten_vad_destroy(handlePtr: number): number;

  /**
   * Get library version string
   * @returns Version string pointer
   */
  _ten_vad_get_version(): number;

  // WebAssembly Memory Management
  _malloc(size: number): number;
  _free(ptr: number): void;

  // Memory access helpers
  HEAP16: Int16Array;
  HEAPF32: Float32Array;
  HEAP32: Int32Array;
  HEAPU8: Uint8Array;

  // Value access methods
  getValue(ptr: number, type: 'i8' | 'i16' | 'i32' | 'float' | 'double'): number;
  setValue(ptr: number, value: number, type: 'i8' | 'i16' | 'i32' | 'float' | 'double'): void;

  // String utilities
  UTF8ToString(ptr: number): string;
  lengthBytesUTF8(str: string): number;
  stringToUTF8(str: string, outPtr: number, maxBytesToWrite: number): void;
}

/**
 * High-level TypeScript wrapper for TEN VAD
 */
export class TenVAD {
  private module: TenVADModule;
  private handle: number | null;
  private hopSize: number;

  constructor(module: TenVADModule, hopSize: number, threshold: number);

  /**
   * Process audio samples for voice activity detection
   * @param audioData Int16Array of audio samples (length must equal hopSize)
   * @returns Object with probability and voice detection flag
   */
  process(audioData: Int16Array): {
    probability: number;
    isVoice: boolean;
  } | null;

  /**
   * Get library version
   */
  getVersion(): string;

  /**
   * Destroy VAD instance
   */
  destroy(): void;

  /**
   * Check if VAD instance is valid
   */
  isValid(): boolean;
}

/**
 * Create TEN VAD WebAssembly module
 */
declare function createVADModule(): Promise<TenVADModule>;

export default createVADModule; 


================================================
FILE: lib/Web/ten_vad.js
================================================

var createVADModule = (() => {
  var _scriptDir = import.meta.url;
  
  return (
function(createVADModule) {
  createVADModule = createVADModule || {};


var a;a||(a=typeof createVADModule !== 'undefined' ? createVADModule : {});var k,l;a.ready=new Promise(function(b,c){k=b;l=c});var p=Object.assign({},a),r="object"==typeof window,u="function"==typeof importScripts,v="",w;
if(r||u)u?v=self.location.href:"undefined"!=typeof document&&document.currentScript&&(v=document.currentScript.src),_scriptDir&&(v=_scriptDir),0!==v.indexOf("blob:")?v=v.substr(0,v.replace(/[?#].*/,"").lastIndexOf("/")+1):v="",u&&(w=b=>{var c=new XMLHttpRequest;c.open("GET",b,!1);c.responseType="arraybuffer";c.send(null);return new Uint8Array(c.response)});var aa=a.print||console.log.bind(console),x=a.printErr||console.warn.bind(console);Object.assign(a,p);p=null;var y;a.wasmBinary&&(y=a.wasmBinary);
var noExitRuntime=a.noExitRuntime||!0;"object"!=typeof WebAssembly&&z("no native wasm support detected");var A,B=!1,C="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,D,E,F;function J(){var b=A.buffer;D=b;a.HEAP8=new Int8Array(b);a.HEAP16=new Int16Array(b);a.HEAP32=new Int32Array(b);a.HEAPU8=E=new Uint8Array(b);a.HEAPU16=new Uint16Array(b);a.HEAPU32=F=new Uint32Array(b);a.HEAPF32=new Float32Array(b);a.HEAPF64=new Float64Array(b)}var K=[],L=[],M=[];
function ba(){var b=a.preRun.shift();K.unshift(b)}var N=0,O=null,P=null;function z(b){if(a.onAbort)a.onAbort(b);b="Aborted("+b+")";x(b);B=!0;b=new WebAssembly.RuntimeError(b+". Build with -sASSERTIONS for more info.");l(b);throw b;}function Q(){return R.startsWith("data:application/octet-stream;base64,")}var R;if(a.locateFile){if(R="ten_vad.wasm",!Q()){var S=R;R=a.locateFile?a.locateFile(S,v):v+S}}else R=(new URL("ten_vad.wasm",import.meta.url)).href;
function T(){var b=R;try{if(b==R&&y)return new Uint8Array(y);if(w)return w(b);throw"both async and sync fetching of the wasm failed";}catch(c){z(c)}}function ca(){return y||!r&&!u||"function"!=typeof fetch?Promise.resolve().then(function(){return T()}):fetch(R,{credentials:"same-origin"}).then(function(b){if(!b.ok)throw"failed to load wasm binary file at '"+R+"'";return b.arrayBuffer()}).catch(function(){return T()})}function U(b){for(;0<b.length;)b.shift()(a)}
var da=[null,[],[]],ea={a:function(){z("")},f:function(b,c,m){E.copyWithin(b,c,c+m)},c:function(b){var c=E.length;b>>>=0;if(2147483648<b)return!1;for(var m=1;4>=m;m*=2){var h=c*(1+.2/m);h=Math.min(h,b+100663296);var d=Math;h=Math.max(b,h);d=d.min.call(d,2147483648,h+(65536-h%65536)%65536);a:{try{A.grow(d-D.byteLength+65535>>>16);J();var e=1;break a}catch(W){}e=void 0}if(e)return!0}return!1},e:function(){return 52},b:function(){return 70},d:function(b,c,m,h){for(var d=0,e=0;e<m;e++){var W=F[c>>2],
X=F[c+4>>2];c+=8;for(var G=0;G<X;G++){var f=E[W+G],H=da[b];if(0===f||10===f){f=H;for(var n=0,q=n+NaN,t=n;f[t]&&!(t>=q);)++t;if(16<t-n&&f.buffer&&C)f=C.decode(f.subarray(n,t));else{for(q="";n<t;){var g=f[n++];if(g&128){var I=f[n++]&63;if(192==(g&224))q+=String.fromCharCode((g&31)<<6|I);else{var Y=f[n++]&63;g=224==(g&240)?(g&15)<<12|I<<6|Y:(g&7)<<18|I<<12|Y<<6|f[n++]&63;65536>g?q+=String.fromCharCode(g):(g-=65536,q+=String.fromCharCode(55296|g>>10,56320|g&1023))}}else q+=String.fromCharCode(g)}f=q}(1===
b?aa:x)(f);H.length=0}else H.push(f)}d+=X}F[h>>2]=d;return 0}};
(function(){function b(d){a.asm=d.exports;A=a.asm.g;J();L.unshift(a.asm.h);N--;a.monitorRunDependencies&&a.monitorRunDependencies(N);0==N&&(null!==O&&(clearInterval(O),O=null),P&&(d=P,P=null,d()))}function c(d){b(d.instance)}function m(d){return ca().then(function(e){return WebAssembly.instantiate(e,h)}).then(function(e){return e}).then(d,function(e){x("failed to asynchronously prepare wasm: "+e);z(e)})}var h={a:ea};N++;a.monitorRunDependencies&&a.monitorRunDependencies(N);if(a.instantiateWasm)try{return a.instantiateWasm(h,
b)}catch(d){x("Module.instantiateWasm callback failed with error: "+d),l(d)}(function(){return y||"function"!=typeof WebAssembly.instantiateStreaming||Q()||"function"!=typeof fetch?m(c):fetch(R,{credentials:"same-origin"}).then(function(d){return WebAssembly.instantiateStreaming(d,h).then(c,function(e){x("wasm streaming compile failed: "+e);x("falling back to ArrayBuffer instantiation");return m(c)})})})().catch(l);return{}})();
a.___wasm_call_ctors=function(){return(a.___wasm_call_ctors=a.asm.h).apply(null,arguments)};a._malloc=function(){return(a._malloc=a.asm.i).apply(null,arguments)};a._free=function(){return(a._free=a.asm.j).apply(null,arguments)};a._ten_vad_create=function(){return(a._ten_vad_create=a.asm.k).apply(null,arguments)};a._ten_vad_process=function(){return(a._ten_vad_process=a.asm.l).apply(null,arguments)};a._ten_vad_destroy=function(){return(a._ten_vad_destroy=a.asm.m).apply(null,arguments)};
a._ten_vad_get_version=function(){return(a._ten_vad_get_version=a.asm.n).apply(null,arguments)};var V;P=function fa(){V||Z();V||(P=fa)};
function Z(){function b(){if(!V&&(V=!0,a.calledRun=!0,!B)){U(L);k(a);if(a.onRuntimeInitialized)a.onRuntimeInitialized();if(a.postRun)for("function"==typeof a.postRun&&(a.postRun=[a.postRun]);a.postRun.length;){var c=a.postRun.shift();M.unshift(c)}U(M)}}if(!(0<N)){if(a.preRun)for("function"==typeof a.preRun&&(a.preRun=[a.preRun]);a.preRun.length;)ba();U(K);0<N||(a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1);b()},1)):b())}}
if(a.preInit)for("function"==typeof a.preInit&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();Z();


  return createVADModule.ready
}
);
})();
export default createVADModule;


================================================
FILE: src/aed.cc
================================================
//
// Copyright © 2025 Agora
// This file is part of TEN Framework, an open source project.
// Licensed under the Apache License, Version 2.0, with certain conditions.
// Refer to the "LICENSE" file in the root directory for more information.
//
#include <string.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>
#include "aed.h"
#include "aed_st.h"
#include "coeff.h"
#include "pitch_est.h"
#include "stft.h"
#include <assert.h>

#define AUP_AED_ALIGN8(o) (((o) + 7) & (~7))
#define AUP_AED_MAX(x, y) (((x) > (y)) ? (x) : (y))
#define AUP_AED_MIN(x, y) (((x) > (y)) ? (y) : (x))
#define AUP_AED_EPS (1e-20f)

/// ///////////////////////////////////////////////////////////////////////
/// Internal Utils
/// ///////////////////////////////////////////////////////////////////////

AUP_MODULE_AIVAD::AUP_MODULE_AIVAD(char* onnx_path) {
  ort_api = OrtGetApiBase()->GetApi(ORT_API_VERSION);
  OrtStatus* status =
      ort_api->CreateEnv(ORT_LOGGING_LEVEL_WARNING, "TEN-VAD", &ort_env);
  if (status) {
    printf("Failed to create env: %s\n", ort_api->GetErrorMessage(status));
    ort_api->ReleaseStatus(status);
    ort_api->ReleaseEnv(ort_env);
    ort_env = NULL;
    return;
  }

  OrtSessionOptions* session_options;
  ort_api->CreateSessionOptions(&session_options);
  ort_api->SetIntraOpNumThreads(session_options, 1);
  status =
      ort_api->CreateSession(ort_env, onnx_path, session_options, &ort_session);
  ort_api->ReleaseSessionOptions(session_options);
  if (status) {
    printf("Failed to create ort_session: %s\n",
           ort_api->GetErrorMessage(status));
    ort_api->ReleaseStatus(status);
    ort_api->ReleaseEnv(ort_env);
    ort_env = NULL;
    return;
  }

  ort_api->GetAllocatorWithDefaultOptions(&ort_allocator);
  size_t num_inputs;
  ort_api->SessionGetInputCount(ort_session, &num_inputs);
  assert(num_inputs == AUP_AED_MODEL_IO_NUM);
  for (size_t i = 0; i < num_inputs; i++) {
    char* input_name;
    ort_api->SessionGetInputName(ort_session, i, ort_allocator, &input_name);
    strncpy(input_names_buf[i], input_name, sizeof(input_names_buf[i]));
    input_names[i] = input_names_buf[i];
    ort_api->AllocatorFree(ort_allocator, input_name);
  }

  size_t num_outputs;
  ort_api->SessionGetOutputCount(ort_session, &num_outputs);
  assert(num_outputs == AUP_AED_MODEL_IO_NUM);
  for (size_t i = 0; i < num_outputs; i++) {
    char* output_name;
    ort_api->SessionGetOutputName(ort_session, i, ort_allocator, &output_name);
    strncpy(output_names_buf[i], output_name, sizeof(output_names_buf[i]));
    output_names[i] = output_names_buf[i];
    ort_api->AllocatorFree(ort_allocator, output_name);
  }

  OrtMemoryInfo* memory_info;
  status = ort_api->CreateCpuMemoryInfo(OrtDeviceAllocator, OrtMemTypeDefault,
                                        &memory_info);
  if (status != NULL) {
    printf("Failed to create memory info: %s\n",
           ort_api->GetErrorMessage(status));
    ort_api->ReleaseStatus(status);
    ort_api->ReleaseSession(ort_session);
    ort_api->ReleaseEnv(ort_env);
    ort_session = NULL;
    ort_env = NULL;
    return;
  }
  int64_t input_shapes0[] = {1, AUP_AED_CONTEXT_WINDOW_LEN, AUP_AED_FEA_LEN};
  int64_t input_shapes1234[] = {1, AUP_AED_MODEL_HIDDEN_DIM};
  for (int i = 0; i < num_inputs; i++) {
    status = ort_api->CreateTensorWithDataAsOrtValue(
        memory_info, i == 0 ? input_data_buf_0 : input_data_buf_1234[i - 1],
        i == 0 ? sizeof(input_data_buf_0) : sizeof(input_data_buf_1234[i - 1]),
        i == 0 ? input_shapes0 : input_shapes1234,
        i == 0 ? sizeof(input_shapes0) / sizeof(input_shapes0[0])
               : sizeof(input_shapes1234) / sizeof(input_shapes1234[0]),
        ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT, &ort_input_tensors[i]);
    if (status != NULL) {
      printf("Failed to create input tensor %d: %s\n", i,
             ort_api->GetErrorMessage(status));
      ort_api->ReleaseStatus(status);
      ort_api->ReleaseSession(ort_session);
      ort_api->ReleaseEnv(ort_env);
      ort_session = NULL;
      ort_env = NULL;
      return;
    }
  }

  int64_t output_shapes0[] = {1, 1, 1};
  int64_t output_shapes1234[] = {1, AUP_AED_MODEL_HIDDEN_DIM};
  for (int i = 0; i < num_outputs; i++) {
    status = ort_api->CreateTensorAsOrtValue(
        ort_allocator, i == 0 ? output_shapes0 : output_shapes1234,
        i == 0 ? sizeof(output_shapes0) / sizeof(output_shapes0[0])
               : sizeof(output_shapes1234) / sizeof(output_shapes1234[0]),
        ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT, &ort_output_tensors[i]);
    if (status != NULL) {
      printf("Failed to create output tensor %d: %s\n", i,
             ort_api->GetErrorMessage(status));
      ort_api->ReleaseStatus(status);
      ort_api->ReleaseSession(ort_session);
      ort_api->ReleaseEnv(ort_env);
      ort_session = NULL;
      ort_env = NULL;
      return;
    }
  }
  inited = 1;
}

AUP_MODULE_AIVAD::~AUP_MODULE_AIVAD() {
  for (int i = 0; i < AUP_AED_MODEL_IO_NUM; i++) {
    if (ort_output_tensors[i]) {
      ort_api->ReleaseValue(ort_output_tensors[i]);
    }
  }
  if (ort_session) {
    ort_api->ReleaseSession(ort_session);
  }
  if (ort_env) {
    ort_api->ReleaseEnv(ort_env);
  }
}

int AUP_MODULE_AIVAD::Process(float* input, float* output) {
  if (!inited) {
    printf("not inited!\n");
    return -1;
  }

  memcpy(input_data_buf_0, input, sizeof(input_data_buf_0));
  if (clear_hidden) {
    memset(input_data_buf_1234, 0, sizeof(input_data_buf_1234));
    clear_hidden = 0;
  }
  OrtStatus* status = ort_api->Run(
      ort_session, NULL, input_names, ort_input_tensors, AUP_AED_MODEL_IO_NUM,
      output_names, AUP_AED_MODEL_IO_NUM, ort_output_tensors);
  float* output_data;
  ort_api->GetTensorMutableData(ort_output_tensors[0], (void**)&output_data);
  *output = output_data[0];
  for (int i = 1; i < AUP_AED_MODEL_IO_NUM; i++) {
    ort_api->GetTensorMutableData(ort_output_tensors[i], (void**)&output_data);
    memcpy(input_data_buf_1234[i - 1], output_data,
           sizeof(input_data_buf_1234[i - 1]));
  }

  return 0;
}

int AUP_MODULE_AIVAD::Reset() {
  if (!inited) {
    return -1;
  }

  clear_hidden = 1;
  return 0;
}

static int AUP_Aed_checkStatCfg(Aed_StaticCfg* pCfg) {
  if (pCfg == NULL) {
    return -1;
  }

#if AUP_AED_FEA_LEN < AUP_AED_MEL_FILTER_BANK_NUM
  return -1;
#endif

  if (pCfg->hopSz < 32) {
    return -1;
  }

  if (pCfg->frqInputAvailableFlag == 1) {
    if (pCfg->fftSz < 128 || pCfg->fftSz < pCfg->hopSz) {
      return -1;
    }
    if (pCfg->anaWindowSz > pCfg->fftSz || pCfg->anaWindowSz < pCfg->hopSz) {
      return -1;
    }
  }

  return 0;
}

static int AUP_Aed_publishStaticCfg(Aed_St* stHdl) {
  const Aed_StaticCfg* pStatCfg;

  if (stHdl == NULL) {
    return -1;
  }
  pStatCfg = (const Aed_StaticCfg*)(&(stHdl->stCfg));

  stHdl->extFftSz = 0;
  stHdl->extNBins = 0;
  stHdl->extWinSz = 0;
  if (pStatCfg->frqInputAvailableFlag == 1) {
    stHdl->extFftSz = pStatCfg->fftSz;
    stHdl->extNBins = (stHdl->extFftSz >> 1) + 1;
    stHdl->extWinSz = pStatCfg->anaWindowSz;
  }
  stHdl->extHopSz = pStatCfg->hopSz;

  stHdl->intFftSz = AUP_AED_ASSUMED_FFTSZ;
  stHdl->intHopSz = AUP_AED_ASSUMED_HOPSZ;
  stHdl->intWinSz = AUP_AED_ASSUMED_WINDOWSZ;
  stHdl->intNBins = (stHdl->intFftSz >> 1) + 1;
  stHdl->intAnalyWindowPtr = AUP_AED_STFTWindow_Hann768;

  if (pStatCfg->frqInputAvailableFlag == 0 ||
      stHdl->extHopSz != stHdl->intHopSz) {
    // external STFT analysis framework is not supported at all
    stHdl->intAnalyFlag =
        2;  // internally redo analysis based on input time signal
  } else if (stHdl->extFftSz == stHdl->intFftSz) {
    // external STFT analysis framework completely match with internal
    // requirement
    stHdl->intAnalyFlag = 0;  // directly use external spectrum
  } else {  // external spectrum need to be interpolated or extrapolated before
            // AIVAD
    stHdl->intAnalyFlag =
        1;  // use external spectrum with interpolation / exterpolation
  }
  stHdl->inputTimeFIFOLen = stHdl->extHopSz + stHdl->intHopSz;

  // for aiaed release2.0.0, pre-emphasis for input time-signal is needed,
  // therefore, we need redo analysis based on input time signal preprocessed by
  // pre-emphasis.
  stHdl->intAnalyFlag =
      2;  // internally redo analysis based on input time signal

  stHdl->feaSz = (size_t)AUP_AED_FEA_LEN;
  stHdl->melFbSz = (size_t)AUP_AED_MEL_FILTER_BANK_NUM;
  stHdl->algDelay = (size_t)AUP_AED_LOOKAHEAD_NFRM;
  stHdl->algCtxtSz = (size_t)AUP_AED_CONTEXT_WINDOW_LEN;
  stHdl->frmRmsBufLen = AUP_AED_MAX(1, stHdl->algDelay);

  return 0;
}

static int AUP_Aed_publishDynamCfg(Aed_St* stHdl) {
  const Aed_DynamCfg* pDynmCfg;
  PE_DynamCfg peDynmCfg;
  if (stHdl == NULL) {
    return -1;
  }

  pDynmCfg = (const Aed_DynamCfg*)(&(stHdl->dynamCfg));
  stHdl->aivadResetFrmNum = pDynmCfg->resetFrameNum;
  stHdl->voiceDecideThresh = pDynmCfg->extVoiceThr;

  if (stHdl->pitchEstStPtr != NULL) {
    peDynmCfg.voicedThr = pDynmCfg->pitchEstVoicedThr;
    AUP_PE_setDynamCfg(stHdl->pitchEstStPtr, &peDynmCfg);
  }

  return 0;
}

static int AUP_Aed_resetVariables(Aed_St* stHdl) {
  if (stHdl == NULL) {
    return -1;
  }

  // first clear all the dynamic memory, all the dynamic variables which are
  // not listed bellow are cleared to 0 by this step
  memset(stHdl->dynamMemPtr, 0, stHdl->dynamMemSize);

  float* melFbCoef = stHdl->melFilterBankCoef;
  size_t* melBinBuff = stHdl->melFilterBinBuff;
  size_t i, j;
  size_t nBins = stHdl->intNBins;
  size_t melFbSz = stHdl->melFbSz;

  stHdl->aedProcFrmCnt = 0;
  stHdl->inputTimeFIFOIdx = 0;
  stHdl->aivadResetCnt = 0;
  stHdl->timeSignalPre = 0.0f;
  stHdl->aivadScore =
      -1.0f;  // as default value, labeling as aed is not working yet
  stHdl->aivadScorePre = -1.0f;

  stHdl->pitchFreq = 0.0f;

  // generate mel filter-bank coefficients
  float low_mel = 2595.0f * log10f(1.0f + 0.0f / 700.0f);
  float high_mel = 2595.0f * log10f(1.0f + 8000.0f / 700.0f);
  float mel_points = 0.0f;
  float hz_points = 0.0f;
  size_t idx = 0;

  for (i = 0; i < melFbSz + 2; i++) {
    mel_points = i * (high_mel - low_mel) / ((float)melFbSz + 1.0f) + low_mel;
    hz_points = 700.0f * (powf(10.0f, mel_points / 2595.0f) - 1.0f);
    melBinBuff[i] =
        (size_t)((stHdl->intFftSz + 1.0f) * hz_points / (float)AUP_AED_FS);
    if (i > 0 && melBinBuff[i] == melBinBuff[i - 1]) {
      return -1;
    }
  }

  for (j = 0; j < melFbSz; j++) {
    for (i = melBinBuff[j]; i < melBinBuff[j + 1]; i++) {
      idx = j * nBins + i;
      melFbCoef[idx] = (float)(i - melBinBuff[j]) /
                       (float)(melBinBuff[j + 1] - melBinBuff[j]);
    }
    for (i = melBinBuff[j + 1]; i < melBinBuff[j + 2]; i++) {
      idx = j * nBins + i;
      melFbCoef[idx] = (float)(melBinBuff[j + 2] - i) /
                       (float)(melBinBuff[j + 2] - melBinBuff[j + 1]);
    }
  }

  if (stHdl->pitchEstStPtr != NULL) {
    if (AUP_PE_init(stHdl->pitchEstStPtr) < 0) {
      return -1;
    }
  }

  if (stHdl->aivadInf != NULL) {
    stHdl->aivadInf->Reset();
  }

  if (stHdl->timeInAnalysis != NULL) {
    if (AUP_Analyzer_init(stHdl->timeInAnalysis) < 0) {
      return -1;
    }
  }

  return 0;
}

static int AUP_Aed_addOneCnter(int cnter) {
  cnter++;
  if (cnter >= 1000000000) {
    cnter = 0;  // reset every half year
  }
  return (cnter);
}

static void AUP_Aed_binPowerConvert(const float* src, float* tgt, int srcNBins,
                                    int tgtNBins) {
  float rate;
  int srcIdx, tgtIdx;
  if (srcNBins == tgtNBins) {
    memcpy(tgt, src, sizeof(float) * tgtNBins);
    return;
  }

  memset(tgt, 0, sizeof(float) * tgtNBins);

  rate = (float)(srcNBins - 1) / (float)(tgtNBins - 1);
  for (tgtIdx = 0; tgtIdx < tgtNBins; tgtIdx++) {
    srcIdx = (int)(tgtIdx * rate);
    srcIdx = AUP_AED_MIN(srcNBins - 1, AUP_AED_MAX(srcIdx, 0));
    tgt[tgtIdx] = src[srcIdx];
  }

  return;
}

static void AUP_Aed_CalcBinPow(int nBins, const float* cmplxSpctr,
                               float* binPow) {
  int idx, realIdx, imagIdx;

  // bin-0
  binPow[0] = cmplxSpctr[0] * cmplxSpctr[0];

  // bin-(NBins-1)
  binPow[nBins - 1] = cmplxSpctr[1] * cmplxSpctr[1];

  for (idx = 1; idx < (nBins - 1); idx++) {
    realIdx = idx << 1;
    imagIdx = realIdx + 1;

    binPow[idx] = cmplxSpctr[realIdx] * cmplxSpctr[realIdx] +
                  cmplxSpctr[imagIdx] * cmplxSpctr[imagIdx];
  }
  return;
}

static int AUP_Aed_pitch_proc(void* pitchModule, const float* timeSignal,
                              size_t timeLen, const float* binPow, size_t nBins,
                              PE_OutputData* pOut) {
  PE_InputData peInData;

  peInData.timeSignal = timeSignal;
  peInData.hopSz = (int)timeLen;
  peInData.inBinPow = binPow;
  peInData.nBins = (int)nBins;
  pOut->pitchFreq = 0;
  pOut->voiced = -1;
  return AUP_PE_proc(pitchModule, &peInData, pOut);
}

static int AUP_Aed_aivad_proc(Aed_St* stHdl, const float* inBinPow,
                              float* aivadScore) {
  if (stHdl == NULL || inBinPow == NULL || aivadScore == NULL) {
    return -1;
  }

  size_t i, j;
  size_t nBins = stHdl->intNBins;
  size_t melFbSz = stHdl->melFbSz;
  size_t srcOffset;
  size_t srcLen;

  float* aivadInputFeatStack = stHdl->aivadInputFeatStack;
  float* melFbCoef = stHdl->melFilterBankCoef;
  const float* aivadFeatMean = AUP_AED_FEATURE_MEANS;
  const float* aivadFeatStd = AUP_AED_FEATURE_STDS;
  float* curMelFbCoefPtr = NULL;
  float* curInputFeatPtr = NULL;
  float perBandValue = 0.0f;
  float powerNormal = 32768.0f * 32768.0f;

  // update aivad feature buff.
  srcOffset = stHdl->feaSz;
  srcLen = (stHdl->algCtxtSz - 1) * stHdl->feaSz;
  memmove(aivadInputFeatStack, aivadInputFeatStack + srcOffset,
          sizeof(float) * srcLen);
  curInputFeatPtr = aivadInputFeatStack + srcLen;

  // cal. mel-filter-bank feature
  for (i = 0; i < melFbSz; i++) {
    perBandValue = 0.0f;
    curMelFbCoefPtr = melFbCoef + i * nBins;
    for (j = 0; j < nBins; j++) {
      perBandValue += (inBinPow[j] * curMelFbCoefPtr[j]);
    }
    perBandValue = perBandValue / powerNormal;
    perBandValue = logf(perBandValue + AUP_AED_EPS);
    curInputFeatPtr[i] =
        (perBandValue - aivadFeatMean[i]) / (aivadFeatStd[i] + AUP_AED_EPS);
  }

  // extra feat.
  for (i = melFbSz; i < stHdl->feaSz; i++) {
    curInputFeatPtr[i] =
        (stHdl->pitchFreq - aivadFeatMean[i]) / (aivadFeatStd[i] + AUP_AED_EPS);
  }

  // exe. aivad
  // exe. aivad
  float aivadOutput;
  if (stHdl->aivadInf != NULL &&
      stHdl->aivadInf->Process(stHdl->aivadInputFeatStack, &aivadOutput) != 0) {
    return -1;
  }

  (*aivadScore) = aivadOutput;

  stHdl->aivadResetCnt += 1;
  if (stHdl->aivadResetCnt >= stHdl->aivadResetFrmNum) {
    if (stHdl->aivadInf != NULL && stHdl->aivadInf->Reset() != 0) {
    }
    stHdl->aivadResetCnt = 0;
  }

  return 0;
}

static int AUP_Aed_dynamMemPrepare(Aed_St* stHdl, void* memPtrExt,
                                   size_t memSize) {
  if (stHdl == NULL) {
    return -1;
  }
  size_t pitchInNBins = stHdl->intNBins;
  size_t totalMemSize = 0;
  size_t inputTimeFIFOMemSize = 0;
  size_t inputEmphTimeFIFOMemSize = 0;
  size_t aivadInputCmplxSptrmMemSize = 0;
  size_t aivadInputBinPowMemSize = 0;
  size_t frameRmsBuffMemSize = 0;
  size_t aivadInputFeatStackMemSize = 0;
  size_t aimdInputFeatStackMemSize = 0;
  size_t melFilterBankCoefMemSize = 0;
  size_t melFilterBinBuffMemSize = 0;
  size_t inputFloatBuffMemSize = 0;

  // size_t vadScoreOutputBuffDelaySample = 384; // buff. delay for output
  char* memPtr = NULL;

  // size_t nBinsBufferMemSize = AUP_AED_ALIGN8(sizeof(float) * nBins);
  // size_t spctrmMemSize = AUP_AED_ALIGN8(sizeof(float) * (nBins - 1) * 2);

  inputTimeFIFOMemSize =
      AUP_AED_ALIGN8(sizeof(float) * stHdl->inputTimeFIFOLen);
  totalMemSize += inputTimeFIFOMemSize;

  inputEmphTimeFIFOMemSize =
      AUP_AED_ALIGN8(sizeof(float) * stHdl->inputTimeFIFOLen);
  totalMemSize += inputEmphTimeFIFOMemSize;

  aivadInputCmplxSptrmMemSize = AUP_AED_ALIGN8(sizeof(float) * stHdl->intFftSz);
  totalMemSize += aivadInputCmplxSptrmMemSize;

  aivadInputBinPowMemSize = AUP_AED_ALIGN8(sizeof(float) * stHdl->intNBins);
  totalMemSize += aivadInputBinPowMemSize;

  aivadInputFeatStackMemSize =
      AUP_AED_ALIGN8(sizeof(float) * stHdl->algCtxtSz * stHdl->feaSz);
  totalMemSize += aivadInputFeatStackMemSize;

  aimdInputFeatStackMemSize =
      AUP_AED_ALIGN8(sizeof(float) * stHdl->algCtxtSz * stHdl->feaSz);
  totalMemSize += aimdInputFeatStackMemSize;

  melFilterBankCoefMemSize =
      AUP_AED_ALIGN8(sizeof(float) * pitchInNBins * stHdl->feaSz);
  totalMemSize += melFilterBankCoefMemSize;

  melFilterBinBuffMemSize = AUP_AED_ALIGN8(sizeof(size_t) * (stHdl->feaSz + 2));
  totalMemSize += melFilterBinBuffMemSize;

  frameRmsBuffMemSize = AUP_AED_ALIGN8(stHdl->frmRmsBufLen * sizeof(float));
  totalMemSize += frameRmsBuffMemSize;

  inputFloatBuffMemSize = AUP_AED_ALIGN8(stHdl->extHopSz * sizeof(float));
  totalMemSize += inputFloatBuffMemSize;

  if (memPtrExt == NULL) {
    return ((int)totalMemSize);
  }

  if (totalMemSize > memSize) {
    return -1;
  }

  memPtr = (char*)memPtrExt;

  stHdl->inputTimeFIFO = (float*)memPtr;
  memPtr += inputTimeFIFOMemSize;

  stHdl->inputEmphTimeFIFO = (float*)memPtr;
  memPtr += inputEmphTimeFIFOMemSize;

  stHdl->aivadInputCmplxSptrm = (float*)memPtr;
  memPtr += aivadInputCmplxSptrmMemSize;

  stHdl->aivadInputBinPow = (float*)memPtr;
  memPtr += aivadInputBinPowMemSize;

  stHdl->aivadInputFeatStack = (float*)memPtr;
  memPtr += aivadInputFeatStackMemSize;

  stHdl->melFilterBankCoef = (float*)memPtr;
  memPtr += melFilterBankCoefMemSize;

  stHdl->melFilterBinBuff = (size_t*)memPtr;
  memPtr += melFilterBinBuffMemSize;

  stHdl->frameRmsBuff = (float*)memPtr;
  memPtr += frameRmsBuffMemSize;

  stHdl->inputFloatBuff = (float*)memPtr;
  memPtr += inputFloatBuffMemSize;

  if (((size_t)(memPtr - (char*)memPtrExt)) > totalMemSize) {
    return -1;
  }

  return ((int)totalMemSize);
}

static int AUP_Aed_runOneFrm(Aed_St* stHdl, const float* tSignal, int hopSz,
                             const float* binPowPtr, int nBins) {
  PE_OutputData peOutData = {0, 0};
  float aivadScore = -1.0f;
  float mediaFilterout = 0;
  int mediaIdx = (int)(AUP_AED_OUTPUT_SMOOTH_FILTER_LEN) / 2;
  int i;

  if (AUP_Aed_pitch_proc(stHdl->pitchEstStPtr, tSignal, hopSz, binPowPtr, nBins,
                         &peOutData) < 0) {
    return -1;
  }
  stHdl->pitchFreq = peOutData.pitchFreq;
  if (AUP_Aed_aivad_proc(stHdl, binPowPtr, &aivadScore) < 0) {
    return -1;
  }
  stHdl->aivadScore = aivadScore;

  return 0;
}

/// ///////////////////////////////////////////////////////////////////////
/// Public API
/// ///////////////////////////////////////////////////////////////////////

int AUP_Aed_create(void** stPtr) {
  if (stPtr == NULL) {
    return -1;
  }
  Aed_St* tmpPtr = (Aed_St*)malloc(sizeof(Aed_St));
  if (tmpPtr == NULL) {
    return -1;
  }
  memset(tmpPtr, 0, sizeof(Aed_St));

  if (AUP_PE_create(&(tmpPtr->pitchEstStPtr)) < 0) {
    return -1;
  }
  if (AUP_Analyzer_create(&(tmpPtr->timeInAnalysis)) < 0) {
    return -1;
  }

  tmpPtr->stCfg.enableFlag = 1;  // as default, module enabled
  tmpPtr->stCfg.fftSz = 1024;
  tmpPtr->stCfg.hopSz = 256;
  tmpPtr->stCfg.anaWindowSz = 768;
  tmpPtr->stCfg.frqInputAvailableFlag = 0;

  tmpPtr->dynamCfg.extVoiceThr = 0.5f;
  tmpPtr->dynamCfg.extMusicThr = 0.5f;
  tmpPtr->dynamCfg.extEnergyThr = 10.0f;
  tmpPtr->dynamCfg.resetFrameNum = 1875;  // TODO
  tmpPtr->dynamCfg.pitchEstVoicedThr = AUP_AED_PITCH_EST_DEFAULT_VOICEDTHR;

  (*stPtr) = (void*)tmpPtr;

  return 0;
}

int AUP_Aed_destroy(void** stPtr) {
  if (stPtr == NULL || (*stPtr) == NULL) {
    return -1;
  }
  Aed_St* stHdl = (Aed_St*)(*stPtr);

  if (stHdl->aivadInf != NULL) {
    delete stHdl->aivadInf;
  }
  stHdl->aivadInf = NULL;

  if (AUP_PE_destroy(&(stHdl->pitchEstStPtr)) < 0) {
    return -1;
  }
  if (AUP_Analyzer_destroy(&(stHdl->timeInAnalysis)) < 0) {
    return -1;
  }

  if (stHdl->dynamMemPtr != NULL) {
    free(stHdl->dynamMemPtr);
  }
  stHdl->dynamMemPtr = NULL;

  if (stHdl != NULL) {
    free(stHdl);
  }
  (*stPtr) = NULL;

  return 0;
}

int AUP_Aed_memAllocate(void* stPtr, const Aed_StaticCfg* pCfg) {
  Aed_St* stHdl = (Aed_St*)(stPtr);
  Aed_StaticCfg aedStatCfg;
  PE_StaticCfg pitchStatCfg;
  Analyzer_StaticCfg analyzerStatCfg;
  int totalMemSize = 0;

  if (stPtr == NULL || pCfg == NULL) {
    return -1;
  }

  // 1th: check static cfg.
  memcpy(&aedStatCfg, pCfg, sizeof(Aed_StaticCfg));
  if (AUP_Aed_checkStatCfg(&aedStatCfg) < 0) {
    return -1;
  }

  memcpy(&(stHdl->stCfg), &aedStatCfg, sizeof(Aed_StaticCfg));

  // 2th: publish static configuration to internal statical configuration
  // registers
  if (AUP_Aed_publishStaticCfg(stHdl) < 0) {
    return -1;
  }

  // 3th: create aivad instance
  if (stHdl->aivadInf == NULL) {
    stHdl->aivadInf = new AUP_MODULE_AIVAD("onnx_model/ten-vad.onnx");
    if (stHdl->aivadInf == NULL) {
      return -1;
    }
  }
  stHdl->aivadInf->Reset();

  // 4th: memAllocate operation for Pitch-Estimator ............
  if (AUP_PE_getStaticCfg(stHdl->pitchEstStPtr, &pitchStatCfg) < 0) {
    return -1;
  }
  pitchStatCfg.fftSz = stHdl->intFftSz;
  pitchStatCfg.anaWindowSz = stHdl->intWinSz;
  pitchStatCfg.hopSz = stHdl->intHopSz;
  pitchStatCfg.useLPCPreFiltering = AUP_AED_PITCH_EST_USE_LPC;
  pitchStatCfg.procFs = AUP_AED_PITCH_EST_PROCFS;
  if (AUP_PE_memAllocate(stHdl->pitchEstStPtr, &pitchStatCfg) < 0) {
    return -1;
  }

  // creation and initialization with time-analysis module ......
  AUP_Analyzer_getStaticCfg(stHdl->timeInAnalysis, &analyzerStatCfg);
  analyzerStatCfg.win_len = (int)stHdl->intWinSz;
  analyzerStatCfg.hop_size = (int)stHdl->intHopSz;
  analyzerStatCfg.fft_size = (int)stHdl->intFftSz;
  analyzerStatCfg.ana_win_coeff = stHdl->intAnalyWindowPtr;
  if (AUP_Analyzer_memAllocate(stHdl->timeInAnalysis, &analyzerStatCfg) < 0) {
    return -1;
  }

  // 5th: check memory requirement ..............................
  totalMemSize = AUP_Aed_dynamMemPrepare(stHdl, NULL, 0);
  if (totalMemSize < 0) {
    return -1;
  }

  // 6th: allocate dynamic memory
  if (totalMemSize > (int)stHdl->dynamMemSize) {
    if (stHdl->dynamMemPtr != NULL) {
      free(stHdl->dynamMemPtr);
      stHdl->dynamMemPtr = NULL;
      stHdl->dynamMemSize = 0;
    }
    stHdl->dynamMemPtr = malloc(totalMemSize);
    if (stHdl->dynamMemPtr == NULL) {
      return -1;
    }
    stHdl->dynamMemSize = totalMemSize;
  }
  memset(stHdl->dynamMemPtr, 0, stHdl->dynamMemSize);

  // 7th: setup the pointers/variable
  if (AUP_Aed_dynamMemPrepare(stHdl, stHdl->dynamMemPtr, stHdl->dynamMemSize) <
      0) {
    return -1;
  }

  // 8th: publish internal dynamic config registers
  if (AUP_Aed_publishDynamCfg(stHdl) < 0) {
    return -1;
  }

  return 0;
}

int AUP_Aed_init(void* stPtr) {
  Aed_St* stHdl = (Aed_St*)(stPtr);
  if (stPtr == NULL) {
    return -1;
  }

  // publish internal dynamic config registers
  if (AUP_Aed_publishDynamCfg(stHdl) < 0) {
    return -1;
  }

  // clear/reset run-time variables
  if (AUP_Aed_resetVariables(stHdl) < 0) {
    return -1;
  }

  return 0;
}

int AUP_Aed_setDynamCfg(void* stPtr, const Aed_DynamCfg* pCfg) {
  Aed_St* stHdl = (Aed_St*)(stPtr);

  if (stPtr == NULL || pCfg == NULL) {
    return -1;
  }

  memcpy(&(stHdl->dynamCfg), pCfg, sizeof(Aed_DynamCfg));

  // publish internal dynamic configuration registers
  if (AUP_Aed_publishDynamCfg(stHdl) < 0) {
    return -1;
  }

  return 0;
}

int AUP_Aed_getStaticCfg(const void* stPtr, Aed_StaticCfg* pCfg) {
  const Aed_St* stHdl = (const Aed_St*)(stPtr);

  if (stPtr == NULL || pCfg == NULL) {
    return -1;
  }

  memcpy(pCfg, &(stHdl->stCfg), sizeof(Aed_StaticCfg));

  return 0;
}

int AUP_Aed_getDynamCfg(const void* stPtr, Aed_DynamCfg* pCfg) {
  const Aed_St* stHdl = (const Aed_St*)(stPtr);

  if (stPtr == NULL || pCfg == NULL) {
    return -1;
  }

  memcpy(pCfg, &(stHdl->dynamCfg), sizeof(Aed_DynamCfg));

  return 0;
}

int AUP_Aed_getAlgDelay(const void* stPtr, int* delayInFrms) {
  const Aed_St* stHdl = (const Aed_St*)(stPtr);

  if (stPtr == NULL || delayInFrms == NULL) {
    return -1;
  }

  (*delayInFrms) = (int)stHdl->algDelay;

  return 0;
}

int AUP_Aed_proc(void* stPtr, const Aed_InputData* pIn, Aed_OutputData* pOut) {
  Analyzer_InputData analyzerInput;
  Analyzer_OutputData analyzerOutput;
  Aed_St* stHdl = (Aed_St*)(stPtr);

  const float* binPowPtr = NULL;
  float frameRms = 0.0f;
  float frameEnergy = 0.0f;
  float powerNormal = 32768.0f * 32768.0f;
  int idx;

  if (stPtr == NULL) {
    return -1;
  }
  if (stHdl->stCfg.enableFlag == 0) {  // this module is disabled
    return 0;
  }
  if (pIn == NULL || pIn->timeSignal == NULL || pOut == NULL) {
    return -1;
  }

  if (stHdl->intAnalyFlag != 2) {  // the external spectra is going to be used
    if (pIn->binPower == NULL) {
      return -1;
    }
    if (pIn->nBins != (int)((stHdl->stCfg.fftSz >> 1) + 1) ||
        pIn->hopSz != (int)(stHdl->stCfg.hopSz)) {
      return -1;
    }
  }

  // cal. input frame energy ....
  for (idx = 0; idx < pIn->hopSz; idx++) {
    frameRms += (pIn->timeSignal[idx] * pIn->timeSignal[idx]);
  }
  frameEnergy = frameRms;
  frameRms = sqrtf(frameRms / (float)pIn->hopSz);
  memmove(stHdl->frameRmsBuff, stHdl->frameRmsBuff + 1,
          sizeof(float) * (stHdl->frmRmsBufLen - 1));
  stHdl->frameRmsBuff[stHdl->frmRmsBufLen - 1] = frameRms;

  // input signal conversion .........
  if ((stHdl->inputTimeFIFOIdx + pIn->hopSz) > (int)stHdl->inputTimeFIFOLen) {
    return -1;
  }

  // update pre-emphasis time signal FIFO
  float* timeSigEphaPtr = stHdl->inputEmphTimeFIFO + stHdl->inputTimeFIFOIdx;
  for (idx = 0; idx < pIn->hopSz; idx++) {
    timeSigEphaPtr[idx] = pIn->timeSignal[idx] - 0.97f * stHdl->timeSignalPre;
    stHdl->timeSignalPre = pIn->timeSignal[idx];
  }

  memcpy(stHdl->inputTimeFIFO + stHdl->inputTimeFIFOIdx, pIn->timeSignal,
         sizeof(float) * (pIn->hopSz));
  stHdl->inputTimeFIFOIdx += pIn->hopSz;

  if (stHdl->intAnalyFlag == 0) {  // directly use external spectra
    if (stHdl->inputTimeFIFOIdx != (int)(stHdl->intHopSz) ||
        (int)(stHdl->intNBins) != pIn->nBins) {
      return -1;
    }

    // one-time processing ...
    stHdl->aedProcFrmCnt = AUP_Aed_addOneCnter(stHdl->aedProcFrmCnt);
    binPowPtr = pIn->binPower;

    // update: stHdl->pitchFreq, stHdl->aivadScore
    if (AUP_Aed_runOneFrm(stHdl, stHdl->inputTimeFIFO, (int)stHdl->intHopSz,
                          binPowPtr, (int)stHdl->intNBins) < 0) {
      return -1;
    }

    // update the inputTimeFIFO
    stHdl->inputTimeFIFOIdx = 0;
  } else if (stHdl->intAnalyFlag ==
             1) {  // do interpolation or extrapolation with external spectra
    if (stHdl->inputTimeFIFOIdx != (int)(stHdl->intHopSz) ||
        (int)(stHdl->extNBins) != pIn->nBins) {
      return -1;
    }

    // one-time processing ....
    stHdl->aedProcFrmCnt = AUP_Aed_addOneCnter(stHdl->aedProcFrmCnt);
    AUP_Aed_binPowerConvert(pIn->binPower, stHdl->aivadInputBinPow,
                            (int)stHdl->extNBins, (int)stHdl->intNBins);
    binPowPtr = stHdl->aivadInputBinPow;

    // update: stHdl->pitchFreq, stHdl->aivadScore
    if (AUP_Aed_runOneFrm(stHdl, stHdl->inputTimeFIFO, (int)stHdl->intHopSz,
                          binPowPtr, (int)stHdl->intNBins) < 0) {
      return -1;
    }

    // update the inputTimeFIFO
    stHdl->inputTimeFIFOIdx = 0;
  } else {  // we need to do STFT on the input time-signal
    if (stHdl->timeInAnalysis == NULL) {
      return -1;
    }

    // loop processing .....
    while (stHdl->inputTimeFIFOIdx >= (int)stHdl->intHopSz) {
      stHdl->aedProcFrmCnt = AUP_Aed_addOneCnter(stHdl->aedProcFrmCnt);

      analyzerInput.input = stHdl->inputEmphTimeFIFO;
      analyzerInput.iLength = (int)stHdl->intHopSz;
      analyzerOutput.output = stHdl->aivadInputCmplxSptrm;
      analyzerOutput.oLength = (int)stHdl->intFftSz;
      if (AUP_Analyzer_proc(stHdl->timeInAnalysis, &analyzerInput,
                            &analyzerOutput) < 0) {
        return -1;
      }

      AUP_Aed_CalcBinPow((int)stHdl->intNBins, stHdl->aivadInputCmplxSptrm,
                         stHdl->aivadInputBinPow);
      binPowPtr = stHdl->aivadInputBinPow;

      // update: stHdl->pitchFreq, stHdl->aivadScore
      if (AUP_Aed_runOneFrm(stHdl, stHdl->inputTimeFIFO, (int)stHdl->intHopSz,
                            binPowPtr, (int)stHdl->intNBins) < 0) {
        return -1;
      }

      // update the inputTimeFIFO & inputEmphTimeFIFO.....
      if (stHdl->inputTimeFIFOIdx > (int)stHdl->intHopSz) {
        memcpy(stHdl->inputTimeFIFO, stHdl->inputTimeFIFO + stHdl->intHopSz,
               sizeof(float) * (stHdl->inputTimeFIFOIdx - stHdl->intHopSz));
        memcpy(stHdl->inputEmphTimeFIFO,
               stHdl->inputEmphTimeFIFO + stHdl->intHopSz,
               sizeof(float) * (stHdl->inputTimeFIFOIdx - stHdl->intHopSz));
      }
      stHdl->inputTimeFIFOIdx -= (int)stHdl->intHopSz;
    }
  }

  // write to output res.
  pOut->frameEnergy = frameEnergy / powerNormal;
  pOut->frameRms = stHdl->frameRmsBuff[0];
  pOut->pitchFreq = stHdl->pitchFreq;
  pOut->voiceProb = stHdl->aivadScore;
  if (pOut->voiceProb < 0.0f) {
    pOut->vadRes = -1;
  } else if (pOut->voiceProb <= stHdl->voiceDecideThresh) {
    pOut->vadRes = 0;
  } else {
    pOut->vadRes = 1;
  }

  return 0;
}



================================================
FILE: src/aed.h
================================================
//
// Copyright © 2025 Agora
// This file is part of TEN Framework, an open source project.
// Licensed under the Apache License, Version 2.0, with certain conditions.
// Refer to the "LICENSE" file in the root directory for more information.
//
#ifndef __AED_H__
#define __AED_H__

#include <stdint.h>
#include <stdlib.h>

#define AUP_AED_MAX_FFT_SZ (1024)  // the max. fft-size supported by VAD module
#define AUP_AED_MAX_NBINS ((AUP_AED_MAX_FFT_SZ >> 1) + 1)

#define AUP_AED_FS (16000)  // assumed input freq.

// Configuration Parameters, which impacts dynamic memory occupation, can only
// be set during allocation
typedef struct Aed_StaticCfg_ {
  int enableFlag;  // flag to enable or disable this module
  // 0: disable, o.w.: enable
  size_t fftSz;               // fft-size, only support: 128, 256, 512, 1024
  size_t hopSz;               // fft-Hop Size, will be used to check
  size_t anaWindowSz;         // fft-window Size, will be used to calc rms
  int frqInputAvailableFlag;  // whether Aed_InputData will contain external
                              // freq. power-sepctra
} Aed_StaticCfg;

// Configuraiton parameters which can be modified/set every frames
typedef struct Aed_DynamCfg_ {
  float extVoiceThr;        // threshold for ai based voice decision [0,1]
  float extMusicThr;        // threshold for ai based music decision [0,1]
  float extEnergyThr;       // threshold for energy based vad decision [0, ---]
  size_t resetFrameNum;     // frame number for aivad reset [1875, 75000]
  float pitchEstVoicedThr;  // threshold for pitch-estimator to output estimated
                            // pitch
} Aed_DynamCfg;

// Spectrum are assumed to be generated with time-domain samples in [-32768,
// 32767] with or without pre-emphasis operation
typedef struct Aed_InputData_ {
  const float* binPower;  // [NBins], power spectrum of 16KHz samples
  int nBins;
  const float*
      timeSignal;  // [hopSz]   // this frame's input signal, in [-32768, 32767]
  int hopSz;       // should be equal to StaticCfg->hopSz
} Aed_InputData;

// return data from statistical ns module
typedef struct Aed_OutputData_ {
  float frameEnergy;  // frame energy for input normalized data
  float frameRms;     // rms for input int16 data
  int energyVadRes;  // vad res 0/1 with extEnergyThreshold based on input frame
                     // energy
  float voiceProb;   // vad score [0,1]
  int vadRes;  // vad res 0/1 with extVoiceThr based on ai method, t + 16ms res
               // correspond to the t input
  float pitchFreq;  // estimated pitch freq.
} Aed_OutputData;

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************
 * AUP_Aed_Create(...)
 *
 * This function creats a state handler from nothing, which is NOT ready for
 * processing
 *
 * Input:
 *
 * Output:
 *      - stPtr         : buffer to store the returned state handler
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Aed_create(void** stPtr);

/****************************************************************************
 * AUP_Aed_Destroy(...)
 *
 * destroy VAD instance, and releasing all the dynamically allocated memory
 * this interface will also release ainsFactory, which was
 * created externally and passed to VAD module through memAllocate interface
 *
 * Input:
 *      - stPtr         : buffer of State Handler, after this method, this
 *                        handler won't be usable anymore
 *
 * Output:
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Aed_destroy(void** stPtr);

/****************************************************************************
 * AUP_Aed_MemAllocate(...)
 *
 * This function sets Static Config params and does memory allocation
 * operation, will lose the dynamCfg values
 *
 * Input:
 *      - stPtr         : State Handler which was returned by _create
 *      - pCfg          : static configuration parameters
 *
 * Output:
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Aed_memAllocate(void* stPtr, const Aed_StaticCfg* pCfg);

/****************************************************************************
 * AUP_Aed_init(...)
 *
 * This function resets (initialize) the VAD module and gets it prepared for
 * processing
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate
 *
 * Output:
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Aed_init(void* stPtr);

/****************************************************************************
 * AUP_Aed_setDynamCfg(...)
 *
 * This function set dynamic (per-frame variable) configuration
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate
 *      - pCfg          : configuration content
 *
 * Output:
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Aed_setDynamCfg(void* stPtr, const Aed_DynamCfg* pCfg);

/****************************************************************************
 * AUP_Aed_getStaticCfg(...)
 *
 * This function get static configuration status from VAD module
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate
 *
 * Output:
 *      - pCfg          : configuration content
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Aed_getStaticCfg(const void* stPtr, Aed_StaticCfg* pCfg);

/****************************************************************************
 * AUP_Aed_getDynamCfg(...)
 *
 * This function get dynamic (per-frame variable) configuration status from
 * VAD module
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate
 *
 * Output:
 *      - pCfg          : configuration content
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Aed_getDynamCfg(const void* stPtr, Aed_DynamCfg* pCfg);

/****************************************************************************
 * AUP_Aed_getAlgDelay(...)
 *
 * This function get algorithm delay from VAD module
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate
 *
 * Output:
 *      - delayInFrms   : algorithm delay in terms of frames
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Aed_getAlgDelay(const void* stPtr, int* delayInFrms);

/****************************************************************************
 * AUP_Aed_proc(...)
 *
 * process a single frame
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate and reset
 *      - pCtrl         : per-frame variable control parameters
 *      - pIn           : input data stream
 *
 * Output:
 *      - pOut          : output data (mask, highband time-domain gain etc.)
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Aed_proc(void* stPtr, const Aed_InputData* pIn, Aed_OutputData* pOut);

#ifdef __cplusplus
}
#endif

#endif



================================================
FILE: src/aed_st.h
================================================
//
// Copyright © 2025 Agora
// This file is part of TEN Framework, an open source project.
// Licensed under the Apache License, Version 2.0, with certain conditions.
// Refer to the "LICENSE" file in the root directory for more information.
//
#ifndef __AED_ST_H__
#define __AED_ST_H__

#include <stdio.h>
#include <onnxruntime_c_api.h>

#include "aed.h"

#define AUP_AED_FS (16000)
#define AUP_AED_MAX_IN_BUFF_SIZE (256)
#define AUP_AED_POWER_SPCTR_NORMALIZER (9.3132e-10f)  // = 1/(32768^2)
#define AUP_AED_OUTPUT_SMOOTH_FILTER_LEN (10)         // 160ms

#define AUP_AED_MEL_FILTER_BANK_NUM (40)
#define AUP_AED_LOOKAHEAD_NFRM (1)
#define AUP_AED_CONTEXT_WINDOW_LEN (3)  // context window length of AIVAD
#define AUP_AED_FEA_LEN \
  (AUP_AED_MEL_FILTER_BANK_NUM + 1)  // feature length of AIVAD

#define AUP_AED_PITCH_EST_USE_LPC (1)
#define AUP_AED_PITCH_EST_PROCFS (4000)
#if AUP_AED_PITCH_EST_PROCFS == 2000
#define AUP_AED_PITCH_EST_DEFAULT_VOICEDTHR (0.45f)
#else
#define AUP_AED_PITCH_EST_DEFAULT_VOICEDTHR (0.4f)
#endif

#define AUP_AED_MODEL_IO_NUM (5)
#define AUP_AED_MODEL_NAME_LENGTH (32)
#define AUP_AED_MODEL_HIDDEN_DIM (64)

class AUP_MODULE_AIVAD {
 public:
  AUP_MODULE_AIVAD(char* onnx_path);
  ~AUP_MODULE_AIVAD();
  int Process(float* input, float* output);
  int Reset();

 private:
  const OrtApi* ort_api = NULL;
  OrtAllocator* ort_allocator = NULL;
  OrtEnv* ort_env = NULL;
  OrtSession* ort_session = NULL;
  int inited = 0;
  int clear_hidden = 0;

  char input_names_buf[AUP_AED_MODEL_IO_NUM][AUP_AED_MODEL_NAME_LENGTH] = {0};
  const char* input_names[AUP_AED_MODEL_IO_NUM] = {NULL};
  float input_data_buf_0[AUP_AED_CONTEXT_WINDOW_LEN * AUP_AED_FEA_LEN] = {0};
  float input_data_buf_1234[AUP_AED_MODEL_IO_NUM - 1]
                           [AUP_AED_MODEL_HIDDEN_DIM] = {0};
  OrtValue* ort_input_tensors[AUP_AED_MODEL_IO_NUM] = {NULL};

  char output_names_buf[AUP_AED_MODEL_IO_NUM][AUP_AED_MODEL_NAME_LENGTH] = {0};
  const char* output_names[AUP_AED_MODEL_IO_NUM] = {NULL};
  OrtValue* ort_output_tensors[AUP_AED_MODEL_IO_NUM] = {NULL};
};

typedef struct Aed_St_ {
  void* dynamMemPtr;    // memory pointer holding the dynamic memory
  size_t dynamMemSize;  // size of the buffer *dynamMemPtr

  Aed_StaticCfg stCfg;

  Aed_DynamCfg dynamCfg;

  // Internal Static Config Registers, which are generated from stCfg
  size_t extFftSz;  // externally decided FFT-Sz
  size_t extHopSz;  // externally decided FFT-Hop-Sz
  size_t extNBins;  // (FFTSz/2) + 1
  size_t extWinSz;  // externally decided FFT-Window-Sz

  size_t intFftSz;                 // internal FFT Sz
  size_t intHopSz;                 // internal Hop Sz
  size_t intWinSz;                 // internal Window Sz
  size_t intNBins;                 // internal NBins
  const float* intAnalyWindowPtr;  // internal analysis pointer
  int intAnalyFlag;                // whether to do internal analysis
  // 0: directly use external spectrum
  // 1: use external spectrum with interpolation / exterpolation
  // 2: need to redo analysis based on input time-domain signal
  size_t inputTimeFIFOLen;  // length of input FIFO buffer
  // if = 0: no need for input time-domain FIFO Queue

  // Internal static config registers for pitch-est module
  size_t feaSz;
  size_t melFbSz;
  size_t algDelay;  // in terms of processing frames
  size_t algCtxtSz;
  size_t frmRmsBufLen;  // frameRmsBuff: buffer-length of frameRmsBuff (FIFO)

  // Internal dynamic Config Registers, which are generated from dynamCfg
  size_t aivadResetFrmNum;
  float voiceDecideThresh;

  // SubModules
  AUP_MODULE_AIVAD* aivadInf;

  void* pitchEstStPtr;  // pitch-estimation module handler
  void* timeInAnalysis;
  // state handler of STFT analysis module

  // Variables
  int aedProcFrmCnt;  // counter of consecutive AI-VAD processed frames
  int inputTimeFIFOIdx;
  float* inputTimeFIFO;  // [inputTimeFIFOLen]
  // input fifo buffer of time-signal to adjust between extHopSz and intHopSz
  float* inputEmphTimeFIFO;     // [inputTimeFIFOLen]
  float* aivadInputCmplxSptrm;  // [intFftSz]
  float* aivadInputBinPow;      // [intNBins]  // AIVAD input power spectrum
  size_t aivadResetCnt;
  float timeSignalPre;
  float aivadScore;
  float aivadScorePre;

  float pitchFreq;      // input audio pitch in Hz
  float* frameRmsBuff;  // [frmRmsBufLen], FIFO, to delay frmRms result so that
                        // it aligns with AIVAD result
  float* aivadInputFeatStack;  // [...] = [AUP_AED_CONTEXT_WINDOW_LEN *
                               // AUP_AED_FEA_LEN]
  float* melFilterBankCoef;    // [melFbSz][nBins]
  size_t* melFilterBinBuff;    // [melFbSz + 2]
  float* inputFloatBuff;       // [hopSz]
} Aed_St;

#endif



================================================
FILE: src/biquad.cc
================================================
//
// Copyright © 2025 Agora
// This file is part of TEN Framework, an open source project.
// Licensed under the Apache License, Version 2.0, with certain conditions.
// Refer to the "LICENSE" file in the root directory for more information.
//
#include "biquad.h"

#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "biquad_st.h"

#define AUP_BIQUAD_NUM_DUMP_FILES (20)
#define AUP_BIQUAD_DUMP_FILENAMES (200)

// ==========================================================================================
// internal tools
// ==========================================================================================

static int AUP_Biquad_checkStatCfg(const Biquad_StaticCfg* pCfg) {
  int secIdx;
  if (pCfg == NULL) {
    return -1;
  }

  if (pCfg->maxNSample == 0 ||
      pCfg->maxNSample > AGORA_UAP_BIQUAD_MAX_INPUT_LEN) {
    return -1;
  }
  if (pCfg->nsect > AGORA_UAP_BIQUAD_MAX_SECTION) {
    return -1;
  }

  // if external filter coefficients are required, we need to check the
  //    external filter coeff pointers' validness
  if (pCfg->nsect > 0) {
    for (secIdx = 0; secIdx < pCfg->nsect; secIdx++) {
      if (pCfg->B[secIdx] == NULL || pCfg->A[secIdx] == NULL) {
        return -1;
      }
    }
    if (pCfg->G == NULL) {
      return -1;
    }
  }

  return 0;
}

static int AUP_Biquad_publishStaticCfg(Biquad_St* stHdl) {
  const Biquad_StaticCfg* pStatCfg;
  int idx;

  if (stHdl == NULL) {
    return -1;
  }
  pStatCfg = (const Biquad_StaticCfg*)(&(stHdl->stCfg));

  stHdl->maxNSample = (int)pStatCfg->maxNSample;

  // first, give default (all-pass-filter) values to filter coeffs
  for (idx = 0; idx < AGORA_UAP_BIQUAD_MAX_SECTION; idx++) {
    stHdl->BCoeff[idx][0] = 1.0f;
    stHdl->BCoeff[idx][1] = 0;
    stHdl->BCoeff[idx][2] = 0;
    stHdl->ACoeff[idx][0] = 1.0f;
    stHdl->ACoeff[idx][1] = 0;
    stHdl->ACoeff[idx][2] = 0;
    stHdl->GCoeff[idx] = 1.0f;
  }

  if (pStatCfg->nsect <= 0) {
    stHdl->nsect = _BIQUAD_DC_REMOVAL_NSECT;
    for (idx = 0; idx < stHdl->nsect; idx++) {
      stHdl->BCoeff[idx][0] = _BIQUAD_DC_REMOVAL_B[idx][0];
      stHdl->BCoeff[idx][1] = _BIQUAD_DC_REMOVAL_B[idx][1];
      stHdl->BCoeff[idx][2] = _BIQUAD_DC_REMOVAL_B[idx][2];
      stHdl->ACoeff[idx][0] = _BIQUAD_DC_REMOVAL_A[idx][0];
      stHdl->ACoeff[idx][1] = _BIQUAD_DC_REMOVAL_A[idx][1];
      stHdl->ACoeff[idx][2] = _BIQUAD_DC_REMOVAL_A[idx][2];
      stHdl->GCoeff[idx] = _BIQUAD_DC_REMOVAL_G[idx];
    }
  } else {
    stHdl->nsect = pStatCfg->nsect;
    for (idx = 0; idx < stHdl->nsect; idx++) {
      stHdl->BCoeff[idx][0] = pStatCfg->B[idx][0];
      stHdl->BCoeff[idx][1] = pStatCfg->B[idx][1];
      stHdl->BCoeff[idx][2] = pStatCfg->B[idx][2];

      stHdl->ACoeff[idx][0] = pStatCfg->A[idx][0];
      stHdl->ACoeff[idx][1] = pStatCfg->A[idx][1];
      stHdl->ACoeff[idx][2] = pStatCfg->A[idx][2];

      stHdl->GCoeff[idx] = pStatCfg->G[idx];
    }
  }

  return 0;
}

static int AUP_Biquad_resetVariables(Biquad_St* stHdl) {
  memset(stHdl->dynamMemPtr, 0, stHdl->dynamMemSize);
  memset(stHdl->sectW, 0, sizeof(stHdl->sectW));

  return 0;
}

// ==========================================================================================
// public APIS
// ==========================================================================================

int AUP_Biquad_create(void** stPtr) {
  Biquad_St* tmpPtr;

  if (stPtr == NULL) {
    return -1;
  }
  *stPtr = (void*)malloc(sizeof(Biquad_St));
  if (*stPtr == NULL) {
    return -1;
  }
  memset(*stPtr, 0, sizeof(Biquad_St));

  tmpPtr = (Biquad_St*)(*stPtr);

  tmpPtr->dynamMemPtr = NULL;
  tmpPtr->dynamMemSize = 0;

  tmpPtr->stCfg.maxNSample = 768;
  tmpPtr->stCfg.nsect = 0;
  for (int idx = 0; idx < AGORA_UAP_BIQUAD_MAX_SECTION; idx++) {
    tmpPtr->stCfg.A[idx] = NULL;
    tmpPtr->stCfg.B[idx] = NULL;
  }
  tmpPtr->stCfg.G = NULL;

  return 0;
}

int AUP_Biquad_destroy(void** stPtr) {
  Biquad_St* stHdl;

  if (stPtr == NULL) {
    return 0;
  }

  stHdl = (Biquad_St*)(*stPtr);
  if (stHdl == NULL) {
    return 0;
  }

  if (stHdl->dynamMemPtr != NULL) {
    free(stHdl->dynamMemPtr);
  }
  stHdl->dynamMemPtr = NULL;

  free(stHdl);

  (*stPtr) = NULL;

  return 0;
}

int AUP_Biquad_memAllocate(void* stPtr, const Biquad_StaticCfg* pCfg) {
  Biquad_St* stHdl = NULL;
  char* memPtr = NULL;
  int maxNSample, nsect, idx;

  int inputTempBufMemSize = 0;
  int sectOutputBufMemSize_EACH = 0;
  int totalMemSize = 0;

  if (stPtr == NULL || pCfg == NULL) {
    return -1;
  }
  stHdl = (Biquad_St*)(stPtr);

  if (AUP_Biquad_checkStatCfg(pCfg) < 0) {
    return -1;
  }
  memcpy(&(stHdl->stCfg), pCfg, sizeof(Biquad_StaticCfg));

  if (AUP_Biquad_publishStaticCfg(stHdl) < 0) {
    return -1;
  }
  maxNSample = stHdl->maxNSample;
  nsect = stHdl->nsect;

  // check memory requirement
  inputTempBufMemSize = AGORA_UAP_BIQUAD_ALIGN8(sizeof(float) * maxNSample);
  totalMemSize += inputTempBufMemSize;

  sectOutputBufMemSize_EACH =
      AGORA_UAP_BIQUAD_ALIGN8(sizeof(float) * maxNSample);
  totalMemSize += sectOutputBufMemSize_EACH * nsect;

  // allocate dynamic memory
  if ((size_t)totalMemSize > stHdl->dynamMemSize) {
    if (stHdl->dynamMemPtr != NULL) {
      free(stHdl->dynamMemPtr);
      stHdl->dynamMemSize = 0;
    }
    stHdl->dynamMemPtr = malloc(totalMemSize);
    if (stHdl->dynamMemPtr == NULL) {
      return -1;
    }
    stHdl->dynamMemSize = totalMemSize;
  }
  memset(stHdl->dynamMemPtr, 0, stHdl->dynamMemSize);

  // setup the pointers/variable
  memPtr = (char*)(stHdl->dynamMemPtr);

  stHdl->inputTempBuf = (float*)memPtr;
  memPtr += inputTempBufMemSize;

  for (idx = 0; idx < nsect; idx++) {
    stHdl->sectOutputBuf[idx] = (float*)memPtr;
    memPtr += sectOutputBufMemSize_EACH;
  }
  for (; idx < AGORA_UAP_BIQUAD_MAX_SECTION; idx++) {
    stHdl->sectOutputBuf[idx] = NULL;
  }

  if (((int)(memPtr - (char*)(stHdl->dynamMemPtr))) > totalMemSize) {
    return -1;
  }

  return 0;
}

int AUP_Biquad_init(void* stPtr) {
  Biquad_St* stHdl;

  if (stPtr == NULL) {
    return -1;
  }
  stHdl = (Biquad_St*)(stPtr);

  if (AUP_Biquad_resetVariables(stHdl) < 0) {
    return -1;
  }

  return 0;
}

int AUP_Biquad_getStaticCfg(const void* stPtr, Biquad_StaticCfg* pCfg) {
  const Biquad_St* stHdl;

  if (stPtr == NULL || pCfg == NULL) {
    return -1;
  }
  stHdl = (const Biquad_St*)(stPtr);

  memcpy(pCfg, &(stHdl->stCfg), sizeof(Biquad_StaticCfg));

  return 0;
}

int AUP_Biquad_getAlgDelay(const void* stPtr, int* delayInSamples) {
  const Biquad_St* stHdl;

  if (stPtr == NULL || delayInSamples == NULL) {
    return -1;
  }
  stHdl = (const Biquad_St*)(stPtr);

  *delayInSamples = stHdl->nsect;

  return 0;
}

int AUP_Biquad_proc(void* stPtr, const Biquad_InputData* pIn,
                    Biquad_OutputData* pOut) {
  Biquad_St* stHdl = NULL;
  int isFloatIO = 0;
  int inputNSamples, nSect;
  int sectIdx, smplIdx;
  float tmp1;
  const short* pShortTemp;
  float* src;
  float* tgt;

  if (stPtr == NULL || pIn == NULL || pOut == NULL) {  //  pCtrl == NULL
    return -1;
  }
  if (pIn->samplesPtr == NULL || pOut->outputBuff == NULL) {
    return -1;
  }

  stHdl = (Biquad_St*)(stPtr);

  if (((int)pIn->nsamples) > stHdl->maxNSample) {
    return -1;
  }

  isFloatIO = 0;
  if (pIn->sampleType != 0) {
    isFloatIO = 1;
  }

  inputNSamples = (int)pIn->nsamples;
  nSect = stHdl->nsect;

  // special handle for input
  if (isFloatIO == 0) {
    pShortTemp = (const short*)pIn->samplesPtr;
    for (smplIdx = 0; smplIdx < inputNSamples; smplIdx++) {
      stHdl->inputTempBuf[smplIdx] = (float)pShortTemp[smplIdx];
    }
  } else {
    memcpy(stHdl->inputTempBuf, (const float*)pIn->samplesPtr,
           sizeof(float) * inputNSamples);
  }

  for (sectIdx = 0; sectIdx < nSect; sectIdx++) {
    if (sectIdx == 0) {
      src = stHdl->inputTempBuf;
    } else {
      src = stHdl->sectOutputBuf[sectIdx - 1];
    }
    tgt = stHdl->sectOutputBuf[sectIdx];

    for (smplIdx = 0; smplIdx < inputNSamples; smplIdx++) {
      tmp1 = src[smplIdx] -
             stHdl->ACoeff[sectIdx][1] * stHdl->sectW[sectIdx][0] -
             stHdl->ACoeff[sectIdx][2] * stHdl->sectW[sectIdx][1];

      tgt[smplIdx] = stHdl->GCoeff[sectIdx] *
                     (stHdl->BCoeff[sectIdx][0] * tmp1 +
                      stHdl->BCoeff[sectIdx][1] * stHdl->sectW[sectIdx][0] +
                      stHdl->BCoeff[sectIdx][2] * stHdl->sectW[sectIdx][1]);

      stHdl->sectW[sectIdx][1] = stHdl->sectW[sectIdx][0];
      stHdl->sectW[sectIdx][0] = tmp1;
    }
  }

  // prepare output buffer
  if (isFloatIO == 0) {
    for (smplIdx = 0; smplIdx < inputNSamples; smplIdx++) {
      ((short*)pOut->outputBuff)[smplIdx] =
          (short)_BIQUAD_FLOAT2SHORT(stHdl->sectOutputBuf[nSect - 1][smplIdx]);
    }
  } else {
    memcpy(pOut->outputBuff, stHdl->sectOutputBuf[nSect - 1],
           sizeof(float) * inputNSamples);
  }

  return 0;
}



================================================
FILE: src/biquad.h
================================================
//
// Copyright © 2025 Agora
// This file is part of TEN Framework, an open source project.
// Licensed under the Apache License, Version 2.0, with certain conditions.
// Refer to the "LICENSE" file in the root directory for more information.
//
#ifndef __BIQUAD_H__
#define __BIQUAD_H__

#include <stdio.h>

#define AGORA_UAP_BIQUAD_MAX_SECTION (20)
// the max. number of sections supported by this Biquad module

#define AGORA_UAP_BIQUAD_MAX_INPUT_LEN (3840)
// max. number of samples each time can be fed in

#define AGORA_UAP_BIQUAD_ALIGN8(o) (((o) + 7) & (~7))
#define _BIQUAD_FLOAT2SHORT(x) \
  ((x) < -32767.5f ? -32768 : ((x) > 32766.5f ? 32767 : (short)floor(.5 + (x))))

#define _BIQUAD_DC_REMOVAL_NSECT (2)
const float _BIQUAD_DC_REMOVAL_B[_BIQUAD_DC_REMOVAL_NSECT][3] = {
    {1.0f, -2.0f, 1.0f}, {1.0f, -1.0f, 0.0f}};
const float _BIQUAD_DC_REMOVAL_A[_BIQUAD_DC_REMOVAL_NSECT][3] = {
    {1.0f, -1.93944294f, 0.94281253f}, {1.0f, -0.94276431f, 0.0f}};
// const float _BIQUAD_DC_REMOVAL_G[_BIQUAD_DC_REMOVAL_NSECT] = {0.97056387f,
// 0.97138215f};
const float _BIQUAD_DC_REMOVAL_G[_BIQUAD_DC_REMOVAL_NSECT] = {0.97056387f,
                                                              0.8655014957f};

// Configuration Parameters, which impacts dynamic memory occupation, can only
// be set during allocation
typedef struct Biquad_StaticCfg_ {
  size_t maxNSample;  // max. number of samples each time can be fed in
  // (0, AGORA_UAP_BIQUAD_MAX_INPUT_LEN]

  int nsect;  // the number of sections to be processed by this Biquad module
  // (-inf, AGORA_UAP_BIQUAD_MAX_SECTION]
  // if <= 0, use internal default filter coefficients

  const float* B[AGORA_UAP_BIQUAD_MAX_SECTION];
  const float* A[AGORA_UAP_BIQUAD_MAX_SECTION];
  // always assume A[...][0] = 1.0f
  const float* G;
} Biquad_StaticCfg;

typedef struct Biquad_InputData_ {
  const void*
      samplesPtr;  // externally provided buffer containing input time samples
  // either in short or float type
  short sampleType;  // = 0: samplesPtr = short*; o.w. samplesPtr = float*
  size_t nsamples;   // number of samples fed in this time
} Biquad_InputData;

typedef struct Biquad_OutputData_ {
  void* outputBuff;  // externally provided output buffer,
                     // assumed to be of enough size  nsamples *
                     // sizeof(short)/sizeof(short) output data type is the same
                     // as input
} Biquad_OutputData;

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************
 * AUP_Biquad_create(...)
 *
 * This function creats a state handler from nothing, which is NOT ready for
 * processing
 *
 * Input:
 *
 * Output:
 *      - stPtr         : buffer to store the returned state handler
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Biquad_create(void** stPtr);

/****************************************************************************
 * AUP_Biquad_destroy(...)
 *
 * destroy biquad instance, and releasing all the dynamically allocated memory
 *
 * Input:
 *      - stPtr         : buffer of State Handler, after this method, this
 *                        handler won't be usable anymore
 *
 * Output:
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Biquad_destroy(void** stPtr);

/****************************************************************************
 * AUP_Biquad_memAllocate(...)
 *
 * This function sets Static Config params and does memory allocation
 * operation
 *
 * Input:
 *      - stPtr         : State Handler which was returned by _create
 *      - pCfg          : static configuration parameters
 *
 * Output:
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Biquad_memAllocate(void* stPtr, const Biquad_StaticCfg* pCfg);

/****************************************************************************
 * AUP_Biquad_init(...)
 *
 * This function resets (initialize) the biquad module and gets it prepared for
 * processing
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate
 *
 * Output:
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Biquad_init(void* stPtr);

/****************************************************************************
 * AUP_Biquad_getStaticCfg(...)
 *
 * This function get static configuration status from Biquad module
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate
 *
 * Output:
 *      - pCfg          : configuration content
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Biquad_getStaticCfg(const void* stPtr, Biquad_StaticCfg* pCfg);

/****************************************************************************
 * AUP_Biquad_getAlgDelay(...)
 *
 * This function get algorithm delay from biquad module
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate
 *
 * Output:
 *      - delayInSamples   : algorithm delay in terms of samples
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Biquad_getAlgDelay(const void* stPtr, int* delayInSamples);

/****************************************************************************
 * AUP_Biquad_proc(...)
 *
 * process a single frame
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate
 *      - pCtrl         : per-frame variable control parameters
 *      - pIn           : input data stream
 *
 * Output:
 *      - pOut          : output data (mask, highband time-domain gain etc.)
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Biquad_proc(void* stPtr, const Biquad_InputData* pIn,
                    Biquad_OutputData* pOut);

#ifdef __cplusplus
}
#endif
#endif  // __BIQUAD_H__



================================================
FILE: src/biquad_st.h
================================================
//
// Copyright © 2025 Agora
// This file is part of TEN Framework, an open source project.
// Licensed under the Apache License, Version 2.0, with certain conditions.
// Refer to the "LICENSE" file in the root directory for more information.
//
#ifndef __BIQUAD_ST_H__
#define __BIQUAD_ST_H__

#include <stdio.h>
#include "biquad.h"

typedef struct Biquad_St_ {
  void* dynamMemPtr;    // memory pointer holding the dynamic memory
  size_t dynamMemSize;  // size of the buffer *dynamMemPtr

  // Static Configuration
  Biquad_StaticCfg stCfg;

  // ---------------------------------------------------------------
  // Internal Static Config Registers, which are generated from stCfg
  int maxNSample;
  int nsect;
  float BCoeff[AGORA_UAP_BIQUAD_MAX_SECTION][3];
  float ACoeff[AGORA_UAP_BIQUAD_MAX_SECTION][3];
  float GCoeff[AGORA_UAP_BIQUAD_MAX_SECTION];  // gain for each section

  // Variables
  float* inputTempBuf;  // [maxNSample]
  float sectW[AGORA_UAP_BIQUAD_MAX_SECTION][2];
  // each section's register
  float* sectOutputBuf
      [AGORA_UAP_BIQUAD_MAX_SECTION];  //[AGORA_UAP_BIQUAD_MAX_SECTION][maxNSample]
                                       // each section's output buffer
} Biquad_St;

#endif  // __BIQUAD_ST_H__



================================================
FILE: src/coeff.h
================================================
//
// Copyright © 2025 Agora
// This file is part of TEN Framework, an open source project.
// Licensed under the Apache License, Version 2.0, with certain conditions.
// Refer to the "LICENSE" file in the root directory for more information.
//
#ifndef __COEFF_H__
#define __COEFF_H__

#include "aed_st.h"

#define AUP_AED_MEAN_STD_NBINS AUP_AED_FEA_LEN

#define AUP_AED_ASSUMED_HOPSZ (256)
#define AUP_AED_ASSUMED_WINDOWSZ (768)
#define AUP_AED_ASSUMED_FFTSZ (1024)

// means of inpu-mel-filterbank
const float AUP_AED_FEATURE_MEANS[AUP_AED_MEAN_STD_NBINS] = {
    -8.198236465454e+00f, -6.265716552734e+00f, -5.483818531036e+00f,
    -4.758691310883e+00f, -4.417088985443e+00f, -4.142892837524e+00f,
    -3.912850379944e+00f, -3.845927953720e+00f, -3.657090425491e+00f,
    -3.723418712616e+00f, -3.876134157181e+00f, -3.843890905380e+00f,
    -3.690405130386e+00f, -3.756065845490e+00f, -3.698696136475e+00f,
    -3.650463104248e+00f, -3.700468778610e+00f, -3.567321300507e+00f,
    -3.498900175095e+00f, -3.477807044983e+00f, -3.458816051483e+00f,
    -3.444923877716e+00f, -3.401328563690e+00f, -3.306261301041e+00f,
    -3.278556823730e+00f, -3.233250856400e+00f, -3.198616027832e+00f,
    -3.204526424408e+00f, -3.208798646927e+00f, -3.257838010788e+00f,
    -3.381376743317e+00f, -3.534021377563e+00f, -3.640867948532e+00f,
    -3.726858854294e+00f, -3.773730993271e+00f, -3.804667234421e+00f,
    -3.832901000977e+00f, -3.871120452881e+00f, -3.990592956543e+00f,
    -4.480289459229e+00f, 9.235690307617e+01f};

// stds of input-mel-filterbank
const float AUP_AED_FEATURE_STDS[AUP_AED_MEAN_STD_NBINS] = {
    5.166063785553e+00f, 4.977209568024e+00f, 4.698895931244e+00f,
    4.630621433258e+00f, 4.634347915649e+00f, 4.641156196594e+00f,
    4.640676498413e+00f, 4.666367053986e+00f, 4.650534629822e+00f,
    4.640020847321e+00f, 4.637400150299e+00f, 4.620099067688e+00f,
    4.596316337585e+00f, 4.562654972076e+00f, 4.554360389709e+00f,
    4.566910743713e+00f, 4.562489986420e+00f, 4.562412738800e+00f,
    4.585299491882e+00f, 4.600179672241e+00f, 4.592845916748e+00f,
    4.585922718048e+00f, 4.583496570587e+00f, 4.626092910767e+00f,
    4.626957893372e+00f, 4.626289367676e+00f, 4.637005805969e+00f,
    4.683015823364e+00f, 4.726813793182e+00f, 4.734289646149e+00f,
    4.753227233887e+00f, 4.849722862244e+00f, 4.869434833527e+00f,
    4.884482860565e+00f, 4.921327114105e+00f, 4.959212303162e+00f,
    4.996619224548e+00f, 5.044823646545e+00f, 5.072216987610e+00f,
    5.096439361572e+00f, 1.152136917114e+02f};

const float AUP_AED_STFTWindow_Hann768[768] = {
    0.0000000e+00f, 1.6733041e-05f, 6.6931045e-05f, 1.5059065e-04f,
    2.6770626e-04f, 4.1827004e-04f, 6.0227190e-04f, 8.1969953e-04f,
    1.0705384e-03f, 1.3547717e-03f, 1.6723803e-03f, 2.0233432e-03f,
    2.4076367e-03f, 2.8252351e-03f, 3.2761105e-03f, 3.7602327e-03f,
    4.2775693e-03f, 4.8280857e-03f, 5.4117450e-03f, 6.0285082e-03f,
    6.6783340e-03f, 7.3611788e-03f, 8.0769970e-03f, 8.8257407e-03f,
    9.6073598e-03f, 1.0421802e-02f, 1.1269013e-02f, 1.2148935e-02f,
    1.3061510e-02f, 1.4006678e-02f, 1.4984373e-02f, 1.5994532e-02f,
    1.7037087e-02f, 1.8111967e-02f, 1.9219101e-02f, 2.0358415e-02f,
    2.1529832e-02f, 2.2733274e-02f, 2.3968661e-02f, 2.5235910e-02f,
    2.6534935e-02f, 2.7865651e-02f, 2.9227967e-02f, 3.0621794e-02f,
    3.2047037e-02f, 3.3503601e-02f, 3.4991388e-02f, 3.6510300e-02f,
    3.8060234e-02f, 3.9641086e-02f, 4.1252752e-02f, 4.2895122e-02f,
    4.4568088e-02f, 4.6271536e-02f, 4.8005353e-02f, 4.9769424e-02f,
    5.1563629e-02f, 5.3387849e-02f, 5.5241962e-02f, 5.7125844e-02f,
    5.9039368e-02f, 6.0982406e-02f, 6.2954829e-02f, 6.4956504e-02f,
    6.6987298e-02f, 6.9047074e-02f, 7.1135695e-02f, 7.3253021e-02f,
    7.5398909e-02f, 7.7573217e-02f, 7.9775799e-02f, 8.2006508e-02f,
    8.4265194e-02f, 8.6551706e-02f, 8.8865891e-02f, 9.1207593e-02f,
    9.3576658e-02f, 9.5972925e-02f, 9.8396234e-02f, 1.0084642e-01f,
    1.0332333e-01f, 1.0582679e-01f, 1.0835663e-01f, 1.1091268e-01f,
    1.1349477e-01f, 1.1610274e-01f, 1.1873640e-01f, 1.2139558e-01f,
    1.2408010e-01f, 1.2678978e-01f, 1.2952444e-01f, 1.3228389e-01f,
    1.3506796e-01f, 1.3787646e-01f, 1.4070919e-01f, 1.4356597e-01f,
    1.4644661e-01f, 1.4935091e-01f, 1.5227868e-01f, 1.5522973e-01f,
    1.5820385e-01f, 1.6120085e-01f, 1.6422052e-01f, 1.6726267e-01f,
    1.7032709e-01f, 1.7341358e-01f, 1.7652192e-01f, 1.7965192e-01f,
    1.8280336e-01f, 1.8597603e-01f, 1.8916971e-01f, 1.9238420e-01f,
    1.9561929e-01f, 1.9887474e-01f, 2.0215035e-01f, 2.0544589e-01f,
    2.0876115e-01f, 2.1209590e-01f, 2.1544993e-01f, 2.1882300e-01f,
    2.2221488e-01f, 2.2562536e-01f, 2.2905421e-01f, 2.3250119e-01f,
    2.3596607e-01f, 2.3944863e-01f, 2.4294863e-01f, 2.4646583e-01f,
    2.5000000e-01f, 2.5355090e-01f, 2.5711830e-01f, 2.6070196e-01f,
    2.6430163e-01f, 2.6791708e-01f, 2.7154806e-01f, 2.7519434e-01f,
    2.7885565e-01f, 2.8253178e-01f, 2.8622245e-01f, 2.8992744e-01f,
    2.9364649e-01f, 2.9737934e-01f, 3.0112576e-01f, 3.0488549e-01f,
    3.0865828e-01f, 3.1244388e-01f, 3.1624203e-01f, 3.2005248e-01f,
    3.2387498e-01f, 3.2770926e-01f, 3.3155507e-01f, 3.3541216e-01f,
    3.3928027e-01f, 3.4315913e-01f, 3.4704849e-01f, 3.5094809e-01f,
    3.5485766e-01f, 3.5877695e-01f, 3.6270569e-01f, 3.6664362e-01f,
    3.7059048e-01f, 3.7454600e-01f, 3.7850991e-01f, 3.8248196e-01f,
    3.8646187e-01f, 3.9044938e-01f, 3.9444422e-01f, 3.9844613e-01f,
    4.0245484e-01f, 4.0647007e-01f, 4.1049157e-01f, 4.1451906e-01f,
    4.1855226e-01f, 4.2259092e-01f, 4.2663476e-01f, 4.3068351e-01f,
    4.3473690e-01f, 4.3879466e-01f, 4.4285652e-01f, 4.4692220e-01f,
    4.5099143e-01f, 4.5506394e-01f, 4.5913946e-01f, 4.6321772e-01f,
    4.6729844e-01f, 4.7138134e-01f, 4.7546616e-01f, 4.7955263e-01f,
    4.8364046e-01f, 4.8772939e-01f, 4.9181913e-01f, 4.9590943e-01f,
    5.0000000e-01f, 5.0409057e-01f, 5.0818087e-01f, 5.1227061e-01f,
    5.1635954e-01f, 5.2044737e-01f, 5.2453384e-01f, 5.2861866e-01f,
    5.3270156e-01f, 5.3678228e-01f, 5.4086054e-01f, 5.4493606e-01f,
    5.4900857e-01f, 5.5307780e-01f, 5.5714348e-01f, 5.6120534e-01f,
    5.6526310e-01f, 5.6931649e-01f, 5.7336524e-01f, 5.7740908e-01f,
    5.8144774e-01f, 5.8548094e-01f, 5.8950843e-01f, 5.9352993e-01f,
    5.9754516e-01f, 6.0155387e-01f, 6.0555578e-01f, 6.0955062e-01f,
    6.1353813e-01f, 6.1751804e-01f, 6.2149009e-01f, 6.2545400e-01f,
    6.2940952e-01f, 6.3335638e-01f, 6.3729431e-01f, 6.4122305e-01f,
    6.4514234e-01f, 6.4905191e-01f, 6.5295151e-01f, 6.5684087e-01f,
    6.6071973e-01f, 6.6458784e-01f, 6.6844493e-01f, 6.7229074e-01f,
    6.7612502e-01f, 6.7994752e-01f, 6.8375797e-01f, 6.8755612e-01f,
    6.9134172e-01f, 6.9511451e-01f, 6.9887424e-01f, 7.0262066e-01f,
    7.0635351e-01f, 7.1007256e-01f, 7.1377755e-01f, 7.1746822e-01f,
    7.2114435e-01f, 7.2480566e-01f, 7.2845194e-01f, 7.3208292e-01f,
    7.3569837e-01f, 7.3929804e-01f, 7.4288170e-01f, 7.4644910e-01f,
    7.5000000e-01f, 7.5353417e-01f, 7.5705137e-01f, 7.6055137e-01f,
    7.6403393e-01f, 7.6749881e-01f, 7.7094579e-01f, 7.7437464e-01f,
    7.7778512e-01f, 7.8117700e-01f, 7.8455007e-01f, 7.8790410e-01f,
    7.9123885e-01f, 7.9455411e-01f, 7.9784965e-01f, 8.0112526e-01f,
    8.0438071e-01f, 8.0761580e-01f, 8.1083029e-01f, 8.1402397e-01f,
    8.1719664e-01f, 8.2034808e-01f, 8.2347808e-01f, 8.2658642e-01f,
    8.2967291e-01f, 8.3273733e-01f, 8.3577948e-01f, 8.3879915e-01f,
    8.4179615e-01f, 8.4477027e-01f, 8.4772132e-01f, 8.5064909e-01f,
    8.5355339e-01f, 8.5643403e-01f, 8.5929081e-01f, 8.6212354e-01f,
    8.6493204e-01f, 8.6771611e-01f, 8.7047556e-01f, 8.7321022e-01f,
    8.7591990e-01f, 8.7860442e-01f, 8.8126360e-01f, 8.8389726e-01f,
    8.8650523e-01f, 8.8908732e-01f, 8.9164337e-01f, 8.9417321e-01f,
    8.9667667e-01f, 8.9915358e-01f, 9.0160377e-01f, 9.0402708e-01f,
    9.0642334e-01f, 9.0879241e-01f, 9.1113411e-01f, 9.1344829e-01f,
    9.1573481e-01f, 9.1799349e-01f, 9.2022420e-01f, 9.2242678e-01f,
    9.2460109e-01f, 9.2674698e-01f, 9.2886431e-01f, 9.3095293e-01f,
    9.3301270e-01f, 9.3504350e-01f, 9.3704517e-01f, 9.3901759e-01f,
    9.4096063e-01f, 9.4287416e-01f, 9.4475804e-01f, 9.4661215e-01f,
    9.4843637e-01f, 9.5023058e-01f, 9.5199465e-01f, 9.5372846e-01f,
    9.5543191e-01f, 9.5710488e-01f, 9.5874725e-01f, 9.6035891e-01f,
    9.6193977e-01f, 9.6348970e-01f, 9.6500861e-01f, 9.6649640e-01f,
    9.6795296e-01f, 9.6937821e-01f, 9.7077203e-01f, 9.7213435e-01f,
    9.7346506e-01f, 9.7476409e-01f, 9.7603134e-01f, 9.7726673e-01f,
    9.7847017e-01f, 9.7964159e-01f, 9.8078090e-01f, 9.8188803e-01f,
    9.8296291e-01f, 9.8400547e-01f, 9.8501563e-01f, 9.8599332e-01f,
    9.8693849e-01f, 9.8785107e-01f, 9.8873099e-01f, 9.8957820e-01f,
    9.9039264e-01f, 9.9117426e-01f, 9.9192300e-01f, 9.9263882e-01f,
    9.9332167e-01f, 9.9397149e-01f, 9.9458825e-01f, 9.9517191e-01f,
    9.9572243e-01f, 9.9623977e-01f, 9.9672389e-01f, 9.9717476e-01f,
    9.9759236e-01f, 9.9797666e-01f, 9.9832762e-01f, 9.9864523e-01f,
    9.9892946e-01f, 9.9918030e-01f, 9.9939773e-01f, 9.9958173e-01f,
    9.9973229e-01f, 9.9984941e-01f, 9.9993307e-01f, 9.9998327e-01f,
    1.0000000e+00f, 9.9998327e-01f, 9.9993307e-01f, 9.9984941e-01f,
    9.9973229e-01f, 9.9958173e-01f, 9.9939773e-01f, 9.9918030e-01f,
    9.9892946e-01f, 9.9864523e-01f, 9.9832762e-01f, 9.9797666e-01f,
    9.9759236e-01f, 9.9717476e-01f, 9.9672389e-01f, 9.9623977e-01f,
    9.9572243e-01f, 9.9517191e-01f, 9.9458825e-01f, 9.9397149e-01f,
    9.9332167e-01f, 9.9263882e-01f, 9.9192300e-01f, 9.9117426e-01f,
    9.9039264e-01f, 9.8957820e-01f, 9.8873099e-01f, 9.8785107e-01f,
    9.8693849e-01f, 9.8599332e-01f, 9.8501563e-01f, 9.8400547e-01f,
    9.8296291e-01f, 9.8188803e-01f, 9.8078090e-01f, 9.7964159e-01f,
    9.7847017e-01f, 9.7726673e-01f, 9.7603134e-01f, 9.7476409e-01f,
    9.7346506e-01f, 9.7213435e-01f, 9.7077203e-01f, 9.6937821e-01f,
    9.6795296e-01f, 9.6649640e-01f, 9.6500861e-01f, 9.6348970e-01f,
    9.6193977e-01f, 9.6035891e-01f, 9.5874725e-01f, 9.5710488e-01f,
    9.5543191e-01f, 9.5372846e-01f, 9.5199465e-01f, 9.5023058e-01f,
    9.4843637e-01f, 9.4661215e-01f, 9.4475804e-01f, 9.4287416e-01f,
    9.4096063e-01f, 9.3901759e-01f, 9.3704517e-01f, 9.3504350e-01f,
    9.3301270e-01f, 9.3095293e-01f, 9.2886431e-01f, 9.2674698e-01f,
    9.2460109e-01f, 9.2242678e-01f, 9.2022420e-01f, 9.1799349e-01f,
    9.1573481e-01f, 9.1344829e-01f, 9.1113411e-01f, 9.0879241e-01f,
    9.0642334e-01f, 9.0402708e-01f, 9.0160377e-01f, 8.9915358e-01f,
    8.9667667e-01f, 8.9417321e-01f, 8.9164337e-01f, 8.8908732e-01f,
    8.8650523e-01f, 8.8389726e-01f, 8.8126360e-01f, 8.7860442e-01f,
    8.7591990e-01f, 8.7321022e-01f, 8.7047556e-01f, 8.6771611e-01f,
    8.6493204e-01f, 8.6212354e-01f, 8.5929081e-01f, 8.5643403e-01f,
    8.5355339e-01f, 8.5064909e-01f, 8.4772132e-01f, 8.4477027e-01f,
    8.4179615e-01f, 8.3879915e-01f, 8.3577948e-01f, 8.3273733e-01f,
    8.2967291e-01f, 8.2658642e-01f, 8.2347808e-01f, 8.2034808e-01f,
    8.1719664e-01f, 8.1402397e-01f, 8.1083029e-01f, 8.0761580e-01f,
    8.0438071e-01f, 8.0112526e-01f, 7.9784965e-01f, 7.9455411e-01f,
    7.9123885e-01f, 7.8790410e-01f, 7.8455007e-01f, 7.8117700e-01f,
    7.7778512e-01f, 7.7437464e-01f, 7.7094579e-01f, 7.6749881e-01f,
    7.6403393e-01f, 7.6055137e-01f, 7.5705137e-01f, 7.5353417e-01f,
    7.5000000e-01f, 7.4644910e-01f, 7.4288170e-01f, 7.3929804e-01f,
    7.3569837e-01f, 7.3208292e-01f, 7.2845194e-01f, 7.2480566e-01f,
    7.2114435e-01f, 7.1746822e-01f, 7.1377755e-01f, 7.1007256e-01f,
    7.0635351e-01f, 7.0262066e-01f, 6.9887424e-01f, 6.9511451e-01f,
    6.9134172e-01f, 6.8755612e-01f, 6.8375797e-01f, 6.7994752e-01f,
    6.7612502e-01f, 6.7229074e-01f, 6.6844493e-01f, 6.6458784e-01f,
    6.6071973e-01f, 6.5684087e-01f, 6.5295151e-01f, 6.4905191e-01f,
    6.4514234e-01f, 6.4122305e-01f, 6.3729431e-01f, 6.3335638e-01f,
    6.2940952e-01f, 6.2545400e-01f, 6.2149009e-01f, 6.1751804e-01f,
    6.1353813e-01f, 6.0955062e-01f, 6.0555578e-01f, 6.0155387e-01f,
    5.9754516e-01f, 5.9352993e-01f, 5.8950843e-01f, 5.8548094e-01f,
    5.8144774e-01f, 5.7740908e-01f, 5.7336524e-01f, 5.6931649e-01f,
    5.6526310e-01f, 5.6120534e-01f, 5.5714348e-01f, 5.5307780e-01f,
    5.4900857e-01f, 5.4493606e-01f, 5.4086054e-01f, 5.3678228e-01f,
    5.3270156e-01f, 5.2861866e-01f, 5.2453384e-01f, 5.2044737e-01f,
    5.1635954e-01f, 5.1227061e-01f, 5.0818087e-01f, 5.0409057e-01f,
    5.0000000e-01f, 4.9590943e-01f, 4.9181913e-01f, 4.8772939e-01f,
    4.8364046e-01f, 4.7955263e-01f, 4.7546616e-01f, 4.7138134e-01f,
    4.6729844e-01f, 4.6321772e-01f, 4.5913946e-01f, 4.5506394e-01f,
    4.5099143e-01f, 4.4692220e-01f, 4.4285652e-01f, 4.3879466e-01f,
    4.3473690e-01f, 4.3068351e-01f, 4.2663476e-01f, 4.2259092e-01f,
    4.1855226e-01f, 4.1451906e-01f, 4.1049157e-01f, 4.0647007e-01f,
    4.0245484e-01f, 3.9844613e-01f, 3.9444422e-01f, 3.9044938e-01f,
    3.8646187e-01f, 3.8248196e-01f, 3.7850991e-01f, 3.7454600e-01f,
    3.7059048e-01f, 3.6664362e-01f, 3.6270569e-01f, 3.5877695e-01f,
    3.5485766e-01f, 3.5094809e-01f, 3.4704849e-01f, 3.4315913e-01f,
    3.3928027e-01f, 3.3541216e-01f, 3.3155507e-01f, 3.2770926e-01f,
    3.2387498e-01f, 3.2005248e-01f, 3.1624203e-01f, 3.1244388e-01f,
    3.0865828e-01f, 3.0488549e-01f, 3.0112576e-01f, 2.9737934e-01f,
    2.9364649e-01f, 2.8992744e-01f, 2.8622245e-01f, 2.8253178e-01f,
    2.7885565e-01f, 2.7519434e-01f, 2.7154806e-01f, 2.6791708e-01f,
    2.6430163e-01f, 2.6070196e-01f, 2.5711830e-01f, 2.5355090e-01f,
    2.5000000e-01f, 2.4646583e-01f, 2.4294863e-01f, 2.3944863e-01f,
    2.3596607e-01f, 2.3250119e-01f, 2.2905421e-01f, 2.2562536e-01f,
    2.2221488e-01f, 2.1882300e-01f, 2.1544993e-01f, 2.1209590e-01f,
    2.0876115e-01f, 2.0544589e-01f, 2.0215035e-01f, 1.9887474e-01f,
    1.9561929e-01f, 1.9238420e-01f, 1.8916971e-01f, 1.8597603e-01f,
    1.8280336e-01f, 1.7965192e-01f, 1.7652192e-01f, 1.7341358e-01f,
    1.7032709e-01f, 1.6726267e-01f, 1.6422052e-01f, 1.6120085e-01f,
    1.5820385e-01f, 1.5522973e-01f, 1.5227868e-01f, 1.4935091e-01f,
    1.4644661e-01f, 1.4356597e-01f, 1.4070919e-01f, 1.3787646e-01f,
    1.3506796e-01f, 1.3228389e-01f, 1.2952444e-01f, 1.2678978e-01f,
    1.2408010e-01f, 1.2139558e-01f, 1.1873640e-01f, 1.1610274e-01f,
    1.1349477e-01f, 1.1091268e-01f, 1.0835663e-01f, 1.0582679e-01f,
    1.0332333e-01f, 1.0084642e-01f, 9.8396234e-02f, 9.5972925e-02f,
    9.3576658e-02f, 9.1207593e-02f, 8.8865891e-02f, 8.6551706e-02f,
    8.4265194e-02f, 8.2006508e-02f, 7.9775799e-02f, 7.7573217e-02f,
    7.5398909e-02f, 7.3253021e-02f, 7.1135695e-02f, 6.9047074e-02f,
    6.6987298e-02f, 6.4956504e-02f, 6.2954829e-02f, 6.0982406e-02f,
    5.9039368e-02f, 5.7125844e-02f, 5.5241962e-02f, 5.3387849e-02f,
    5.1563629e-02f, 4.9769424e-02f, 4.8005353e-02f, 4.6271536e-02f,
    4.4568088e-02f, 4.2895122e-02f, 4.1252752e-02f, 3.9641086e-02f,
    3.8060234e-02f, 3.6510300e-02f, 3.4991388e-02f, 3.3503601e-02f,
    3.2047037e-02f, 3.0621794e-02f, 2.9227967e-02f, 2.7865651e-02f,
    2.6534935e-02f, 2.5235910e-02f, 2.3968661e-02f, 2.2733274e-02f,
    2.1529832e-02f, 2.0358415e-02f, 1.9219101e-02f, 1.8111967e-02f,
    1.7037087e-02f, 1.5994532e-02f, 1.4984373e-02f, 1.4006678e-02f,
    1.3061510e-02f, 1.2148935e-02f, 1.1269013e-02f, 1.0421802e-02f,
    9.6073598e-03f, 8.8257407e-03f, 8.0769970e-03f, 7.3611788e-03f,
    6.6783340e-03f, 6.0285082e-03f, 5.4117450e-03f, 4.8280857e-03f,
    4.2775693e-03f, 3.7602327e-03f, 3.2761105e-03f, 2.8252351e-03f,
    2.4076367e-03f, 2.0233432e-03f, 1.6723803e-03f, 1.3547717e-03f,
    1.0705384e-03f, 8.1969953e-04f, 6.0227190e-04f, 4.1827004e-04f,
    2.6770626e-04f, 1.5059065e-04f, 6.6931045e-05f, 1.6733041e-05f};

#endif



================================================
FILE: src/fftw.h
================================================
//
// Copyright © 2025 Agora
// This file is part of TEN Framework, an open source project.
// Licensed under the Apache License, Version 2.0, with certain conditions.
// Refer to the "LICENSE" file in the root directory for more information.
//
#ifndef __FFTW_H__
#define __FFTW_H__

#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
// Spectrum Storage Format definition:
// format1:  [Real-0, Real-Nyq, Real-1, Imag-1, Real-2, Imag-2, ...]
// format2:  [Real-0, Real-1, (-1)*Imag-1, Real-2, (-1)*Imag-2, ..., Real-Nyq]

// the following functions assume input and output spectrum to be stored in
// format2
void AUP_FFTW_r2c_256(float* in, float* out);
void AUP_FFTW_c2r_256(float* in, float* out);

void AUP_FFTW_c2r_512(float* in, float* out);
void AUP_FFTW_r2c_512(float* in, float* out);

void AUP_FFTW_r2c_1024(float* in, float* out);
void AUP_FFTW_c2r_1024(float* in, float* out);

void AUP_FFTW_r2c_2048(float* in, float* out);
void AUP_FFTW_c2r_2048(float* in, float* out);

void AUP_FFTW_r2c_4096(float* in, float* out);
void AUP_FFTW_c2r_4096(float* in, float* out);

// if direction == 0: format1->format2
// if direction == 1: format2->format1
void AUP_FFTW_InplaceTransf(int direction, int fftSz, float* inplaceTranfBuf);

void AUP_FFTW_RescaleFFTOut(int fftSz, float* inplaceBuf);
void AUP_FFTW_RescaleIFFTOut(int fftSz, float* inplaceBuf);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif  // __FFTW_H__



================================================
FILE: src/fscvrt.cc
================================================
//
// Copyright © 2025 Agora
// This file is part of TEN Framework, an open source project.
// Licensed under the Apache License, Version 2.0, with certain conditions.
// Refer to the "LICENSE" file in the root directory for more information.
//
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "fscvrt.h"
#include "fscvrt_st.h"
#include "biquad.h"

// ==========================================================================================
// internal tools
// ==========================================================================================

static int AUP_Fscvrt_FilterSet(int resampleRate, int* nsect,
                                const float* B[_FSCVRT_MAXNSEC],
                                const float* A[_FSCVRT_MAXNSEC],
                                const float** G) {
  int idx;
  if (resampleRate == 2) {
    *nsect = _FSCVRT_1over2_LOWPASS_NSEC;
    for (idx = 0; idx < (*nsect); idx++) {
      B[idx] = &(_FSCVRT_1over2_LOWPASS_B[idx][0]);
      A[idx] = &(_FSCVRT_1over2_LOWPASS_A[idx][0]);
    }
    *G = _FSCVRT_1over2_LOWPASS_G;
  } else if (resampleRate == 3) {
    *nsect = _FSCVRT_1over3_LOWPASS_NSEC;
    for (idx = 0; idx < (*nsect); idx++) {
      B[idx] = &(_FSCVRT_1over3_LOWPASS_B[idx][0]);
      A[idx] = &(_FSCVRT_1over3_LOWPASS_A[idx][0]);
    }
    *G = _FSCVRT_1over3_LOWPASS_G;
  } else if (resampleRate == 4) {
    *nsect = _FSCVRT_1over4_LOWPASS_NSEC;
    for (idx = 0; idx < (*nsect); idx++) {
      B[idx] = &(_FSCVRT_1over4_LOWPASS_B[idx][0]);
      A[idx] = &(_FSCVRT_1over4_LOWPASS_A[idx][0]);
    }
    *G = _FSCVRT_1over4_LOWPASS_G;
  } else if (resampleRate == 6) {
    *nsect = _FSCVRT_1over6_LOWPASS_NSEC;
    for (idx = 0; idx < (*nsect); idx++) {
      B[idx] = &(_FSCVRT_1over6_LOWPASS_B[idx][0]);
      A[idx] = &(_FSCVRT_1over6_LOWPASS_A[idx][0]);
    }
    *G = _FSCVRT_1over6_LOWPASS_G;
  } else {  // unknown resample rate
    return -1;
  }

  return 0;
}

static int AUP_Fscvrt_dynamMemPrepare(FscvrtSt* stHdl, void* memPtrExt,
                                      size_t memSize) {
  char* memPtr = NULL;
  int biquadInBufMemSize = 0;
  int biquadOutBufMemSize = 0;
  int totalMemSize = 0;

  if (stHdl == NULL) {
    return -1;
  }

  biquadInBufMemSize = _FSCVRT_ALIGN8(sizeof(float) * stHdl->biquadInBufLen);
  totalMemSize += biquadInBufMemSize;

  biquadOutBufMemSize = _FSCVRT_ALIGN8(sizeof(float) * stHdl->biquadOutBufLen);
  totalMemSize += biquadOutBufMemSize;

  totalMemSize = _FSCVRT_MAX(totalMemSize, 80);

  // if no external memory provided, we are only profiling the memory
  // requirement
  if (memPtrExt == NULL) {
    return (totalMemSize);
  }

  // if required memory is more than provided, error
  if ((size_t)totalMemSize > memSize) {
    return -1;
  }
  memPtr = (char*)memPtrExt;

  stHdl->biquadInBuf = NULL;
  if (biquadInBufMemSize != 0) {
    stHdl->biquadInBuf = (float*)memPtr;
    memPtr += biquadInBufMemSize;
  }

  stHdl->biquadOutBuf = NULL;
  if (biquadOutBufMemSize != 0) {
    stHdl->biquadOutBuf = (float*)memPtr;
    memPtr += biquadOutBufMemSize;
  }

  if (((int)(memPtr - (char*)memPtrExt)) > totalMemSize) {
    return -1;
  }

  return (totalMemSize);
}

static int AUP_Fscvrt_checkStatCfg(FscvrtStaticCfg* pCfg) {
  if (pCfg == NULL) {
    return -1;
  }

  if (pCfg->inputFs != 16000 && pCfg->inputFs != 24000 &&
      pCfg->inputFs != 32000 && pCfg->inputFs != 48000) {
    return -1;
  }

  if (pCfg->outputFs != 16000 && pCfg->outputFs != 24000 &&
      pCfg->outputFs != 32000 && pCfg->outputFs != 48000) {
    return -1;
  }

  if (pCfg->stepSz > AUP_FSCVRT_MAX_INPUT_LEN || pCfg->stepSz < 1) {
    return -1;
  }

  if (pCfg->inputType != 0) {
    pCfg->inputType = 1;
  }

  if (pCfg->outputType != 0) {
    pCfg->outputType = 1;
  }

  return 0;
}

static int AUP_Fscvrt_publishStaticCfg(FscvrtSt* stHdl) {
  int tmpRatio;
  int ret;
  int maxResmplRate = 0;

  stHdl->mode = 0;
  stHdl->upSmplRate = 1;
  stHdl->downSmplRate = 1;
  if (stHdl->stCfg.inputFs != stHdl->stCfg.outputFs) {
    if (stHdl->stCfg.outputFs > stHdl->stCfg.inputFs) {
      tmpRatio = (stHdl->stCfg.outputFs / stHdl->stCfg.inputFs);
      if (stHdl->stCfg.outputFs == tmpRatio * stHdl->stCfg.inputFs) {
        stHdl->mode = 1;
        stHdl->upSmplRate = tmpRatio;
        stHdl->downSmplRate = 1;
      } else {
        stHdl->mode = 3;
        stHdl->upSmplRate = _FSCVRT_COMMON_FS / stHdl->stCfg.inputFs;
        stHdl->downSmplRate = _FSCVRT_COMMON_FS / stHdl->stCfg.outputFs;
      }
    } else {  // stHdl->stCfg.outputFs < stHdl->stCfg.inputFs
      tmpRatio = (stHdl->stCfg.inputFs / stHdl->stCfg.outputFs);
      if (stHdl->stCfg.inputFs == tmpRatio * stHdl->stCfg.outputFs) {
        stHdl->mode = 2;
        stHdl->upSmplRate = 1;
        stHdl->downSmplRate = tmpRatio;
      } else {
        stHdl->mode = 3;
        stHdl->upSmplRate = _FSCVRT_COMMON_FS / stHdl->stCfg.inputFs;
        stHdl->downSmplRate = _FSCVRT_COMMON_FS / stHdl->stCfg.outputFs;
      }
    }
  }

  if (stHdl->mode == 0) {
    stHdl->biquadInBufLen = 0;
    stHdl->biquadOutBufLen = 0;
  } else {
    stHdl->biquadInBufLen = stHdl->stCfg.stepSz * stHdl->upSmplRate;
    stHdl->biquadOutBufLen = 2 * (stHdl->stCfg.stepSz * stHdl->upSmplRate);
  }

  maxResmplRate = _FSCVRT_MAX(stHdl->upSmplRate, stHdl->downSmplRate);

  stHdl->nSec = 0;
  memset(stHdl->biquadB, 0, sizeof(stHdl->biquadB));
  memset(stHdl->biquadA, 0, sizeof(stHdl->biquadA));
  stHdl->biquadG = NULL;  // gain for each section

  if (stHdl->mode != 0) {
    ret = AUP_Fscvrt_FilterSet(maxResmplRate, &(stHdl->nSec), stHdl->biquadB,
                               stHdl->biquadA, &(stHdl->biquadG));
    if (ret < 0) {
      return -1;
    }
  }

  return 0;
}

static int AUP_Fscvrt_resetVariables(FscvrtSt* stHdl) {
  stHdl->biquadInBufCnt = 0;
  stHdl->biquadOutBufCnt = 0;

  if (stHdl->dynamMemPtr != NULL && stHdl->dynamMemSize > 0) {
    memset(stHdl->dynamMemPtr, 0, stHdl->dynamMemSize);
  }
  return 0;
}

// ==========================================================================================
// public APIs
// ==========================================================================================

int AUP_Fscvrt_create(void** stPtr) {
  FscvrtSt* tmpPtr;

  if (stPtr == NULL) {
    return -1;
  }
  *stPtr = (void*)malloc(sizeof(FscvrtSt));
  if (*stPtr == NULL) {
    return -1;
  }
  memset(*stPtr, 0, sizeof(FscvrtSt));

  tmpPtr = (FscvrtSt*)(*stPtr);

  tmpPtr->dynamMemPtr = NULL;
  tmpPtr->dynamMemSize = 0;

  tmpPtr->stCfg.inputFs = 24000;
  tmpPtr->stCfg.outputFs = 32000;
  tmpPtr->stCfg.stepSz = 240;    // 10ms processing step
  tmpPtr->stCfg.inputType = 0;   // short in
  tmpPtr->stCfg.outputType = 0;  // short out

  if (AUP_Biquad_create(&(tmpPtr->biquadSt)) < 0) {
    return -1;
  }

  return 0;
}

int AUP_Fscvrt_destroy(void** stPtr) {
  FscvrtSt* stHdl;

  if (stPtr == NULL) {
    return 0;
  }

  stHdl = (FscvrtSt*)(*stPtr);
  if (stHdl == NULL) {
    return 0;
  }

  AUP_Biquad_destroy(&(stHdl->biquadSt));
  if (stHdl->dynamMemPtr != NULL) {
    free(stHdl->dynamMemPtr);
  }
  stHdl->dynamMemPtr = NULL;

  free(stHdl);
  (*stPtr) = NULL;

  return 0;
}

int AUP_Fscvrt_memAllocate(void* stPtr, const FscvrtStaticCfg* pCfg) {
  FscvrtSt* stHdl = NULL;
  FscvrtStaticCfg tmpStatCfg = {0};
  Biquad_StaticCfg bqStatCfg;
  int idx, ret;
  int totalMemSize = 0;

  if (stPtr == NULL || pCfg == NULL) {
    return -1;
  }
  stHdl = (FscvrtSt*)(stPtr);

  memcpy(&tmpStatCfg, pCfg, sizeof(FscvrtStaticCfg));
  if (AUP_Fscvrt_checkStatCfg(&tmpStatCfg) < 0) {
    return -1;
  }
  memcpy(&(stHdl->stCfg), &tmpStatCfg, sizeof(FscvrtStaticCfg));

  if (AUP_Fscvrt_publishStaticCfg(stHdl) < 0) {
    return -1;
  }

  // check memory requirement
  totalMemSize = AUP_Fscvrt_dynamMemPrepare(stHdl, NULL, 0);
  if (totalMemSize < 0) {
    return -1;
  }

  // allocate dynamic memory
  if ((size_t)totalMemSize > stHdl->dynamMemSize) {
    if (stHdl->dynamMemPtr != NULL) {
      free(stHdl->dynamMemPtr);
      stHdl->dynamMemSize = 0;
    }
    stHdl->dynamMemPtr = (void*)malloc(totalMemSize);
    if (stHdl->dynamMemPtr == NULL) {
      return -1;
    }
    stHdl->dynamMemSize = totalMemSize;
  }
  memset(stHdl->dynamMemPtr, 0, stHdl->dynamMemSize);

  // setup the pointers/variable
  if (AUP_Fscvrt_dynamMemPrepare(stHdl, stHdl->dynamMemPtr,
                                 stHdl->dynamMemSize) < 0) {
    return -1;
  }

  // memAllocation for upSmplBiquadSt and downSmplBiquadSt
  if (stHdl->nSec != 0) {
    if (stHdl->nSec > AGORA_UAP_BIQUAD_MAX_SECTION) {
      return -1;
    }
    memset(&bqStatCfg, 0, sizeof(Biquad_StaticCfg));
    bqStatCfg.maxNSample = (size_t)(stHdl->biquadInBufLen);
    bqStatCfg.nsect = stHdl->nSec;
    for (idx = 0; idx < stHdl->nSec; idx++) {
      bqStatCfg.B[idx] = stHdl->biquadB[idx];
      bqStatCfg.A[idx] = stHdl->biquadA[idx];
    }
    bqStatCfg.G = stHdl->biquadG;

    ret = AUP_Biquad_memAllocate(stHdl->biquadSt, &bqStatCfg);
    if (ret < 0) {
      return -1;
    }
  }

  return 0;
}

int AUP_Fscvrt_init(void* stPtr) {
  FscvrtSt* stHdl;

  if (stPtr == NULL) {
    return -1;
  }
  stHdl = (FscvrtSt*)(stPtr);

  // clear/reset run-time variables
  if (AUP_Fscvrt_resetVariables(stHdl) < 0) {
    return -1;
  }

  // init submodules ...
  if (stHdl->biquadSt != NULL && stHdl->nSec != 0) {
    if (AUP_Biquad_init(stHdl->biquadSt) < 0) {
      return -1;
    }
  }

  return 0;
}

int AUP_Fscvrt_getStaticCfg(const void* stPtr, FscvrtStaticCfg* pCfg) {
  const FscvrtSt* stHdl;

  if (stPtr == NULL || pCfg == NULL) {
    return -1;
  }
  stHdl = (const FscvrtSt*)(stPtr);

  memcpy(pCfg, &(stHdl->stCfg), sizeof(FscvrtStaticCfg));

  return 0;
}

int AUP_Fscvrt_getInfor(const void* stPtr, FscvrtGetData* buff) {
  const FscvrtSt* stHdl;
  int delayBiquad = 0;
  int tmp;

  if (stPtr == NULL || buff == NULL) {
    return -1;
  }
  stHdl = (const FscvrtSt*)(stPtr);

  if (stHdl->nSec != 0) {
    if (AUP_Biquad_getAlgDelay(stHdl->biquadSt, &delayBiquad) < 0) {
      return -1;
    }
  }

  if (stHdl->mode == 0) {
    buff->delayInInputFs = 0;
  } else if (stHdl->mode == 1) {
    buff->delayInInputFs =
        (int)roundf(delayBiquad / (float)(stHdl->upSmplRate));
  } else if (stHdl->mode == 2) {  // direct downsampling
    buff->delayInInputFs = delayBiquad;
  } else {  // stHdl->mode == 3
    buff->delayInInputFs =
        (int)roundf(delayBiquad / (float)(stHdl->upSmplRate));
  }
  tmp = stHdl->stCfg.stepSz * stHdl->upSmplRate / stHdl->downSmplRate;
  if (tmp * stHdl->downSmplRate == stHdl->stCfg.stepSz * stHdl->upSmplRate) {
    buff->maxOutputStepSz = tmp;
  } else {
    buff->maxOutputStepSz = tmp + 1;
  }

  return 0;
}

int AUP_Fscvrt_proc(void* stPtr, const FscvrtInData* pIn, FscvrtOutData* pOut) {
  FscvrtSt* stHdl = NULL;
  const FscvrtStaticCfg* pCfg;
  Biquad_InputData bqdInData;
  Biquad_OutputData bqdOutData;
  const short* shortSrcPtr = NULL;
  const float* floatSrcPtr = NULL;
  short* shortTgtPtr = NULL;
  float* floatTgtPtr = NULL;
  int idx, tgtIdx;
  int nOutSamples = 0, samplesTaken = 0, samplesLeft = 0;
  int jumpRate;

  if (stPtr == NULL || pIn == NULL || pOut == NULL || pIn->inDataSeq == NULL ||
      pOut->outDataSeq == NULL) {  //  pCtrl == NULL
    return -1;
  }

  stHdl = (FscvrtSt*)(stPtr);
  pCfg = (const FscvrtStaticCfg*)&(stHdl->stCfg);
  shortSrcPtr = (const short*)(pIn->inDataSeq);
  floatSrcPtr = (const float*)(pIn->inDataSeq);
  // ==============================================================================
  // mode-0: bypass
  if (stHdl->mode == 0) {  // direct bypass
    if (pIn->outDataSeqLen < pCfg->stepSz) {
      return -1;
    }
    pOut->nOutData = pCfg->stepSz;
    pOut->outDataType = pCfg->outputType;
    if (pIn->inDataSeq == pOut->outDataSeq) {
      if (pCfg->outputType == pCfg->inputType)
        return 0;  // we don't need to do anything
      return -1;
      // if input buffer and the output buffer are the same, but required
      // different data type: error, we currently do not support such usecase
    }

    if (pCfg->inputType == 0 && pCfg->outputType == 0) {
      memcpy(pOut->outDataSeq, pIn->inDataSeq, sizeof(short) * pCfg->stepSz);
    } else if (pCfg->inputType == 1 && pCfg->outputType == 1) {
      memcpy(pOut->outDataSeq, pIn->inDataSeq, sizeof(float) * pCfg->stepSz);
    } else if (pCfg->inputType == 0 && pCfg->outputType == 1) {
      for (idx = 0; idx < pCfg->stepSz; idx++) {
        ((float*)pOut->outDataSeq)[idx] = ((short*)pIn->inDataSeq)[idx];
      }
    } else {  // if (pCfg->inputType == 1 && pCfg->outputType == 0)
      for (idx = 0; idx < pCfg->stepSz; idx++) {
        ((short*)pOut->outDataSeq)[idx] =
            (short)_FSCVRT_FLOAT2SHORT(((float*)pIn->inDataSeq)[idx]);
      }
    }

    return 0;
  }

  // prepare input buffer for Biquad .....
  memset(stHdl->biquadInBuf, 0, sizeof(float) * stHdl->biquadInBufLen);
  if (pCfg->inputType == 0) {
    for (idx = 0; idx < pCfg->stepSz; idx++) {
      stHdl->biquadInBuf[idx * (stHdl->upSmplRate)] =
          ((float)shortSrcPtr[idx]) * stHdl->upSmplRate;
    }
  } else {
    for (idx = 0; idx < pCfg->stepSz; idx++) {
      stHdl->biquadInBuf[idx * (stHdl->upSmplRate)] =
          floatSrcPtr[idx] * stHdl->upSmplRate;
    }
  }

  // biquad filtering ......
  memset(&bqdInData, 0, sizeof(Biquad_InputData));
  memset(&bqdOutData, 0, sizeof(Biquad_OutputData));
  bqdInData.samplesPtr = (const void*)(stHdl->biquadInBuf);
  bqdInData.sampleType = 1;
  bqdInData.nsamples = (size_t)(pCfg->stepSz * stHdl->upSmplRate);
  bqdOutData.outputBuff = (void*)&(stHdl->biquadOutBuf[stHdl->biquadOutBufCnt]);
  if (stHdl->biquadOutBufCnt + (pCfg->stepSz * stHdl->upSmplRate) >
      stHdl->biquadOutBufLen) {
    return -1;
  }
  if (AUP_Biquad_proc(stHdl->biquadSt, &bqdInData, &bqdOutData) < 0) {
    return -1;
  }
  stHdl->biquadOutBufCnt += (pCfg->stepSz * stHdl->upSmplRate);

  // checking the output buffer .........
  nOutSamples = stHdl->biquadOutBufCnt / stHdl->downSmplRate;
  if (pIn->outDataSeqLen < nOutSamples) {
    return -1;
  }

  // prepare output data, downsampling and throwing out ......
  pOut->nOutData = nOutSamples;
  pOut->outDataType = pCfg->outputType;

  shortTgtPtr = (short*)pOut->outDataSeq;
  floatTgtPtr = (float*)pOut->outDataSeq;
  jumpRate = stHdl->downSmplRate;
  if (pCfg->outputType == 0) {  // -> shortTgtPtr
    for (idx = (jumpRate - 1), tgtIdx = 0; idx < stHdl->biquadOutBufCnt;
         idx += jumpRate, tgtIdx++) {
      shortTgtPtr[tgtIdx] = _FSCVRT_FLOAT2SHORT(stHdl->biquadOutBuf[idx]);
    }
  } else {  // -> floatTgtPtr
    for (idx = (jumpRate - 1), tgtIdx = 0; idx < stHdl->biquadOutBufCnt;
         idx += jumpRate, tgtIdx++) {
      floatTgtPtr[tgtIdx] = stHdl->biquadOutBuf[idx];
    }
  }
  if (nOutSamples != tgtIdx) {
    return -1;
  }

  // update the stHdl->biquadOutBuf and stHdl->biquadOutBufCnt
  samplesTaken = nOutSamples * jumpRate;
  samplesLeft = stHdl->biquadOutBufCnt - samplesTaken;
  if (samplesLeft == 0) {
    stHdl->biquadOutBufCnt = 0;
  } else if (samplesLeft > 0) {
    stHdl->biquadOutBufCnt = samplesLeft;
    memmove(stHdl->biquadOutBuf, &(stHdl->biquadOutBuf[samplesTaken]),
            sizeof(float) * samplesLeft);
  } else {  // samplesLeft < 0
    stHdl->biquadOutBufCnt = 0;
    return -1;
  }

  return 0;
}



================================================
FILE: src/fscvrt.h
================================================
//
// Copyright © 2025 Agora
// This file is part of TEN Framework, an open source project.
// Licensed under the Apache License, Version 2.0, with certain conditions.
// Refer to the "LICENSE" file in the root directory for more information.
//
#ifndef __FSCVRT_H__
#define __FSCVRT_H__

#define AUP_FSCVRT_MAX_INPUT_LEN (2400)
// max. number of samples each time can be fed in

#include <stdio.h>

typedef struct FscvrtStaticCfg_ {
  int inputFs;     // input stream sampling freq.
  int outputFs;    // output stream sampling freq.
  int stepSz;      // number of input samples per each proc.
  int inputType;   // input data type, 0: short, 1: float
  int outputType;  // output data type, 0: short, 1: float
} FscvrtStaticCfg;

typedef struct FscvrtInData_ {
  const void* inDataSeq;  // [stepSz], externally provided buffer
  int outDataSeqLen;
  // the length of externally provided buffer outDataSeq in OutData
} FscvrtInData;

typedef struct FscvrtOutData_ {
  int nOutData;  // number of samples in outDataSeq
  // this value may vary by +-1 from frame-to-frame
  // and the user needs to check if nOutData <= outDataSeqLen
  // o.w. the buffer outDataSeq is not long enough
  int outDataType;   // output data type, 0: short, 1: float
  void* outDataSeq;  // [outDataSeqLen], externally provided buffer
} FscvrtOutData;

typedef struct FscvrtGetData_ {
  int maxOutputStepSz;  // max. number of output samples per each proc.
  int delayInInputFs;   // algorithm delay in terms of samples @ input fs
} FscvrtGetData;

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************
 * AUP_Fscvrt_create(...)
 *
 * This function creats a state handler from nothing, which is NOT ready for
 * processing
 *
 * Input:
 *
 * Output:
 *      - stPtr         : buffer to store the returned state handler
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Fscvrt_create(void** stPtr);

/****************************************************************************
 * AUP_Fscvrt_destroy(...)
 *
 * destroy biquad instance, and releasing all the dynamically allocated memory
 *
 * Input:
 *      - stPtr         : buffer of State Handler, after this method, this
 *                        handler won't be usable anymore
 *
 * Output:
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Fscvrt_destroy(void** stPtr);

/****************************************************************************
 * AUP_Fscvrt_memAllocate(...)
 *
 * This function sets Static Config params and does memory allocation
 * operation
 *
 * Input:
 *      - stPtr         : State Handler which was returned by _create
 *      - pCfg          : static configuration parameters
 *
 * Output:
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Fscvrt_memAllocate(void* stPtr, const FscvrtStaticCfg* pCfg);

/****************************************************************************
 * AUP_Fscvrt_init(...)
 *
 * This function resets (initialize) the XXXX module and gets it prepared for
 * processing
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate
 *
 * Output:
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Fscvrt_init(void* stPtr);

/****************************************************************************
 * AUP_Fscvrt_setDynamCfg(...)
 *
 * This function set dynamic (per-frame variable) configuration
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate
 *      - pCfg          : configuration content
 *
 * Output:
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Fscvrt_setDynamCfg(void* stPtr);

/****************************************************************************
 * AUP_Fscvrt_getStaticCfg(...)
 *
 * This function get static configuration status from XXXXX module
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate
 *
 * Output:
 *      - pCfg          : configuration content
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Fscvrt_getStaticCfg(const void* stPtr, FscvrtStaticCfg* pCfg);

/****************************************************************************
 * AUP_Fscvrt_getInfor(...)
 *
 * This function get subsidiary information from Fs-Converter module
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate
 *
 * Output:
 *      - FscvrtGetData : returned information
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Fscvrt_getInfor(const void* stPtr, FscvrtGetData* buff);

/****************************************************************************
 * AUP_Fscvrt_proc(...)
 *
 * process a single frame
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate
 *      - pCtrl         : per-frame variable control parameters
 *      - pIn           : input data stream
 *
 * Output:
 *      - pOut          : output data (mask, highband time-domain gain etc.)
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Fscvrt_proc(void* stPtr, const FscvrtInData* pIn, FscvrtOutData* pOut);

#ifdef __cplusplus
}
#endif
#endif  // __FSCVRT_H__



================================================
FILE: src/fscvrt_st.h
================================================
//
// Copyright © 2025 Agora
// This file is part of TEN Framework, an open source project.
// Licensed under the Apache License, Version 2.0, with certain conditions.
// Refer to the "LICENSE" file in the root directory for more information.
//
#ifndef __FSCVRT_ST_H__
#define __FSCVRT_ST_H__

#include <stdio.h>

#include "fscvrt.h"

#define _FSCVRT_MAXNSEC (40)
#define _FSCVRT_COMMON_FS (96000)
#define _FSCVRT_ALIGN8(o) (((o) + 7) & (~7))
#define _FSCVRT_FLOAT2SHORT(x) \
  ((x) < -32767.5f ? -32768 : ((x) > 32766.5f ? 32767 : (short)floor(.5 + (x))))
#define _FSCVRT_MIN(x, y) ((x > y) ? (y) : (x))
#define _FSCVRT_MAX(x, y) ((x > y) ? (x) : (y))

#define _FSCVRT_1over2_LOWPASS_NSEC (5)
static const float _FSCVRT_1over2_LOWPASS_B[_FSCVRT_1over2_LOWPASS_NSEC][3] = {
    {1.000000e+00f, 1.830863e+00f, 1.000000e+00f},
    {1.000000e+00f, 1.039654e+00f, 1.000000e+00f},
    {1.000000e+00f, 4.900788e-01f, 1.000000e+00f},
    {1.000000e+00f, 2.419292e-01f, 1.000000e+00f},
    {1.000000e+00f, 1.517919e-01f, 1.000000e+00f}};
static const float _FSCVRT_1over2_LOWPASS_A[_FSCVRT_1over2_LOWPASS_NSEC][3] = {
    {1.000000e+00f, -8.445478e-01f, 2.453003e-01f},
    {1.000000e+00f, -5.469711e-01f, 5.010509e-01f},
    {1.000000e+00f, -2.646897e-01f, 7.464574e-01f},
    {1.000000e+00f, -1.074159e-01f, 8.912371e-01f},
    {1.000000e+00f, -4.448528e-02f, 9.702184e-01f}};
static const float _FSCVRT_1over2_LOWPASS_G[_FSCVRT_1over2_LOWPASS_NSEC] = {
    // 4.184914e-01f,4.184914e-01f,4.184914e-01f,4.184914e-01f,4.184914e-01f
    4.233410e-01f, 4.233410e-01f, 4.233410e-01f, 4.233410e-01f, 4.233410e-01f};

#define _FSCVRT_1over3_LOWPASS_NSEC (5)
static const float _FSCVRT_1over3_LOWPASS_B[_FSCVRT_1over3_LOWPASS_NSEC][3] = {
    {1.000000e+00f, 1.535971e+00f, 1.000000e+00f},
    {1.000000e+00f, 6.284728e-02f, 1.000000e+00f},
    {1.000000e+00f, -5.726159e-01f, 1.000000e+00f},
    {1.000000e+00f, -7.990919e-01f, 1.000000e+00f},
    {1.000000e+00f, -8.741772e-01f, 1.000000e+00f}};
static const float _FSCVRT_1over3_LOWPASS_A[_FSCVRT_1over3_LOWPASS_NSEC][3] = {
    {1.000000e+00f, -1.261229e+00f, 4.351921e-01f},
    {1.000000e+00f, -1.171732e+00f, 6.072938e-01f},
    {1.000000e+00f, -1.078980e+00f, 7.901941e-01f},
    {1.000000e+00f, -1.026436e+00f, 9.073955e-01f},
    {1.000000e+00f, -1.013524e+00f, 9.743813e-01f}};
static const float _FSCVRT_1over3_LOWPASS_G[_FSCVRT_1over3_LOWPASS_NSEC] = {
    // 3.126979e-01f,3.126979e-01f,3.126979e-01f,3.126979e-01f,3.126979e-01f
    3.1704682e-01f, 3.1704682e-01f, 3.1704682e-01f, 3.1704682e-01f,
    3.1704682e-01f};

#define _FSCVRT_1over4_LOWPASS_NSEC (5)
static const float _FSCVRT_1over4_LOWPASS_B[_FSCVRT_1over4_LOWPASS_NSEC][3] = {
    {1.000000e+00f, 1.193034e+00f, 1.000000e+00f},
    {1.000000e+00f, -5.757392e-01f, 1.000000e+00f},
    {1.000000e+00f, -1.105338e+00f, 1.000000e+00f},
    {1.000000e+00f, -1.271233e+00f, 1.000000e+00f},
    {1.000000e+00f, -1.323929e+00f, 1.000000e+00f}};
static const float _FSCVRT_1over4_LOWPASS_A[_FSCVRT_1over4_LOWPASS_NSEC][3] = {
    {1.000000e+00f, -1.447526e+00f, 5.478735e-01f},
    {1.000000e+00f, -1.429707e+00f, 6.830356e-01f},
    {1.000000e+00f, -1.412017e+00f, 8.292100e-01f},
    {1.000000e+00f, -1.405145e+00f, 9.242718e-01f},
    {1.000000e+00f, -1.412679e+00f, 9.790443e-01f}};
static const float _FSCVRT_1over4_LOWPASS_G[_FSCVRT_1over4_LOWPASS_NSEC] = {
    // 2.700060e-01f,2.700060e-01f,2.700060e-01f,2.700060e-01f,2.700060e-01f
    2.7502688e-01f, 2.7502688e-01f, 2.7502688e-01f, 2.7502688e-01f,
    2.7502688e-01f};

#define _FSCVRT_1over6_LOWPASS_NSEC (5)
static const float _FSCVRT_1over6_LOWPASS_B[_FSCVRT_1over6_LOWPASS_NSEC][3] = {
    {1.000000e+00f, 4.149228e-01f, 1.000000e+00f},
    {1.000000e+00f, -1.285358e+00f, 1.000000e+00f},
    {1.000000e+00f, -1.583012e+00f, 1.000000e+00f},
    {1.000000e+00f, -1.663823e+00f, 1.000000e+00f},
    {1.000000e+00f, -1.688104e+00f, 1.000000e+00f}};
static const float _FSCVRT_1over6_LOWPASS_A[_FSCVRT_1over6_LOWPASS_NSEC][3] = {
    {1.000000e+00f, -1.688731e+00f, 7.264798e-01f},
    {1.000000e+00f, -1.696982e+00f, 8.146896e-01f},
    {1.000000e+00f, -1.706117e+00f, 9.049889e-01f},
    {1.000000e+00f, -1.713737e+00f, 9.598250e-01f},
    {1.000000e+00f, -1.723161e+00f, 9.892408e-01f}};
static const float _FSCVRT_1over6_LOWPASS_G[_FSCVRT_1over6_LOWPASS_NSEC] = {
    // 2.333130e-01f,2.333130e-01f,2.333130e-01f,2.333130e-01f,2.333130e-01f
    2.3765156e-01f, 2.3765156e-01f, 2.3765156e-01f, 2.3765156e-01f,
    2.3765156e-01f};

typedef struct FscvrtSt_ {
  void* dynamMemPtr;    // memory pointer holding the dynamic memory
  size_t dynamMemSize;  // size of the buffer *dynamMemPtr

  // Static Configuration
  FscvrtStaticCfg stCfg;

  // Internal Static Config Registers, which are generated from stCfg
  int mode;
  // 0: direct bypass, 1: direct upsampling, 2: direct downsampling
  // 3: upsampling->downsampling
  int upSmplRate;
  int downSmplRate;
  int biquadInBufLen;   // biquad input buffer length
  int biquadOutBufLen;  // biquad output buffer length

  int nSec;
  const float* biquadB[_FSCVRT_MAXNSEC];
  const float* biquadA[_FSCVRT_MAXNSEC];
  const float* biquadG;  // gain for each section

  // ---------------------------------------------------------------
  // Variables
  void* biquadSt;  // biqua filter state handler
  int biquadInBufCnt;
  float* biquadInBuf;  // [biquadInBufLen]
  int biquadOutBufCnt;
  float* biquadOutBuf;  // [biquadOutBufLen]
} FscvrtSt;

#endif  // __FSCVRT_ST_H__



================================================
FILE: src/pitch_est.cc
================================================
//
// Copyright © 2025 Agora
// This file is part of TEN Framework, an open source project.
// Licensed under the Apache License, Version 2.0, with certain conditions.
// Refer to the "LICENSE" file in the root directory for more information.
//
// This file contains modified code derived from LPCNet (https://github.com/mozilla/LPCNet),
// specifically from the following functions:
//   - compute_frame_features() in lpcnet_enc.c
//   - process_superframe() in lpcnet_enc.c
//
// Original lpcnet_enc.c code LICENSE Text, licensed under the BSD-2-Clause License:
//   Copyright (c) 2017-2019 Mozilla
//
//   Redistribution and use in source and binary forms, with or without modification,
//   are permitted provided that the following conditions are met:
//
//   - Redistributions of source code must retain the above copyright notice, 
//     this list of conditions and the following disclaimer.
//
//   - Redistributions in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
//   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR
//   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
//   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
//   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
//   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//
// Original LPCNet LICENSE Text, licensed under the BSD-3-Clause License:
//   Copyright (c) 2017-2018, Mozilla
//   Copyright (c) 2007-2017, Jean-Marc Valin
//   Copyright (c) 2005-2017, Xiph.Org Foundation
//   Copyright (c) 2003-2004, Mark Borgerding
//
//   Redistribution and use in source and binary forms, with or without
//   modification, are permitted provided that the following conditions
//   are met:
//
//   - Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//
//   - Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  
//   - Neither the name of the Xiph.Org Foundation nor the names of its
//     contributors may be used to endorse or promote products derived from
//     this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
//  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION
//  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
//  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//   

#include <assert.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "biquad.h"
#include "pitch_est.h"
#include "pitch_est_st.h"
#include "fftw.h"

// ==========================================================================================
// internal tools
// ==========================================================================================

static int AUP_PE_checkStatCfg(PE_StaticCfg* pCfg) {
  if (pCfg == NULL) {
    return -1;
  }

  if (pCfg->fftSz != 256 && pCfg->fftSz != 512 && pCfg->fftSz != 1024) {
    return -1;
  }
  if (pCfg->fftSz > AUP_PE_MAX_FFTSIZE) {
    return -1;
  }
  if (pCfg->anaWindowSz > pCfg->fftSz || pCfg->anaWindowSz < pCfg->hopSz) {
    return -1;
  }
  if (pCfg->hopSz != 64 && pCfg->hopSz != 80 && pCfg->hopSz != 128 &&
      pCfg->hopSz != 160 && pCfg->hopSz != 256 && pCfg->hopSz != 512) {
    return -1;
  }

  if (pCfg->useLPCPreFiltering != 0) {
    pCfg->useLPCPreFiltering = 1;
  }

  if (pCfg->procFs != 2000 && pCfg->procFs != 4000 && pCfg->procFs != 8000 &&
      pCfg->procFs != 16000) {
    pCfg->procFs = 4000;
  }

  return 0;
}

static int AUP_PE_checkDynamCfg(PE_DynamCfg* pCfg) {
  if (pCfg == NULL) {
    return -1;
  }

  pCfg->voicedThr = AUP_PE_MIN(2.0f, AUP_PE_MAX(pCfg->voicedThr, -1.0f));

  return 0;
}

static int AUP_PE_publishStaticCfg(PE_St* stHdl) {
  const PE_StaticCfg* pStatCfg;
  int idx, jdx;
  int hopSz;
  int excBufShiftLen;

  if (stHdl == NULL) {
    return -1;
  }
  pStatCfg = (const PE_StaticCfg*)(&(stHdl->stCfg));
  hopSz = (int)pStatCfg->hopSz;

  stHdl->nBins = ((int)(pStatCfg->fftSz >> 1)) + 1;
  stHdl->procResampleRate = AUP_PE_FS / (int)pStatCfg->procFs;
  stHdl->minPeriod = AUP_PE_MIN_PERIOD_16KHZ / stHdl->procResampleRate;
  stHdl->maxPeriod = AUP_PE_MAX_PERIOD_16KHZ / stHdl->procResampleRate;
  stHdl->difPeriod = stHdl->maxPeriod - stHdl->minPeriod;
  stHdl->inputResampleBufLen = hopSz * 2;  // give it a max. value
  stHdl->inputQLen = AUP_PE_MAX(AUP_PE_XCORR_TRAINING_OFFSET, hopSz) + hopSz;

  excBufShiftLen = (int)ceilf(hopSz / (float)stHdl->procResampleRate);
  stHdl->excBufLen = stHdl->maxPeriod + excBufShiftLen + 1;

  stHdl->nFeat = (int)ceilf(AUP_PE_FEAT_TIME_WINDOW * AUP_PE_FS /
                            ((float)hopSz * 1000.0f));
  stHdl->nFeat = AUP_PE_MIN(stHdl->nFeat, AUP_PE_FEAT_MAX_NFRM);
  stHdl->estDelay = 0;

  // publish DCT-table coeff.
  for (idx = 0; idx < AUP_PE_NB_BANDS; idx++) {
    for (jdx = 0; jdx < AUP_PE_NB_BANDS; jdx++) {
      stHdl->dct_table[idx * AUP_PE_NB_BANDS + jdx] =
          cosf((idx + .5f) * jdx * AUP_PE_PI / AUP_PE_NB_BANDS);
      if (jdx == 0) stHdl->dct_table[idx * AUP_PE_NB_BANDS + jdx] *= sqrtf(.5f);
    }
  }

  return 0;
}

static int AUP_PE_resetVariables(PE_St* stHdl) {
  // int nBins;
  int idx;

  memset(stHdl->dynamMemPtr, 0, stHdl->dynamMemSize);

  stHdl->inputResampleBufIdx = 0;

  for (idx = 0; idx < AUP_PE_LPC_ORDER; idx++) {
    stHdl->lpc[idx] = 0;
    stHdl->pitch_mem[idx] = 0;
  }
  stHdl->pitch_filt = 0;

  memset(stHdl->tmpFeat, 0, sizeof(stHdl->tmpFeat));

  stHdl->xCorrOffsetIdx = 0;
  for (idx = 0; idx < (AUP_PE_FEAT_MAX_NFRM * 2); idx++) {
    stHdl->frmWeight[idx] = 0;
    stHdl->frmWeightNorm[idx] = 0;
  }

  stHdl->pitchMaxPathAll = 0;
  stHdl->bestPeriodEst = 0;

  stHdl->voiced = 0;
  stHdl->pitchEstResult = 0;  // label as no speech

  if (stHdl->procResampleRate != 1) {
    if (AUP_Biquad_init(stHdl->biquadIIRPtr) < 0) {
      return -1;
    }
  }

  return 0;
}

static int AUP_PE_dynamMemPrepare(PE_St* stHdl, void* memPtrExt,
                                  size_t memSize) {
  int idx;

  int inputResampleBufMemSize = 0;
  int inputQMemSize = 0;
  int alignedInMemSize = 0;
  int lpcFilterOutBufMemSize = 0;
  int excBufMemSize = 0;
  int excBufSqMemSize = 0;
  int xCorrInstMemSize = 0;
  int xCorrPerFeatMemSize = 0;
  int xCorrPerFeatTmpMemSize = 0;
  int pitchMaxPathRegPerRegMemSize = 0;
  int pitchPrevPerFeatMemSize = 0;
  int totalMemSize = 0;
  char* memPtr = NULL;

  inputResampleBufMemSize =
      AUP_PE_ALIGN8(sizeof(float) * stHdl->inputResampleBufLen);
  totalMemSize += inputResampleBufMemSize;

  inputQMemSize = AUP_PE_ALIGN8(sizeof(float) * stHdl->inputQLen);
  totalMemSize += inputQMemSize;

  alignedInMemSize = AUP_PE_ALIGN8(sizeof(float) * stHdl->stCfg.hopSz);
  totalMemSize += alignedInMemSize;

  lpcFilterOutBufMemSize = AUP_PE_ALIGN8(sizeof(float) * stHdl->stCfg.hopSz);
  totalMemSize += lpcFilterOutBufMemSize;

  excBufMemSize = AUP_PE_ALIGN8(sizeof(float) * stHdl->excBufLen);
  totalMemSize += excBufMemSize;
  excBufSqMemSize = excBufMemSize;
  totalMemSize += excBufSqMemSize;

  xCorrInstMemSize = AUP_PE_ALIGN8(sizeof(float) * (stHdl->maxPeriod));
  totalMemSize += xCorrInstMemSize;

  xCorrPerFeatMemSize = AUP_PE_ALIGN8(sizeof(float) * (stHdl->maxPeriod + 1));
  xCorrPerFeatTmpMemSize = xCorrPerFeatMemSize;
  totalMemSize +=
      (xCorrPerFeatMemSize + xCorrPerFeatTmpMemSize) * (stHdl->nFeat * 2);

  pitchMaxPathRegPerRegMemSize =
      AUP_PE_ALIGN8(sizeof(float) * (stHdl->maxPeriod));
  totalMemSize += pitchMaxPathRegPerRegMemSize * 2;

  pitchPrevPerFeatMemSize = AUP_PE_ALIGN8(sizeof(int) * (stHdl->maxPeriod));
  totalMemSize += pitchPrevPerFeatMemSize * (stHdl->nFeat * 2);

  // if no external memory provided, we are only profiling the memory
  // requirement
  if (memPtrExt == NULL) {
    return (totalMemSize);
  }

  // if required memory is more than provided, error
  if ((size_t)totalMemSize > memSize) {
    return -1;
  }

  memPtr = (char*)memPtrExt;

  stHdl->inputResampleBuf = (float*)memPtr;
  memPtr += inputResampleBufMemSize;

  stHdl->inputQ = (float*)memPtr;
  memPtr += inputQMemSize;

  stHdl->alignedIn = (float*)memPtr;
  memPtr += alignedInMemSize;

  stHdl->lpcFilterOutBuf = (float*)memPtr;
  memPtr += lpcFilterOutBufMemSize;

  stHdl->excBuf = (float*)memPtr;
  memPtr += excBufMemSize;

  stHdl->excBufSq = (float*)memPtr;
  memPtr += excBufSqMemSize;

  stHdl->xCorrInst = (float*)memPtr;
  memPtr += xCorrInstMemSize;

  for (idx = 0; idx < AUP_PE_FEAT_MAX_NFRM * 2; idx++) {
    stHdl->xCorr[idx] = NULL;
    stHdl->xCorrTmp[idx] = NULL;
    stHdl->pitchPrev[idx] = NULL;
  }
  for (idx = 0; idx < (stHdl->nFeat * 2); idx++) {
    stHdl->xCorr[idx] = (float*)memPtr;
    memPtr += xCorrPerFeatMemSize;

    stHdl->xCorrTmp[idx] = (float*)memPtr;
    memPtr += xCorrPerFeatTmpMemSize;

    stHdl->pitchPrev[idx] = (int*)memPtr;
    memPtr += pitchPrevPerFeatMemSize;
  }

  stHdl->pitchMaxPathReg[0] = (float*)memPtr;
  memPtr += pitchMaxPathRegPerRegMemSize;
  stHdl->pitchMaxPathReg[1] = (float*)memPtr;
  memPtr += pitchMaxPathRegPerRegMemSize;

  if (((int)(memPtr - (char*)memPtrExt)) > totalMemSize) {
    return -1;
  }

  return (totalMemSize);
}

static void AUP_PE_computeBandEnergy(const float* inBinPower,
                                     const int binPowNFFT,
                                     float bandE[AUP_PE_NB_BANDS]) {
  int i, j, bandSz;
  // float sum[NB_BANDS] = { 0 };
  float frac;
  float indexConvRate = 1.0;
  int indexOffset = 0, accIdx;
  int nBins = (binPowNFFT >> 1) + 1;

  indexConvRate = (float)binPowNFFT / AUP_PE_ASSUMED_FFT_4_BAND_ENG;
  for (i = 0; i < AUP_PE_NB_BANDS; i++) {
    bandE[i] = 0;
  }

  for (i = 0; i < AUP_PE_NB_BANDS - 1; i++) {
    bandSz = (int)roundf(
        (AUP_PE_BAND_START_INDEX[i + 1] - AUP_PE_BAND_START_INDEX[i]) *
        indexConvRate);  // WINDOW_SIZE_5MS;
    indexOffset = (int)roundf(AUP_PE_BAND_START_INDEX[i] *
                              indexConvRate);  // WINDOW_SIZE_5MS;

    for (j = 0; j < bandSz; j++) {
      frac = (float)j / bandSz;
      accIdx = AUP_PE_MIN(nBins - 1, (indexOffset + j));

      bandE[i] += (1 - frac) * inBinPower[accIdx];
      bandE[i + 1] += frac * inBinPower[accIdx];
    }
  }
  bandE[0] *= 2;
  bandE[AUP_PE_NB_BANDS - 1] *= 2;

  return;
}

static void AUP_PE_dct(const float DctTable[AUP_PE_NB_BANDS * AUP_PE_NB_BANDS],
                       const float* in, float* out) {
  int idx, j;
  float sum;
  float ratio = sqrtf(2.0f / AUP_PE_NB_BANDS);
  for (idx = 0; idx < AUP_PE_NB_BANDS; idx++) {
    sum = 0;
    for (j = 0; j < AUP_PE_NB_BANDS; j++) {
      sum += in[j] * DctTable[j * AUP_PE_NB_BANDS + idx];
    }
    out[idx] = sum * ratio;
  }
  return;
}

static void AUP_PE_idct(const float DctTable[AUP_PE_NB_BANDS * AUP_PE_NB_BANDS],
                        const float* in, float* out) {
  int idx, j;
  float sum;
  float ratio = sqrtf(2.0f / AUP_PE_NB_BANDS);
  for (idx = 0; idx < AUP_PE_NB_BANDS; idx++) {
    sum = 0;
    for (j = 0; j < AUP_PE_NB_BANDS; j++) {
      sum += in[j] * DctTable[idx * AUP_PE_NB_BANDS + j];
    }
    out[idx] = sum * ratio;
  }
  return;
}

static void AUP_PE_interp_band_gain(const int nBins,
                                    const float bandE[AUP_PE_NB_BANDS],
                                    float* g) {
  int idx, j, bandSz;
  float indexConvRate = 1.0f;
  int fftSz = (nBins - 1) * 2;
  int indexOffset = 0, accIdx;
  float frac;

  indexConvRate = ((float)fftSz) / AUP_PE_ASSUMED_FFT_4_BAND_ENG;
  memset(g, 0, sizeof(float) * nBins);

  for (idx = 0; idx < AUP_PE_NB_BANDS - 1; idx++) {
    bandSz = (int)roundf(
        (AUP_PE_BAND_START_INDEX[idx + 1] - AUP_PE_BAND_START_INDEX[idx]) *
        indexConvRate);  // WINDOW_SIZE_5MS;
    indexOffset = (int)roundf(AUP_PE_BAND_START_INDEX[idx] *
                              indexConvRate);  // WINDOW_SIZE_5MS;

    for (j = 0; j < bandSz; j++) {
      frac = (float)j / bandSz;
      accIdx = AUP_PE_MIN(nBins - 1, (indexOffset + j));

      g[accIdx] = (1 - frac) * bandE[idx] + frac * bandE[idx + 1];
    }
  }

  return;
}

// ac: in:  [0...p] autocorrelation values
// p: in: buffer length of _lpc and rc
// _lpc: out: [0...p-1] LPC coefficients
static float AUP_PE_celt_lpc(const float* ac, const int p, float* _lpc,
                             float* rc) {
  int i, j;
  float r;
  float error = ac[0];
  float* lpc = _lpc;
  float rr;
  float tmp1, tmp2;

  // RNN_CLEAR(lpc, p);
  memset(lpc, 0, sizeof(float) * p);
  // RNN_CLEAR(rc, p);
  memset(rc, 0, sizeof(float) * p);

  if (ac[0] != 0) {
    for (i = 0; i < p; i++) {
      /* Sum up this iteration's reflection coefficient */
      rr = 0;
      for (j = 0; j < i; j++) rr += lpc[j] * ac[i - j];
      rr += ac[i + 1];
      r = (-rr) / error;
      rc[i] = r;
      /*  Update LPC coefficients and total error */
      lpc[i] = r;
      for (j = 0; j<(i + 1)>> 1; j++) {
        tmp1 = lpc[j];
        tmp2 = lpc[i - 1 - j];
        lpc[j] = tmp1 + (r * tmp2);
        lpc[i - 1 - j] = tmp2 + (r * tmp1);
      }

      error = error - (r * r * error);
      /* Bail out once we get 30 dB gain */

      if (error < .001f * ac[0]) break;
    }
  }

  return error;
}

static float AUP_PE_lpc_from_bands(const int windowSz, const int nBins,
                                   const float Ex[AUP_PE_NB_BANDS],
                                   float lpc[AUP_PE_LPC_ORDER]) {
  int i;
  float e;
  float ac[AUP_PE_LPC_ORDER + 1] = {0};
  float rc[AUP_PE_LPC_ORDER] = {0};
  float Xr[AUP_PE_MAX_NBINS] = {0};
  float X_auto[AUP_PE_MAX_FFTSIZE + 4] = {0};
  float x_auto[AUP_PE_MAX_FFTSIZE + 4] = {0};
  float DC0_BIAS;
  int fftSz = (nBins - 1) * 2;

  AUP_PE_interp_band_gain(nBins, Ex, Xr);
  Xr[nBins - 1] = 0;  // remove nyquist freq.

  // RNN_CLEAR(X_auto, FREQ_SIZE);
  X_auto[0] = Xr[0];  // reformat as complex spectrum data
  X_auto[1] = Xr[nBins - 1];
  for (i = 1; i < (nBins - 1); i++) {
    X_auto[i << 1] = Xr[i];  // give value to its real part
  }                          // leave all the imaginary part as 0

  // inverse_transform(x_auto, X_auto); // IFFT, transform back to time domain
  // (X_auto -> x_auto)
  AUP_FFTW_InplaceTransf(0, fftSz, X_auto);
  if (fftSz == 256) {
    AUP_FFTW_c2r_256(X_auto, x_auto);
  } else if (fftSz == 512) {
    AUP_FFTW_c2r_512(X_auto, x_auto);
  } else if (fftSz == 1024) {
    AUP_FFTW_c2r_1024(X_auto, x_auto);
  }
  AUP_FFTW_RescaleIFFTOut(fftSz, x_auto);

  for (i = 0; i < (AUP_PE_LPC_ORDER + 1);
       i++) {  // take only the first LPC_ORDER + 1 coeff.
    ac[i] = x_auto[i];
  }

  // -40 dB noise floor
  DC0_BIAS = (windowSz / 12 / 38.0f);

  ac[0] += ac[0] * 1e-4f + DC0_BIAS;
  // Lag windowing
  for (i = 1; i < (AUP_PE_LPC_ORDER + 1); i++) {
    ac[i] *= (1 - 6e-5f * i * i);
  }

  e = AUP_PE_celt_lpc(ac, AUP_PE_LPC_ORDER, lpc, rc);

  return (e);
}

// lpc_from_cepstrum
static float AUP_PE_lpcCompute(
    const int windowSz, const int nBins,
    const float DctTable[AUP_PE_NB_BANDS * AUP_PE_NB_BANDS],
    const float* cepstrum, float* lpc) {
  int i;
  float Ex[AUP_PE_NB_BANDS] = {0};
  float tmp[AUP_PE_NB_BANDS] = {0};
  float errValue = 0;

  // RNN_COPY(tmp, cepstrum, NB_BANDS);
  memcpy(tmp, cepstrum, sizeof(float) * AUP_PE_NB_BANDS);

  AUP_PE_idct(DctTable, tmp, Ex);  // idct(Ex, tmp);
  for (i = 0; i < AUP_PE_NB_BANDS; i++) {
    Ex[i] = powf(10.f, Ex[i]) * AUP_PE_BAND_LPC_COMP[i];
  }

  errValue = AUP_PE_lpc_from_bands(windowSz, nBins, Ex, lpc);

  return (errValue);
}

static void AUP_PE_xcorr_kernel(const float* x, const float* y, float sum[4],
                                int len) {
  int j;
  float y_0, y_1, y_2, y_3;
  y_3 = 0; /* gcc doesn't realize that y_3 can't be used uninitialized */
  y_0 = *y++;
  y_1 = *y++;
  y_2 = *y++;
  for (j = 0; j < len - 3; j += 4) {
    float tmp;
    tmp = *x++;
    y_3 = *y++;
    sum[0] += tmp * y_0;
    sum[1] += tmp * y_1;
    sum[2] += tmp * y_2;
    sum[3] += tmp * y_3;
    tmp = *x++;
    y_0 = *y++;
    sum[0] += tmp * y_1;
    sum[1] += tmp * y_2;
    sum[2] += tmp * y_3;
    sum[3] += tmp * y_0;
    tmp = *x++;
    y_1 = *y++;
    sum[0] += tmp * y_2;
    sum[1] += tmp * y_3;
    sum[2] += tmp * y_0;
    sum[3] += tmp * y_1;
    tmp = *x++;
    y_2 = *y++;
    sum[0] += tmp * y_3;
    sum[1] += tmp * y_0;
    sum[2] += tmp * y_1;
    sum[3] += tmp * y_2;
  }
  if (j++ < len) {
    float tmp = *x++;
    y_3 = *y++;
    sum[0] += tmp * y_0;
    sum[1] += tmp * y_1;
    sum[2] += tmp * y_2;
    sum[3] += tmp * y_3;
  }
  if (j++ < len) {
    float tmp = *x++;
    y_0 = *y++;
    sum[0] += tmp * y_1;
    sum[1] += tmp * y_2;
    sum[2] += tmp * y_3;
    sum[3] += tmp * y_0;
  }
  if (j < len) {
    float tmp = *x++;
    y_1 = *y++;
    sum[0] += tmp * y_2;
    sum[1] += tmp * y_3;
    sum[2] += tmp * y_0;
    sum[3] += tmp * y_1;
  }
  return;
}

static float AUP_PE_celt_inner_prod(const float* x, const float* y, int N) {
  int i;
  float xy = 0;
  for (i = 0; i < N; i++) {
    xy += (x[i] * y[i]);
  }

  return (xy);
}

static void AUP_PE_MvingXCorr(int corrWindowLen, int corrShiftTimes,
                              const float* refIn, const float* yInToShift,
                              float* xcorr) {
  /* Unrolled version of the pitch correlation -- runs faster on x86 and ARM */
  int i;
  float tmp;

  for (i = 0; i < corrShiftTimes - 3; i += 4) {
    float sum[4] = {0, 0, 0, 0};
    AUP_PE_xcorr_kernel(refIn, yInToShift + i, sum, corrWindowLen);
    xcorr[i] = sum[0];
    xcorr[i + 1] = sum[1];
    xcorr[i + 2] = sum[2];
    xcorr[i + 3] = sum[3];
  }
  /* In case corrShiftTimes isn't a multiple of 4, do non-unrolled version. */
  for (; i < corrShiftTimes; i++) {
    tmp = AUP_PE_celt_inner_prod(refIn, yInToShift + i, corrWindowLen);
    xcorr[i] = tmp;
  }
  return;
}

// ==========================================================================================
// public APIs
// ==========================================================================================

int AUP_PE_create(void** stPtr) {
  PE_St* tmpPtr;

  if (stPtr == NULL) {
    return -1;
  }

  *stPtr = (void*)malloc(sizeof(PE_St));
  if (*stPtr == NULL) {
    return -1;
  }
  memset(*stPtr, 0, sizeof(PE_St));

  tmpPtr = (PE_St*)(*stPtr);

  tmpPtr->dynamMemPtr = NULL;
  tmpPtr->dynamMemSize = 0;

  if (AUP_Biquad_create(&(tmpPtr->biquadIIRPtr)) < 0 ||
      tmpPtr->biquadIIRPtr == NULL) {
    return -1;
  }

  tmpPtr->stCfg.fftSz = 1024;
  tmpPtr->stCfg.anaWindowSz = 768;
  tmpPtr->stCfg.hopSz = 256;
  tmpPtr->stCfg.useLPCPreFiltering = 1;
  tmpPtr->stCfg.procFs = 4000;  // 4KHz resampling rate

  tmpPtr->dynamCfg.voicedThr = 0.4f;

  return 0;
}

int AUP_PE_destroy(void** stPtr) {
  PE_St* stHdl;

  if (stPtr == NULL) {
    return 0;
  }

  stHdl = (PE_St*)(*stPtr);
  if (stHdl == NULL) {
    return 0;
  }

  if (stHdl->dynamMemPtr != NULL) {
    free(stHdl->dynamMemPtr);
  }
  stHdl->dynamMemPtr = NULL;

  if (stHdl->biquadIIRPtr != NULL) {
    AUP_Biquad_destroy(&(stHdl->biquadIIRPtr));
  }

  free(stHdl);
  (*stPtr) = NULL;

  return 0;
}

int AUP_PE_memAllocate(void* stPtr, const PE_StaticCfg* pCfg) {
  PE_St* stHdl = NULL;
  PE_StaticCfg localStCfg;
  Biquad_StaticCfg biquadStCfg = {0, 0, 0, {0}, {0}, 0};
  int idx;
  int totalMemSize = 0;

  if (stPtr == NULL || pCfg == NULL) {
    return -1;
  }
  stHdl = (PE_St*)(stPtr);

  memcpy(&localStCfg, pCfg, sizeof(PE_StaticCfg));
  if (AUP_PE_checkStatCfg(&localStCfg) < 0) {
    return -1;
  }

  memcpy(&(stHdl->stCfg), &localStCfg, sizeof(PE_StaticCfg));

  // publish internal static configuration registers
  if (AUP_PE_publishStaticCfg(stHdl) < 0) {
    return -1;
  }

  // check memory requirement
  totalMemSize = AUP_PE_dynamMemPrepare(stHdl, NULL, 0);
  if (totalMemSize < 0) {
    return -1;
  }

  // allocate dynamic memory
  if ((size_t)totalMemSize > stHdl->dynamMemSize) {
    if (stHdl->dynamMemPtr != NULL) {
      free(stHdl->dynamMemPtr);
      stHdl->dynamMemSize = 0;
    }
    stHdl->dynamMemPtr = malloc(totalMemSize);
    if (stHdl->dynamMemPtr == NULL) {
      return -1;
    }
    stHdl->dynamMemSize = totalMemSize;
  }
  memset(stHdl->dynamMemPtr, 0, stHdl->dynamMemSize);

  // setup the pointers/variable
  if (AUP_PE_dynamMemPrepare(stHdl, stHdl->dynamMemPtr, stHdl->dynamMemSize) <
      0) {
    return -1;
  }

  if (AUP_Biquad_getStaticCfg(stHdl->biquadIIRPtr, &biquadStCfg) < 0) {
    return -1;
  }
  biquadStCfg.maxNSample = stHdl->stCfg.hopSz;
  if (stHdl->procResampleRate != 1) {
    biquadStCfg.nsect = AUP_PE_LOWPSS_NSEC;
    if (stHdl->stCfg.procFs == 2000) {
      biquadStCfg.G = AUP_PE_G_2KHZ;
      for (idx = 0; idx < biquadStCfg.nsect; idx++) {
        biquadStCfg.B[idx] = AUP_PE_B_2KHZ[idx];
        biquadStCfg.A[idx] = AUP_PE_A_2KHZ[idx];
      }
    } else if (stHdl->stCfg.procFs == 4000) {
      biquadStCfg.G = AUP_PE_G_4KHZ;
      for (idx = 0; idx < biquadStCfg.nsect; idx++) {
        biquadStCfg.B[idx] = AUP_PE_B_4KHZ[idx];
        biquadStCfg.A[idx] = AUP_PE_A_4KHZ[idx];
      }
    } else if (stHdl->stCfg.procFs == 8000) {
      biquadStCfg.G = AUP_PE_G_8KHZ;
      for (idx = 0; idx < biquadStCfg.nsect; idx++) {
        biquadStCfg.B[idx] = AUP_PE_B_8KHZ[idx];
        biquadStCfg.A[idx] = AUP_PE_A_8KHZ[idx];
      }
    }
  } else {
    biquadStCfg.nsect = -1;
  }
  if (AUP_Biquad_memAllocate(stHdl->biquadIIRPtr, &biquadStCfg) < 0) {
    return -1;
  }

  return 0;
}

int AUP_PE_init(void* stPtr) {
  PE_St* stHdl;

  if (stPtr == NULL) {
    return -1;
  }
  stHdl = (PE_St*)(stPtr);

  if (AUP_PE_resetVariables(stHdl) < 0) {
    return -1;
  }

  return 0;
}

int AUP_PE_setDynamCfg(void* stPtr, const PE_DynamCfg* pCfg) {
  PE_St* stHdl;
  PE_DynamCfg localCfg;

  if (stPtr == NULL || pCfg == NULL) {
    return -1;
  }

  memcpy(&localCfg, pCfg, sizeof(PE_DynamCfg));
  if (AUP_PE_checkDynamCfg(&localCfg) < 0) {
    return -1;
  }

  stHdl = (PE_St*)(stPtr);

  memcpy(&(stHdl->dynamCfg), &localCfg, sizeof(PE_DynamCfg));

  return 0;
}

int AUP_PE_getStaticCfg(const void* stPtr, PE_StaticCfg* pCfg) {
  const PE_St* stHdl;

  if (stPtr == NULL || pCfg == NULL) {
    return -1;
  }
  stHdl = (const PE_St*)(stPtr);

  memcpy(pCfg, &(stHdl->stCfg), sizeof(PE_StaticCfg));

  return 0;
}

int AUP_PE_getDynamCfg(const void* stPtr, PE_DynamCfg* pCfg) {
  const PE_St* stHdl;

  if (stPtr == NULL || pCfg == NULL) {
    return -1;
  }
  stHdl = (const PE_St*)(stPtr);

  memcpy(pCfg, &(stHdl->dynamCfg), sizeof(PE_DynamCfg));

  return 0;
}

int AUP_PE_getAlgDelay(const void* stPtr, int* delayInFrms) {
  const PE_St* stHdl;

  if (stPtr == NULL || delayInFrms == NULL) {
    return -1;
  }
  stHdl = (const PE_St*)(stPtr);

  *delayInFrms = stHdl->estDelay;

  return 0;
}

int AUP_PE_proc(void* stPtr, const PE_InputData* pIn, PE_OutputData* pOut) {
  PE_St* stHdl = NULL;
  Biquad_InputData bqInData = {0, 0, 0};
  Biquad_OutputData bqOutData = {0};
  int nBins, fftSz, hopSz, idx, jdx, sub, offset, tmpInt, xcorrAccIdx;
  float bandPow[AUP_PE_NB_BANDS] = {0};  // Ex
  float Ly[AUP_PE_NB_BANDS] = {0};
  float follow, lpcErr, logMax;
  float energy0, slidWinSum, tmpDenom = 0, maxTrackReg = 0, maxPathReg = 0;
  float frmCorr = 0;  // frmCorrCorrection = 0;
  const float* startPtr = NULL;
  const float* refSeqPtr = NULL;
  const float* mvSeqPtr = NULL;
  int CORR_HALF_HOPSZ, SIDXT, XCIdx;
  int bestPeriodEstLocal[AUP_PE_TOTAL_NFEAT * 2] = {0};
  float w, sx = 0, sxx = 0, sxy = 0, sy = 0, sw = 0;
  float bestA = 0, bestB = 0;
  float estimatedPeriod;

  if (stPtr == NULL || pIn == NULL || pIn->timeSignal == NULL) {
    return -1;
  }
  stHdl = (PE_St*)(stPtr);

  nBins = (int)(stHdl->nBins);
  fftSz = (int)(stHdl->stCfg.fftSz);
  hopSz = (int)(stHdl->stCfg.hopSz);
  CORR_HALF_HOPSZ = hopSz / (stHdl->procResampleRate * 2);

  if (pIn->hopSz != (int)stHdl->stCfg.hopSz) {
    return -1;
  }

  if (stHdl->stCfg.useLPCPreFiltering == 1 && pIn->inBinPow == NULL) {
    return -1;
  }
  if (stHdl->stCfg.useLPCPreFiltering == 1 && pIn->nBins != stHdl->nBins) {
    return -1;
  }

  //////////////////////////////////////////////////////////////////////////////////////
  // Feature Pre-Calculation .... from compute_frame_features of lpcnet_enc.cc
  //////////////////////////////////////////////////////////////////////////////////////
  if (stHdl->stCfg.useLPCPreFiltering == 1) {
    // first. generate features and pre-raw information ...
    AUP_PE_computeBandEnergy(pIn->inBinPow, fftSz, bandPow);
    logMax = -2.0f;
    follow = -2.0f;
    for (idx = 0; idx < AUP_PE_NB_BANDS; idx++) {
      Ly[idx] = log10f(1e-2f + bandPow[idx]);  // Ex
      Ly[idx] = AUP_PE_MAX(logMax - 8.0f, AUP_PE_MAX(follow - 2.5f, Ly[idx]));
      logMax = AUP_PE_MAX(logMax, Ly[idx]);

      follow = AUP_PE_MAX(follow - 2.5f, Ly[idx]);
    }

    AUP_PE_dct(stHdl->dct_table, Ly, stHdl->tmpFeat);

    lpcErr = AUP_PE_lpcCompute((int)(stHdl->stCfg.anaWindowSz), nBins,
                               stHdl->dct_table, stHdl->tmpFeat, stHdl->lpc);

    memmove(stHdl->inputQ, stHdl->inputQ + hopSz,
            sizeof(float) * (stHdl->inputQLen - hopSz));
    memcpy(&(stHdl->inputQ[stHdl->inputQLen - hopSz]), pIn->timeSignal,
           sizeof(float) * hopSz);
    // then, take part out into alignedIn for later correlation calculation
    offset =
        AUP_PE_MAX(0, stHdl->inputQLen - hopSz - AUP_PE_XCORR_TRAINING_OFFSET);
    memcpy(stHdl->alignedIn, stHdl->inputQ + offset, sizeof(float) * hopSz);

    for (idx = 0; idx < hopSz; idx++) {
      // FIR LPC filtering .....
      slidWinSum = stHdl->alignedIn[idx];
      for (jdx = 0; jdx < AUP_PE_LPC_ORDER; jdx++) {
        slidWinSum += stHdl->lpc[jdx] * stHdl->pitch_mem[jdx];
      }

      memmove(stHdl->pitch_mem + 1, stHdl->pitch_mem,
              sizeof(float) * (AUP_PE_LPC_ORDER - 1));
      stHdl->pitch_mem[0] =
          stHdl->alignedIn[idx];  // push the latest base-sample into the tail
                                  // of FIFO

      stHdl->lpcFilterOutBuf[idx] = slidWinSum + 0.7f * stHdl->pitch_filt;
      stHdl->pitch_filt = slidWinSum;
    }

    if (stHdl->procResampleRate != 1) {
      // resample of lpcFilterOutBuf
      bqInData.nsamples = (size_t)hopSz;
      bqInData.samplesPtr = (const void*)(stHdl->lpcFilterOutBuf);
      bqInData.sampleType = 1;
      bqOutData.outputBuff =
          (void*)(stHdl->inputResampleBuf + stHdl->inputResampleBufIdx);
      if (AUP_Biquad_proc(stHdl->biquadIIRPtr, &bqInData, &bqOutData) < 0) {
        return -1;
      }
      tmpInt = stHdl->inputResampleBufIdx;
      for (idx = tmpInt; idx < (tmpInt + hopSz);
           idx += stHdl->procResampleRate) {
        stHdl->inputResampleBuf[stHdl->inputResampleBufIdx] =
            stHdl->inputResampleBuf[idx];
        stHdl->inputResampleBufIdx++;
      }
      // update the excBuf ....
      tmpInt = stHdl->inputResampleBufIdx;
      memmove(stHdl->excBuf, stHdl->excBuf + tmpInt,
              sizeof(float) * (stHdl->excBufLen - tmpInt));
      memcpy(stHdl->excBuf + (stHdl->excBufLen - tmpInt),
             stHdl->inputResampleBuf, sizeof(float) * tmpInt);
      stHdl->inputResampleBufIdx = 0;
    } else {
      tmpInt = hopSz;
      memmove(stHdl->excBuf, stHdl->excBuf + tmpInt,
              sizeof(float) * (stHdl->excBufLen - tmpInt));
      memcpy(stHdl->excBuf + (stHdl->excBufLen - tmpInt),
             stHdl->lpcFilterOutBuf, sizeof(float) * tmpInt);
    }

  } else {
    if (stHdl->procResampleRate != 1) {
      // resample of lpcFilterOutBuf
      bqInData.nsamples = (size_t)hopSz;
      bqInData.samplesPtr = (const void*)(pIn->timeSignal);
      bqInData.sampleType = 1;
      bqOutData.outputBuff =
          (void*)(stHdl->inputResampleBuf + stHdl->inputResampleBufIdx);
      if (AUP_Biquad_proc(stHdl->biquadIIRPtr, &bqInData, &bqOutData) < 0) {
        return -1;
      }
      tmpInt = stHdl->inputResampleBufIdx;
      for (idx = tmpInt; idx < (tmpInt + hopSz);
           idx += stHdl->procResampleRate) {
        stHdl->inputResampleBuf[stHdl->inputResampleBufIdx] =
            stHdl->inputResampleBuf[idx];
        stHdl->inputResampleBufIdx++;
      }

      // update the excBuf ....
      tmpInt = stHdl->inputResampleBufIdx;
      memmove(stHdl->excBuf, stHdl->excBuf + tmpInt,
              sizeof(float) * (stHdl->excBufLen - tmpInt));
      memcpy(stHdl->excBuf + (stHdl->excBufLen - tmpInt),
             stHdl->inputResampleBuf, sizeof(float) * tmpInt);
      stHdl->inputResampleBufIdx = 0;
    } else {
      tmpInt = hopSz;
      memmove(stHdl->excBuf, stHdl->excBuf + tmpInt,
              sizeof(float) * (stHdl->excBufLen - tmpInt));
      memcpy(stHdl->excBuf + (stHdl->excBufLen - tmpInt), pIn->timeSignal,
             sizeof(float) * tmpInt);
    }
  }

  // prepare for cross-correlation computation ....
  for (idx = 0; idx < stHdl->excBufLen; idx++) {
    stHdl->excBufSq[idx] = (stHdl->excBuf[idx] * stHdl->excBuf[idx]);
  }

  // shift the frmWeight queue to left space for this new frame
  for (idx = 0; idx < (stHdl->nFeat - 1); idx++) {
    stHdl->frmWeight[2 * (idx)] = stHdl->frmWeight[2 * (idx + 1)];
    stHdl->frmWeight[2 * (idx) + 1] = stHdl->frmWeight[2 * (idx + 1) + 1];
  }

  // do the cross-correlation .....
  for (sub = 0; sub < 2; sub++) {
    xcorrAccIdx = 2 * (stHdl->xCorrOffsetIdx) + sub;
    offset = sub * CORR_HALF_HOPSZ;

    refSeqPtr = stHdl->excBuf + (stHdl->maxPeriod + offset);
    mvSeqPtr = stHdl->excBuf + offset;
    AUP_PE_MvingXCorr(CORR_HALF_HOPSZ, stHdl->maxPeriod, refSeqPtr, mvSeqPtr,
                      stHdl->xCorrInst);

    energy0 = 0;
    startPtr = stHdl->excBufSq + (stHdl->maxPeriod + offset);
    for (idx = 0; idx < CORR_HALF_HOPSZ; idx++) {
      energy0 += startPtr[idx];
    }
    stHdl->frmWeight[2 * (stHdl->nFeat - 1) + sub] = energy0;

    slidWinSum = 0;
    startPtr = stHdl->excBufSq + offset;
    for (idx = 0; idx < CORR_HALF_HOPSZ; idx++) {
      slidWinSum += startPtr[idx];
    }

    // special hanlding for the 0th element
    tmpDenom = AUP_PE_MAX(1e-12f, slidWinSum + (1 + energy0));
    stHdl->xCorr[xcorrAccIdx][0] = 2 * stHdl->xCorrInst[0] / tmpDenom;

    for (idx = 1; idx < stHdl->maxPeriod; idx++) {
      // update the slidWinSum
      slidWinSum =
          AUP_PE_MAX(0, slidWinSum - stHdl->excBufSq[offset + idx - 1]);
      slidWinSum += stHdl->excBufSq[offset + idx + CORR_HALF_HOPSZ - 1];

      tmpDenom = AUP_PE_MAX(1e-12f, slidWinSum + (1 + energy0));
      stHdl->xCorr[xcorrAccIdx][idx] = 2 * stHdl->xCorrInst[idx] / tmpDenom;
    }

    // shrink/sharpen the values in xCorr array ...
    for (idx = 0; idx < (stHdl->maxPeriod - 2 * stHdl->minPeriod); idx++) {
      tmpDenom = stHdl->xCorr[xcorrAccIdx][(stHdl->maxPeriod + idx) / 2];
      tmpDenom = AUP_PE_MAX(
          tmpDenom,
          stHdl->xCorr[xcorrAccIdx][(stHdl->maxPeriod + idx + 2) / 2]);
      tmpDenom = AUP_PE_MAX(
          tmpDenom,
          stHdl->xCorr[xcorrAccIdx][(stHdl->maxPeriod + idx - 1) / 2]);

      if (stHdl->xCorr[xcorrAccIdx][idx] < (tmpDenom * 1.1f))
        stHdl->xCorr[xcorrAccIdx][idx] *= 0.8f;
    }
  }
  stHdl->xCorrOffsetIdx++;
  if (stHdl->xCorrOffsetIdx >= stHdl->nFeat) {
    stHdl->xCorrOffsetIdx = 0;
  }

  //////////////////////////////////////////////////////////////////////////////////////
  // Pitch Estimation .... from process_superframe of lpcnet_enc.cc
  //////////////////////////////////////////////////////////////////////////////////////
  slidWinSum = 1e-15f;
  for (sub = 0; sub < (stHdl->nFeat * 2); sub++) {
    slidWinSum += stHdl->frmWeight[sub];
  }
  for (sub = 0; sub < (stHdl->nFeat * 2); sub++) {
    stHdl->frmWeightNorm[sub] =
        stHdl->frmWeight[sub] * ((stHdl->nFeat * 2) / slidWinSum);
  }

  // copy xCorr to xCorrTmp, so that later-on we can modify the content in
  // xCorrTmp without impacting next hop's processing
  for (idx = 0; idx < (stHdl->nFeat * 2); idx++) {
    memcpy(stHdl->xCorrTmp[idx], stHdl->xCorr[idx],
           sizeof(float) * (stHdl->maxPeriod + 1));
  }

  // shift pitchPrev buffer to left space for this new frame's result
  for (sub = 0; sub < (stHdl->nFeat * 2 - 2); sub += 2) {
    memcpy(stHdl->pitchPrev[sub], stHdl->pitchPrev[sub + 2],
           sizeof(int) * stHdl->maxPeriod);
    memcpy(stHdl->pitchPrev[sub + 1], stHdl->pitchPrev[sub + 3],
           sizeof(int) * stHdl->maxPeriod);
  }
  for (sub = (stHdl->nFeat * 2 - 2); sub < (stHdl->nFeat * 2); sub++) {
    XCIdx = sub + (stHdl->xCorrOffsetIdx * 2);
    if (XCIdx >= (2 * stHdl->nFeat)) {
      XCIdx -= (2 * stHdl->nFeat);
    }

    for (idx = 0; idx < stHdl->difPeriod; idx++) {
      maxTrackReg = stHdl->pitchMaxPathAll - 1e10f;
      stHdl->pitchPrev[sub][idx] = stHdl->bestPeriodEst;

      SIDXT = AUP_PE_MIN(0, 4 - idx);
      for (jdx = SIDXT; jdx <= 4 && (idx + jdx) < stHdl->difPeriod; jdx++) {
        tmpDenom = stHdl->pitchMaxPathReg[0][idx + jdx] -
                   (AUP_PE_PITCHMAXPATH_W * abs(jdx) * abs(jdx));
        if (tmpDenom > maxTrackReg) {
          maxTrackReg = tmpDenom;
          stHdl->pitchPrev[sub][idx] = idx + jdx;
        }
      }

      // store the max search result into pitch_max_path[1][...]
      stHdl->pitchMaxPathReg[1][idx] =
          maxTrackReg + stHdl->frmWeightNorm[sub] * stHdl->xCorrTmp[XCIdx][idx];
    }

    maxPathReg = -1e15f;
    tmpInt = 0;
    for (idx = 0; idx < stHdl->difPeriod; idx++) {
      if (stHdl->pitchMaxPathReg[1][idx] > maxPathReg) {
        maxPathReg = stHdl->pitchMaxPathReg[1][idx];
        tmpInt = idx;
      }
    }
    stHdl->pitchMaxPathAll = maxPathReg;
    stHdl->bestPeriodEst = tmpInt;

    memcpy(&(stHdl->pitchMaxPathReg[0][0]), &(stHdl->pitchMaxPathReg[1][0]),
           sizeof(float) * stHdl->maxPeriod);
    for (idx = 0; idx < stHdl->difPeriod; idx++) {
      stHdl->pitchMaxPathReg[0][idx] -= maxPathReg;
    }
  }

  tmpInt = stHdl->bestPeriodEst;
  frmCorr = 0;
  // Backward pass
  for (sub = (stHdl->nFeat * 2) - 1; sub >= 0; sub--) {
    bestPeriodEstLocal[sub] = stHdl->maxPeriod - tmpInt;

    XCIdx = sub + (stHdl->xCorrOffsetIdx * 2);
    if (XCIdx >= (2 * stHdl->nFeat)) {
      XCIdx -= (2 * stHdl->nFeat);
    }
    frmCorr += stHdl->frmWeightNorm[sub] * stHdl->xCorrTmp[XCIdx][tmpInt];
    tmpInt = stHdl->pitchPrev[sub][tmpInt];
  }
  frmCorr = AUP_PE_MAX(0, frmCorr / (float)(stHdl->nFeat * 2));
  stHdl->voiced = (frmCorr >= stHdl->dynamCfg.voicedThr) ? 1 : 0;

  for (sub = 0; sub < (stHdl->nFeat * 2); sub++) {
    w = stHdl->frmWeightNorm[sub];
    sw += w;
    sx += w * sub;
    sxx += w * sub * sub;
    sxy += w * sub * bestPeriodEstLocal[sub];
    sy += w * bestPeriodEstLocal[sub];
  }

  // Linear regression to figure out the pitch contour
  // frmCorrCorrection = frmCorr;
  tmpDenom = (sw * sxx - sx * sx);
  if (tmpDenom == 0)
    bestA = (sw * sxy - sx * sy) / 1e-15f;
  else
    bestA = (sw * sxy - sx * sy) / tmpDenom;

  if (stHdl->voiced == 1) {
    tmpDenom = (sy / sw) / (4 * 2 * stHdl->nFeat);
    bestA = AUP_PE_MIN(tmpDenom, AUP_PE_MAX(-tmpDenom, bestA));
  } else {  // if there is no voice inside this frame
    bestA = 0;
  }
  bestB = (sy - bestA * sx) / sw;
  estimatedPeriod = bestB + 5.5f * bestA;

  if (stHdl->voiced == 1) {
    stHdl->pitchEstResult =
        ((float)(stHdl->stCfg.procFs)) / AUP_PE_MAX(1.0f, estimatedPeriod);
  } else {
    stHdl->pitchEstResult = 0;
  }

  if (pOut != NULL) {
    pOut->pitchFreq = stHdl->pitchEstResult;
    pOut->voiced = stHdl->voiced;
  }

  return 0;
}



================================================
FILE: src/pitch_est.h
================================================
 //
 // Copyright © 2025 Agora
 // This file is part of TEN Framework, an open source project.
 // Licensed under the Apache License, Version 2.0, with certain conditions.
 //
 // Refer to the "LICENSE" file in the root directory for more information.
 //

#ifndef __PITCH_EST_H__
#define __PITCH_EST_H__

#include <stddef.h>
#include <stdint.h>
#include <stdio.h>

#define AUP_PE_MAX_FFTSIZE (1024)
#define AUP_PE_MAX_NBINS ((AUP_PE_MAX_FFTSIZE >> 1) + 1)

#define AUP_PE_FS (16000)
// assumed sampling freq. of this module

// Configuration Parameters, which impacts dynamic memory occupation, can only
// be set during allocation
typedef struct PE_StaticCfg_ {
  size_t fftSz;        // fft-size, only support: 128, 256, 512, 1024
  size_t anaWindowSz;  // analysis fft-Window Size, will be used in LPC estimate
  size_t hopSz;        // fft-Hop Size, will be used to check
  int useLPCPreFiltering;
  // 0: use raw pcm to estimate pitch
  // 1: use LPC prefiltering before pitch estimation
  size_t procFs;  // internal processing sampling rate
  // 2000/4000/8000/16000
} PE_StaticCfg;

// Configuraiton parameters which can be modified/set every frames
typedef struct PE_DynamCfg_ {
  float voicedThr;  // threshold on frame correlation coeff to label if voice
                    // present
  // suggested value: procFs == 2KHz, Yes: 0.45, No: 0.4
} PE_DynamCfg;

// Spectrum are assumed to be generated with time-domain samples in [-32768,
// 32767] WITH LEC blowup protection Note: the input timeSignal has to be in
// 16KHz sampling-rate
typedef struct PE_InputData_ {
  const float*
      timeSignal;  // [hopSz]   // this frame's input signal, in [-32768, 32767]
  int hopSz;       // should be equal to StaticCfg->hopSz

  // if useLPCPreFiltering == 0, the following two input argument
  //    are not necessary
  const float* inBinPow;  // [nBins], bin-wise power
  int nBins;
} PE_InputData;

typedef struct PE_OutputData_ {
  float pitchFreq;  // the current estimated pitch freq.
  // <= 0: no voice
  int voiced;  // 0: no-voice, 1: voice-present
} PE_OutputData;

typedef struct PE_GetData_ {
  float pitchFreq;  // the current estimated pitch freq.
  // <= 0: no voice
  int voiced;  // 0: no-voice, 1: voice-present
} PE_GetData;

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************
 * AUP_PE_create(...)
 *
 * This function creats a state handler from nothing, which is NOT ready for
 * processing
 *
 * Input:
 *
 * Output:
 *      - stPtr         : buffer to store the returned state handler
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_PE_create(void** stPtr);

/****************************************************************************
 * AUP_PE_destroy(...)
 *
 * destroy PE instance, and releasing all the dynamically allocated memory
 *
 * Input:
 *      - stPtr         : buffer of State Handler, after this method, this
 *                        handler won't be usable anymore
 *
 * Output:
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_PE_destroy(void** stPtr);

/****************************************************************************
 * AUP_PE_memAllocate(...)
 *
 * This function sets Static Config params and does memory allocation
 * operation, will lose the dynamCfg values
 *
 * Input:
 *      - stPtr         : State Handler which was returned by _create
 *      - pCfg          : static configuration parameters
 *
 * Output:
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_PE_memAllocate(void* stPtr, const PE_StaticCfg* pCfg);

/****************************************************************************
 * AUP_PE_init(...)
 *
 * This function resets (initialize) the PE module and gets it prepared for
 * processing
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate
 *
 * Output:
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_PE_init(void* stPtr);

/****************************************************************************
 * AUP_PE_setDynamCfg(...)
 *
 * This function set dynamic (per-frame variable) configuration
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate
 *      - pCfg          : configuration content
 *
 * Output:
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_PE_setDynamCfg(void* stPtr, const PE_DynamCfg* pCfg);

/****************************************************************************
 * AUP_PE_getStaticCfg(...)
 *
 * This function get static configuration status from PE module
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate
 *
 * Output:
 *      - pCfg          : configuration content
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_PE_getStaticCfg(const void* stPtr, PE_StaticCfg* pCfg);

/****************************************************************************
 * AUP_PE_getDynamCfg(...)
 *
 * This function get dynamic (per-frame variable) configuration status from
 * PE module
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate
 *
 * Output:
 *      - pCfg          : configuration content
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_PE_getDynamCfg(const void* stPtr, PE_DynamCfg* pCfg);

/****************************************************************************
 * AUP_PE_getAlgDelay(...)
 *
 * This function get algorithm delay from PE module
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate
 *
 * Output:
 *      - delayInFrms   : algorithm delay in terms of frames
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_PE_getAlgDelay(const void* stPtr, int* delayInFrms);

/****************************************************************************
 * AUP_PE_proc(...)
 *
 * process a single frame
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate and reset
 *      - pCtrl         : per-frame variable control parameters
 *      - pIn           : input data stream
 *
 * Output:
 *      - pOut          : output data (mask, highband time-domain gain etc.)
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_PE_proc(void* stPtr, const PE_InputData* pIn, PE_OutputData* pOut);

#ifdef __cplusplus
}
#endif
#endif  // __PITCH_EST_H__



================================================
FILE: src/pitch_est_st.h
================================================
//
// Copyright © 2025 Agora
// This file is part of TEN Framework, an open source project.
// Licensed under the Apache License, Version 2.0, with certain conditions.
// Refer to the "LICENSE" file in the root directory for more information.
//
#ifndef __PITCH_EST_ST_H__
#define __PITCH_EST_ST_H__

#include <stdio.h>

#include "pitch_est.h"

#define AUP_PE_ALIGN8(o) (((o) + 7) & (~7))
#define AUP_PE_MAX(x, y) (((x) > (y)) ? (x) : (y))
#define AUP_PE_MIN(x, y) (((x) > (y)) ? (y) : (x))

#define AUP_PE_NB_BANDS (18)  // number of mel bands
#define AUP_PE_LPC_ORDER (16)

#define AUP_PE_XCORR_TRAINING_OFFSET (80)  // = 80
#define AUP_PE_MIN_PERIOD_16KHZ (32)   // stands for 1.333kHz, PITCH_MIN_PERIOD
#define AUP_PE_MAX_PERIOD_16KHZ (256)  // stands for ~62Hz, PITCH_MAX_PERIOD

#define AUP_PE_LOWPSS_NSEC (5)
const float AUP_PE_B_2KHZ[AUP_PE_LOWPSS_NSEC][3] = {
    {1.000000e+00f, -1.303155e-01f, 1.000000e+00f},
    {1.000000e+00f, -1.563002e+00f, 1.000000e+00f},
    {1.000000e+00f, -1.759739e+00f, 1.000000e+00f},
    {1.000000e+00f, -1.811650e+00f, 1.000000e+00f},
    {1.000000e+00f, -1.827332e+00f, 1.000000e+00f}};
const float AUP_PE_A_2KHZ[AUP_PE_LOWPSS_NSEC][3] = {
    {1.000000e+00f, -1.726800e+00f, 7.526543e-01f},
    {1.000000e+00f, -1.762977e+00f, 8.277960e-01f},
    {1.000000e+00f, -1.802014e+00f, 9.079320e-01f},
    {1.000000e+00f, -1.828423e+00f, 9.594240e-01f},
    {1.000000e+00f, -1.846774e+00f, 9.888390e-01f}};
const float AUP_PE_G_2KHZ[AUP_PE_LOWPSS_NSEC] = {
    2.156619e-01f, 2.156619e-01f, 2.156619e-01f, 2.156619e-01f, 2.156619e-01f};

const float AUP_PE_B_4KHZ[AUP_PE_LOWPSS_NSEC][3] = {
    {1.000000e+00f, 1.198825e+00f, 1.000000e+00f},
    {1.000000e+00f, -5.674614e-01f, 1.000000e+00f},
    {1.000000e+00f, -1.099061e+00f, 1.000000e+00f},
    {1.000000e+00f, -1.265846e+00f, 1.000000e+00f},
    {1.000000e+00f, -1.318849e+00f, 1.000000e+00f}};
const float AUP_PE_A_4KHZ[AUP_PE_LOWPSS_NSEC][3] = {
    {1.000000e+00f, -1.445267e+00f, 5.463974e-01f},
    {1.000000e+00f, -1.426720e+00f, 6.820138e-01f},
    {1.000000e+00f, -1.408255e+00f, 8.286664e-01f},
    {1.000000e+00f, -1.400909e+00f, 9.240320e-01f},
    {1.000000e+00f, -1.408242e+00f, 9.789776e-01f}};
const float AUP_PE_G_4KHZ[AUP_PE_LOWPSS_NSEC] = {
    2.692541e-01f, 2.692541e-01f, 2.692541e-01f, 2.692541e-01f, 2.692541e-01f};

const float AUP_PE_B_8KHZ[AUP_PE_LOWPSS_NSEC][3] = {
    {1.000000e+00f, 1.830863e+00f, 1.000000e+00f},
    {1.000000e+00f, 1.039654e+00f, 1.000000e+00f},
    {1.000000e+00f, 4.900788e-01f, 1.000000e+00f},
    {1.000000e+00f, 2.419292e-01f, 1.000000e+00f},
    {1.000000e+00f, 1.517919e-01f, 1.000000e+00f}};
const float AUP_PE_A_8KHZ[AUP_PE_LOWPSS_NSEC][3] = {
    {1.000000e+00f, -8.445478e-01f, 2.453003e-01f},
    {1.000000e+00f, -5.469711e-01f, 5.010509e-01f},
    {1.000000e+00f, -2.646897e-01f, 7.464574e-01f},
    {1.000000e+00f, -1.074159e-01f, 8.912371e-01f},
    {1.000000e+00f, -4.448528e-02f, 9.702184e-01f}};
const float AUP_PE_G_8KHZ[AUP_PE_LOWPSS_NSEC] = {
    4.165686e-01f, 4.165686e-01f, 4.165686e-01f, 4.165686e-01f, 4.165686e-01f};

#define AUP_PE_PI (3.1415926f)

#define AUP_PE_FEAT_TIME_WINDOW (40)  // in ms
// how much time data to use for cross-correlation calculation
#define AUP_PE_FEAT_MAX_NFRM (12)
#define AUP_PE_TOTAL_NFEAT (55)

#define AUP_PE_ASSUMED_FFT_4_BAND_ENG (80)
const int AUP_PE_BAND_START_INDEX[AUP_PE_NB_BANDS] = {
    // 0  200 400 600 800  1k 1.2 1.4 1.6  2k 2.4 2.8 3.2  4k 4.8 5.6 6.8  8k
    0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 34, 40};
// compensation
const float AUP_PE_BAND_LPC_COMP[AUP_PE_NB_BANDS] = {
    0.8f, 1.f,  1.f,  1.f,       1.f,   1.f,   1.f,  1.f,       0.666667f,
    0.5f, 0.5f, 0.5f, 0.333333f, 0.25f, 0.25f, 0.2f, 0.166667f, 0.173913f};

#define AUP_PE_PITCHMAXPATH_W (0.02f)

typedef struct PE_St_ {
  void* dynamMemPtr;    // memory pointer holding the dynamic memory
  size_t dynamMemSize;  // size of the buffer *dynamMemPtr
  // void* ifftStHdl;  // AgoraFft*
  void* biquadIIRPtr;

  // ---------------------------------------------------------------
  // Static Configuration
  PE_StaticCfg stCfg;

  // ---------------------------------------------------------------
  // Internal Static Config Registers, which are generated from stCfg
  int nBins;
  int procResampleRate;     // AUP_PE_FS / stCfg.procFs
  int minPeriod;            // min. pitch period in procFs
  int maxPeriod;            // max. pitch period in procFs
  int difPeriod;            // maxPeriod - minPeriod
  int inputResampleBufLen;  // length of the resampling output buffer
  int inputQLen;            // MAX(TRAINING_OFFSET_XXXX, hopSz) + hopSz
  int excBufLen;            // PITCH_MAX_PERIOD + hopSz + 1
  int nFeat;                // number of feature frames to use/store
  int estDelay;             // pitch estimate delay in terms of frames
  float dct_table[AUP_PE_NB_BANDS *
                  AUP_PE_NB_BANDS];  // coeff. table of DCT transformation

  // ---------------------------------------------------------------
  // Dynamic Configuration
  PE_DynamCfg dynamCfg;

  // ---------------------------------------------------------------
  // Internal Dynamic Config Registers, which are generated from dynamCfg

  // ---------------------------------------------------------------
  // Variables
  /////////////////////////////////////////////////////////////////////////
  float* inputResampleBuf;  // [inputResampleBufLen]
  int inputResampleBufIdx;

  float* inputQ;           // [inputQLen]
  float* alignedIn;        // [hopSz]
  float* lpcFilterOutBuf;  // [hopSz]

  float* excBuf;  // [excBufLen]
  // excBuf stores the smoothed LPC prediction result
  float* excBufSq;  // [excBufLen]
  // = excBuf.^2

  float lpc[AUP_PE_LPC_ORDER];
  float pitch_mem[AUP_PE_LPC_ORDER];
  float pitch_filt;

  float tmpFeat[AUP_PE_TOTAL_NFEAT];

  int xCorrOffsetIdx;  // the oldest frame's index in xCorr Buffer
  float* xCorrInst;    // [maxPeriod]
  float* xCorr[AUP_PE_FEAT_MAX_NFRM * 2];  // [stHdl->nFeat * 2][maxPeriod + 1]
  // circ-buffer [<--->][...]
  float*
      xCorrTmp[AUP_PE_FEAT_MAX_NFRM * 2];  // [stHdl->nFeat * 2][maxPeriod + 1]
  // temporarily modified version of xCorr

  float frmWeight[AUP_PE_FEAT_MAX_NFRM * 2];
  float frmWeightNorm[AUP_PE_FEAT_MAX_NFRM * 2];
  // normalized version of frmWeight

  // variables for best pitch estimation ....
  /////////////////////////////////////////////////////////////////////////
  float* pitchMaxPathReg[2];  // [2][maxPeriod]

  int* pitchPrev[AUP_PE_FEAT_MAX_NFRM * 2];  // [stHdl->nFeat * 2][maxPeriod]
  float pitchMaxPathAll;
  int bestPeriodEst;

  int voiced;            // whether this frame has voice
  float pitchEstResult;  // the final result storing the estimated pitch freq.
} PE_St;

#endif  // __PITCH_EST_ST_H__



================================================
FILE: src/stft.cc
================================================
//
// Copyright © 2025 Agora
// This file is part of TEN Framework, an open source project.
// Licensed under the Apache License, Version 2.0, with certain conditions.
// Refer to the "LICENSE" file in the root directory for more information.
//
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "stft.h"
#include "stft_st.h"
#include "fftw.h"

// ==========================================================================================
// internal tools
// ==========================================================================================

static int AUP_Analyzer_checkStatCfg(Analyzer_StaticCfg* pCfg) {
  if (pCfg == NULL) {
    return -1;
  }

  if (pCfg->fft_size != 256 && pCfg->fft_size != 512 &&
      pCfg->fft_size != 1024 && pCfg->fft_size != 2048 &&
      pCfg->fft_size != 4096) {
    return -1;
  }

  if (pCfg->win_len <= 0 || pCfg->win_len < pCfg->hop_size ||
      pCfg->win_len > pCfg->fft_size) {
    return -1;
  }

  if (pCfg->hop_size <= 0) {
    return -1;
  }

  return 0;
}

static int AUP_Analyzer_publishStaticCfg(Analyzer_St* stHdl) {
  const Analyzer_StaticCfg* pStatCfg;
  int idx;

  if (stHdl == NULL) {
    return -1;
  }
  pStatCfg = (const Analyzer_StaticCfg*)(&(stHdl->stCfg));

  stHdl->nBins = (pStatCfg->fft_size >> 1) + 1;
  if (pStatCfg->ana_win_coeff != NULL) {
    memcpy(stHdl->windowCoffCopy, pStatCfg->ana_win_coeff,
           sizeof(float) * pStatCfg->win_len);
  } else {
    for (idx = 0; idx < AUP_STFT_MAX_FFTSZ; idx++) {
      stHdl->windowCoffCopy[idx] = 1.0f;
    }
  }
  return 0;
}

static int AUP_Analyzer_resetVariables(Analyzer_St* stHdl) {
  memset(stHdl->dynamMemPtr, 0, stHdl->dynamMemSize);
  return 0;
}

static int AUP_Analyzer_dynamMemPrepare(Analyzer_St* stHdl, void* memPtrExt,
                                        size_t memSize) {
  int inputQMemSz = 0;
  int fftInputBufMemSz = 0;
  int totalMemSize = 0;
  char* memPtr = NULL;

  inputQMemSz = AUP_STFT_ALIGN8(sizeof(float) * (stHdl->stCfg.win_len + 4));
  totalMemSize += inputQMemSz;

  fftInputBufMemSz =
      AUP_STFT_ALIGN8(sizeof(float) * (stHdl->stCfg.fft_size + 4));
  totalMemSize += fftInputBufMemSz;

  // if no external memory provided, we are only profiling the memory
  // requirement
  if (memPtrExt == NULL) {
    return (totalMemSize);
  }

  // if required memory is more than provided, error
  if ((size_t)totalMemSize > memSize) {
    return -1;
  }

  memPtr = (char*)memPtrExt;

  stHdl->inputQ = (float*)memPtr;
  memPtr += inputQMemSz;

  stHdl->fftInputBuf = (float*)memPtr;
  memPtr += fftInputBufMemSz;

  if (((int)(memPtr - (char*)memPtrExt)) > totalMemSize) {
    return -1;
  }

  return (totalMemSize);
}

// ==========================================================================================
// public APIs
// ==========================================================================================

int AUP_Analyzer_create(void** stPtr) {
  Analyzer_St* tmpPtr;

  if (stPtr == NULL) {
    return -1;
  }

  *stPtr = (void*)malloc(sizeof(Analyzer_St));
  if (*stPtr == NULL) {
    return -1;
  }
  memset(*stPtr, 0, sizeof(Analyzer_St));

  tmpPtr = (Analyzer_St*)(*stPtr);

  tmpPtr->dynamMemPtr = NULL;
  tmpPtr->dynamMemSize = 0;

  tmpPtr->stCfg.win_len = 768;
  tmpPtr->stCfg.hop_size = 256;
  tmpPtr->stCfg.fft_size = 1024;
  tmpPtr->stCfg.ana_win_coeff = NULL;

  return 0;
}

int AUP_Analyzer_destroy(void** stPtr) {
  Analyzer_St* stHdl;

  if (stPtr == NULL) {
    return 0;
  }

  stHdl = (Analyzer_St*)(*stPtr);
  if (stHdl == NULL) {
    return 0;
  }

  if (stHdl->dynamMemPtr != NULL) {
    free(stHdl->dynamMemPtr);
  }
  stHdl->dynamMemPtr = NULL;

  free(stHdl);
  (*stPtr) = NULL;

  return 0;
}

int AUP_Analyzer_memAllocate(void* stPtr, const Analyzer_StaticCfg* pCfg) {
  Analyzer_St* stHdl = NULL;
  Analyzer_StaticCfg localStCfg;
  int totalMemSize = 0;

  if (stPtr == NULL || pCfg == NULL) {
    return -1;
  }
  stHdl = (Analyzer_St*)(stPtr);

  memcpy(&localStCfg, pCfg, sizeof(Analyzer_StaticCfg));
  if (AUP_Analyzer_checkStatCfg(&localStCfg) < 0) {
    return -1;
  }

  memcpy(&(stHdl->stCfg), &localStCfg, sizeof(Analyzer_StaticCfg));

  // 1st. publish internal static configuration registers
  if (AUP_Analyzer_publishStaticCfg(stHdl) < 0) {
    return -1;
  }

  // 4th: check memory requirement
  totalMemSize = AUP_Analyzer_dynamMemPrepare(stHdl, NULL, 0);
  if (totalMemSize < 0) {
    return -1;
  }

  // 5th: allocate dynamic memory
  if ((size_t)totalMemSize > stHdl->dynamMemSize) {
    if (stHdl->dynamMemPtr != NULL) {
      free(stHdl->dynamMemPtr);
      stHdl->dynamMemSize = 0;
    }
    stHdl->dynamMemPtr = malloc(totalMemSize);
    if (stHdl->dynamMemPtr == NULL) {
      return -1;
    }
    stHdl->dynamMemSize = totalMemSize;
  }
  memset(stHdl->dynamMemPtr, 0, stHdl->dynamMemSize);

  // 6th: setup the pointers/variable
  if (AUP_Analyzer_dynamMemPrepare(stHdl, stHdl->dynamMemPtr,
                                   stHdl->dynamMemSize) < 0) {
    return -1;
  }

  return 0;
}

int AUP_Analyzer_init(void* stPtr) {
  Analyzer_St* stHdl;

  if (stPtr == NULL) {
    return -1;
  }
  stHdl = (Analyzer_St*)(stPtr);

  if (AUP_Analyzer_resetVariables(stHdl) < 0) {
    return -1;
  }

  return 0;
}

int AUP_Analyzer_getStaticCfg(const void* stPtr, Analyzer_StaticCfg* pCfg) {
  const Analyzer_St* stHdl;

  if (stPtr == NULL || pCfg == NULL) {
    return -1;
  }
  stHdl = (const Analyzer_St*)(stPtr);

  memcpy(pCfg, &(stHdl->stCfg), sizeof(Analyzer_StaticCfg));

  return 0;
}

int AUP_Analyzer_proc(void* stPtr, const Analyzer_InputData* pIn,
                      Analyzer_OutputData* pOut) {
  Analyzer_St* stHdl = NULL;
  int hopSz, fftSz, winLen, nBins;
  int idx = 0;

  if (stPtr == NULL || pIn == NULL || pIn->input == NULL || pOut == NULL ||
      pOut->output == NULL) {
    return -1;
  }
  stHdl = (Analyzer_St*)(stPtr);

  if (pIn->iLength != stHdl->stCfg.hop_size ||
      pOut->oLength < stHdl->stCfg.fft_size) {
    return -1;
  }
  hopSz = stHdl->stCfg.hop_size;
  fftSz = stHdl->stCfg.fft_size;
  nBins = (fftSz >> 1) + 1;
  winLen = stHdl->stCfg.win_len;

  memset(pOut->output, 0, sizeof(float) * pOut->oLength);
  memmove(stHdl->inputQ, stHdl->inputQ + hopSz,
          sizeof(float) * (winLen - hopSz));
  memcpy(stHdl->inputQ + (winLen - hopSz), pIn->input, sizeof(float) * hopSz);

  if (stHdl->stCfg.ana_win_coeff != NULL) {
    for (idx = 0; idx < winLen; idx++) {
      stHdl->fftInputBuf[idx] = stHdl->inputQ[idx] * stHdl->windowCoffCopy[idx];
    }
  } else {
    for (idx = 0; idx < winLen; idx++) {
      stHdl->fftInputBuf[idx] = stHdl->inputQ[idx];
    }
  }
  for (; idx < fftSz; idx++) {
    stHdl->fftInputBuf[idx] = 0;
  }

  if (fftSz == 256) {
    AUP_FFTW_r2c_256(stHdl->fftInputBuf, pOut->output);
  } else if (fftSz == 512) {
    AUP_FFTW_r2c_512(stHdl->fftInputBuf, pOut->output);
  } else if (fftSz == 1024) {
    AUP_FFTW_r2c_1024(stHdl->fftInputBuf, pOut->output);
  } else if (fftSz == 2048) {
    AUP_FFTW_r2c_2048(stHdl->fftInputBuf, pOut->output);
  } else if (fftSz == 4096) {
    AUP_FFTW_r2c_4096(stHdl->fftInputBuf, pOut->output);
  }
  AUP_FFTW_InplaceTransf(1, fftSz, pOut->output);
  AUP_FFTW_RescaleFFTOut(fftSz, pOut->output);

  return 0;
}



================================================
FILE: src/stft.h
================================================
//
// Copyright © 2025 Agora
// This file is part of TEN Framework, an open source project.
// Licensed under the Apache License, Version 2.0, with certain conditions.
// Refer to the "LICENSE" file in the root directory for more information.
//
#ifndef __STFT_H__
#define __STFT_H__

#include <stddef.h>
#include <stdint.h>
#include <stdio.h>

#define AUP_STFT_MAX_FFTSZ (4096)

// Configuration Parameters, which impacts dynamic memory occupation, can only
// be set during allocation
typedef struct Analyzer_StaticCfg_ {
  int win_len;
  int hop_size;
  int fft_size;
  const float* ana_win_coeff;
} Analyzer_StaticCfg;

// Spectrum are assumed to be generated with time-domain samples in [-32768,
// 32767] WITH LEC blowup protection Note: the input timeSignal has to be in
// 16KHz sampling-rate
typedef struct Analyzer_InputData_ {
  float* input;
  int iLength;
} Analyzer_InputData;

typedef struct Analyzer_OutputData_ {
  float* output;  // externally provided buffe
  int oLength;    // externally provided buffer length
} Analyzer_OutputData;

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************
 * AUP_Analyzer_create(...)
 *
 * This function creats a state handler from nothing, which is NOT ready for
 * processing
 *
 * Input:
 *
 * Output:
 *      - stPtr         : buffer to store the returned state handler
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Analyzer_create(void** stPtr);

/****************************************************************************
 * AUP_Analyzer_destroy(...)
 *
 * destroy PE instance, and releasing all the dynamically allocated memory
 *
 * Input:
 *      - stPtr         : buffer of State Handler, after this method, this
 *                        handler won't be usable anymore
 *
 * Output:
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Analyzer_destroy(void** stPtr);

/****************************************************************************
 * AUP_Analyzer_memAllocate(...)
 *
 * This function sets Static Config params and does memory allocation
 * operation, will lose the dynamCfg values
 *
 * Input:
 *      - stPtr         : State Handler which was returned by _create
 *      - pCfg          : static configuration parameters
 *
 * Output:
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Analyzer_memAllocate(void* stPtr, const Analyzer_StaticCfg* pCfg);

/****************************************************************************
 * AUP_Analyzer_init(...)
 *
 * This function resets (initialize) the PE module and gets it prepared for
 * processing
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate
 *
 * Output:
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Analyzer_init(void* stPtr);

/****************************************************************************
 * AUP_Analyzer_getStaticCfg(...)
 *
 * This function get static configuration status from PE module
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate
 *
 * Output:
 *      - pCfg          : configuration content
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Analyzer_getStaticCfg(const void* stPtr, Analyzer_StaticCfg* pCfg);

/****************************************************************************
 * AUP_Analyzer_proc(...)
 *
 * process a single frame
 *
 * Input:
 *      - stPtr         : State Handler which has gone through create and
 *                        memAllocate and reset
 *      - pCtrl         : per-frame variable control parameters
 *      - pIn           : input data stream
 *
 * Output:
 *      - pOut          : output data (mask, highband time-domain gain etc.)
 *
 * Return value         :  0 - Ok
 *                        -1 - Error
 */
int AUP_Analyzer_proc(void* stPtr, const Analyzer_InputData* pIn,
                      Analyzer_OutputData* pOut);

#ifdef __cplusplus
}
#endif
#endif  // __STFT_H__



================================================
FILE: src/stft_st.h
================================================
//
// Copyright © 2025 Agora
// This file is part of TEN Framework, an open source project.
// Licensed under the Apache License, Version 2.0, with certain conditions.
// Refer to the "LICENSE" file in the root directory for more information.
//
#ifndef __STFT_ST_H__
#define __STFT_ST_H__

#include <stdio.h>
#include "stft.h"

#define AUP_STFT_ALIGN8(o) (((o) + 7) & (~7))
#define AUP_STFT_MAX(x, y) (((x) > (y)) ? (x) : (y))
#define AUP_STFT_MIN(x, y) (((x) > (y)) ? (y) : (x))

typedef struct Analyzer_St_ {
  void* dynamMemPtr;    // memory pointer holding the dynamic memory
  size_t dynamMemSize;  // size of the buffer *dynamMemPtr

  // ---------------------------------------------------------------
  // Static Configuration
  Analyzer_StaticCfg stCfg;

  // ---------------------------------------------------------------
  // Internal Static Config Registers, which are generated from stCfg
  int nBins;
  float windowCoffCopy[AUP_STFT_MAX_FFTSZ];

  // ---------------------------------------------------------------
  // Dynamic Configuration

  // ---------------------------------------------------------------
  // Internal Dynamic Config Registers, which are generated from dynamCfg

  // ---------------------------------------------------------------
  // Variables
  float* inputQ;       // [stCfg->win_len + 4]
  float* fftInputBuf;  // [stCfg->fft_size + 4]
} Analyzer_St;

#endif  // __STFT_ST_H__



================================================
FILE: src/ten_vad.cc
================================================
//
// Copyright © 2025 Agora
// This file is part of TEN Framework, an open source project.
// Licensed under the Apache License, Version 2.0, with certain conditions.
// Refer to the "LICENSE" file in the root directory for more information.
//
#include <cassert>
#include "ten_vad.h"
#include "aed_st.h"
#include "aed.h"

static void int16_to_float(const int16_t* inputs, int inputLen, float* output) {
  for (int i = 0; i < inputLen; ++i) {
    output[i] = float(inputs[i]);
  }
}

int ten_vad_create(ten_vad_handle_t* handle, size_t hop_size, float threshold) {
  if (AUP_Aed_create(handle) < 0) {
    return -1;
  }
  Aed_St* stHdl = nullptr;
  Aed_StaticCfg aedStCfg;
  aedStCfg.enableFlag = 1;
  aedStCfg.fftSz = 0;
  aedStCfg.hopSz = hop_size;
  aedStCfg.anaWindowSz = 0;
  aedStCfg.frqInputAvailableFlag = 0;
  stHdl = (Aed_St*)(*handle);
  stHdl->dynamCfg.extVoiceThr = threshold;

  if (AUP_Aed_memAllocate(*handle, &aedStCfg) < 0) {
    return -1;
  }
  if (AUP_Aed_init(*handle) < 0) {
    return -1;
  }
  return 0;
}

int ten_vad_process(ten_vad_handle_t handle, const int16_t* audio_data,
                    size_t audio_data_length, float* out_probability,
                    int* out_flag) {
  if (handle == nullptr || audio_data == nullptr ||
      out_probability == nullptr || out_flag == nullptr) {
    return -1;
  }
  Aed_St* ptr = (Aed_St*)handle;
  assert(audio_data_length == ptr->stCfg.hopSz);
  int16_to_float(audio_data, audio_data_length, ptr->inputFloatBuff);
  Aed_InputData aedInputData;
  Aed_OutputData aedOutputData;
  aedInputData.binPower = NULL;
  aedInputData.hopSz = ptr->stCfg.hopSz;
  aedInputData.nBins = -1;
  aedInputData.timeSignal = ptr->inputFloatBuff;
  int ret = AUP_Aed_proc(handle, &aedInputData, &aedOutputData);
  if (ret == 0) {
    *out_probability = aedOutputData.voiceProb;
    *out_flag = aedOutputData.vadRes;
  }
  return ret;
}

int ten_vad_destroy(ten_vad_handle_t* handle) {
  return AUP_Aed_destroy(handle);
}

const char* ten_vad_get_version(void) { return "1.0"; }


================================================
FILE: testset/testset-audio-01.scv
================================================
testset-audio-01,0.000,0.403,0,0.403,1.204,1,1.204,1.440,0,1.440,2.470,1,2.470,2.929,0,2.929,3.402,1,3.402,3.709,0,3.709,6.617,1,6.617,6.880,0,6.880,8.413,1,8.413,8.902,0,8.902,11.520,1



================================================
FILE: testset/testset-audio-02.scv
================================================
testset-audio-02,0.000,0.192,0,0.192,0.689,1,0.689,0.974,0,0.974,1.416,1,1.416,1.673,0,1.673,2.623,1,2.623,3.069,0,3.069,3.702,1,3.702,4.045,0



================================================
FILE: testset/testset-audio-03.scv
================================================
testset-audio-03,0.000,0.433,0,0.433,2.490,1,2.490,3.052,0,3.052,6.737,1,6.737,7.492,0,7.492,8.000,1,8.000,8.301,0,8.301,10.333,1



================================================
FILE: testset/testset-audio-04.scv
================================================
testset-audio-04,0.000,0.156,0,0.156,2.790,1,2.790,3.608,0,3.608,7.157,1,7.157,7.855,0,7.855,10.333,1



================================================
FILE: testset/testset-audio-05.scv
================================================
testset-audio-05,0.000,0.602,0,0.602,3.679,1,3.679,4.224,0,4.224,5.627,1,5.627,5.991,0,5.991,8.245,1,8.245,9.557,0,9.557,10.333,1



================================================
FILE: testset/testset-audio-06.scv
================================================
testset-audio-06,0.000,0.336,0,0.336,3.139,1,3.139,4.000,0,4.000,6.111,1,6.111,6.363,0,6.363,6.712,1,6.712,7.313,0,7.313,10.333,1



================================================
FILE: testset/testset-audio-07.scv
================================================
testset-audio-07,0.000,0.432,0,0.432,1.798,1,1.798,2.593,0,2.593,3.488,1,3.488,3.605,0,3.605,5.251,1,5.251,5.885,0,5.885,6.651,1,6.651,6.900,0,6.900,7.899,1,7.899,8.440,0



================================================
FILE: testset/testset-audio-08.scv
================================================
testset-audio-08,0.000,0.412,0,0.412,3.355,1,3.355,3.771,0,3.771,5.339,1,5.339,5.707,0,5.707,6.576,1,6.576,6.961,0,6.961,9.429,1,9.429,9.600,0



================================================
FILE: testset/testset-audio-09.scv
================================================
testset-audio-09,0.000,1.745,1,1.745,2.449,0,2.449,3.953,1,3.953,4.802,0,4.802,5.600,1,5.600,5.697,0,5.697,8.399,1,8.399,9.296,0,9.296,10.333,1



================================================
FILE: testset/testset-audio-10.scv
================================================
testset-audio-10,0.000,0.077,0,0.077,1.200,1,1.200,2.102,0,2.102,2.893,1,2.893,3.148,0,3.148,3.645,1,3.645,4.045,0,4.045,4.503,1,4.503,4.624,0,4.624,4.903,1,4.903,5.043,0,5.043,5.675,1,5.675,6.200,0,6.200,7.594,1,7.594,8.029,0,8.029,8.400,1,8.400,8.645,0,8.645,9.238,1,9.238,9.354,0,9.354,10.333,1



================================================
FILE: testset/testset-audio-11.scv
================================================
testset-audio-11,0.000,0.065,0,0.065,2.160,1,2.160,2.558,0,2.558,3.403,1,3.403,4.248,0,4.248,4.500,1,4.500,4.841,0,4.841,8.832,1



================================================
FILE: testset/testset-audio-12.scv
================================================
testset-audio-12,0.000,0.500,0,0.500,1.183,1,1.183,1.500,0,1.500,2.914,1,2.914,3.500,0,3.500,4.317,1,4.317,4.790,0



================================================
FILE: testset/testset-audio-13.scv
================================================
testset-audio-13,0.000,0.505,1,0.505,1.311,0,1.311,3.284,1,3.284,4.595,0,4.595,7.265,1,7.265,7.506,0,7.506,10.128,1,10.128,10.333,0



================================================
FILE: testset/testset-audio-14.scv
================================================
testset-audio-14,0.000,0.261,0,0.261,1.500,1,1.500,2.000,0,2.000,4.745,1,4.745,5.117,0,5.117,6.500,1,6.500,6.805,0



================================================
FILE: testset/testset-audio-15.scv
================================================
testset-audio-15,0.000,0.490,0,0.490,2.532,1,2.532,2.859,0,2.859,3.577,1,3.577,3.951,0,3.951,4.600,1,4.600,4.736,0



================================================
FILE: testset/testset-audio-16.scv
================================================
testset-audio-16,0.000,0.262,0,0.262,2.515,1,2.515,3.290,0,3.290,5.173,1,5.173,5.686,0,5.686,10.000,1,10.000,10.240,0



================================================
FILE: testset/testset-audio-17.scv
================================================
testset-audio-17,0.000,0.519,0,0.519,2.371,1,2.371,2.683,0,2.683,3.595,1,3.595,3.880,0



================================================
FILE: testset/testset-audio-18.scv
================================================
testset-audio-18,0.000,0.973,1,0.973,1.143,0,1.143,3.302,1,3.302,3.847,0,3.847,4.483,1,4.483,5.365,0,5.365,6.250,1,6.250,6.326,0,6.326,7.139,1,7.139,7.296,0



================================================
FILE: testset/testset-audio-19.scv
================================================
testset-audio-19,0.000,0.355,0,0.355,1.161,1,1.161,1.570,0,1.570,5.421,1,5.421,6.378,0,6.378,9.000,1,9.000,9.240,0



================================================
FILE: testset/testset-audio-20.scv
================================================
testset-audio-20,0.000,0.597,0,0.597,2.512,1,2.512,2.893,0,2.893,5.275,1,5.275,5.993,0,5.993,9.050,1,9.050,9.388,0,9.388,10.333,1



================================================
FILE: testset/testset-audio-21.scv
================================================
testset-audio-21,0.000,0.559,0,0.559,1.836,1,1.836,2.116,0,2.116,2.966,1,2.966,3.430,0



================================================
FILE: testset/testset-audio-22.scv
================================================
testset-audio-22,0.000,1.268,0,1.268,3.418,1,3.418,3.807,0,3.807,4.443,1,4.443,4.639,0,4.639,7.940,1,7.940,8.744,0,8.744,9.213,1,9.213,9.845,0,9.845,10.512,1,10.512,11.523,0,11.523,12.858,1,12.858,13.069,0,13.069,13.880,1,13.880,14.080,0



================================================
FILE: testset/testset-audio-23.scv
================================================
testset-audio-23,0.000,0.354,0,0.354,1.951,1,1.951,2.501,0,2.501,4.671,1,4.671,4.992,0



================================================
FILE: testset/testset-audio-24.scv
================================================
testset-audio-24,0.000,0.468,0,0.468,0.843,1,0.843,1.384,0,1.384,4.843,1,4.843,5.053,0,5.053,5.833,1,5.833,6.440,0



================================================
FILE: testset/testset-audio-25.scv
================================================
testset-audio-25,0.000,0.514,0,0.514,2.352,1,2.352,2.848,0,2.848,4.869,1,4.869,5.641,0,5.641,7.919,1,7.919,8.520,0,8.520,12.441,1,12.441,12.680,0,12.680,15.297,1,15.297,15.785,0



================================================
FILE: testset/testset-audio-26.scv
================================================
testset-audio-26,0.000,0.144,0,0.144,2.502,1,2.502,3.452,0,3.452,5.617,1,5.617,6.123,0,6.123,8.041,1,8.041,9.245,0,9.245,10.333,1



================================================
FILE: testset/testset-audio-27.scv
================================================
testset-audio-27,0.000,0.374,0,0.374,1.358,1,1.358,1.709,0,1.709,3.070,1,3.070,3.600,0,3.600,4.930,1,4.930,5.410,0,5.410,7.115,1,7.115,8.176,0,8.176,8.590,1,8.590,8.704,0



================================================
FILE: testset/testset-audio-28.scv
================================================
testset-audio-28,0.000,0.107,0,0.107,0.727,1,0.727,0.829,0,0.829,2.037,1,2.037,3.006,0,3.006,5.157,1,5.157,5.800,0,5.800,7.168,1



================================================
FILE: testset/testset-audio-29.scv
================================================
testset-audio-29,0.000,0.192,0,0.192,0.668,1,0.668,0.957,0,0.957,1.764,1,1.764,2.400,0,2.400,4.181,1,4.181,5.170,0,5.170,7.161,1,7.161,7.249,0,7.249,8.907,1,8.907,8.960,0



================================================
FILE: testset/testset-audio-30.scv
================================================
testset-audio-30,0.000,0.245,0,0.245,1.417,1,1.417,1.885,0,1.885,3.148,1,3.148,3.356,0,3.356,4.682,1,4.682,5.791,0,5.791,7.035,1,7.035,7.382,0,7.382,8.934,1,8.934,9.460,0,9.460,10.333,1



================================================
FILE: .github/workflows/test-platforms.yml
================================================
name: Test Platform Detection

on: [push, pull_request]

jobs:
  test-platforms:
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            platform: Linux
            python-version: '3.9'
          - os: ubuntu-latest
            platform: Linux
            python-version: '3.10'
          - os: ubuntu-latest
            platform: Linux
            python-version: '3.11'
          - os: ubuntu-latest
            platform: Linux
            python-version: '3.12'
          - os: macos-latest
            platform: macOS
            python-version: '3.9'
          - os: macos-latest
            platform: macOS
            python-version: '3.10'
          - os: macos-latest
            platform: macOS
            python-version: '3.11'
          - os: macos-latest
            platform: macOS
            python-version: '3.12'
    
    runs-on: ${{ matrix.os }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install system dependencies (Ubuntu)
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y libc++1 libc++abi1
    
    - name: Install dependencies for git clone scenario
      run: |
        pip install -r requirements.txt
        pip install -r examples/requirements.txt
    
    - name: Test git clone scenario
      run: |
        cd examples
        python test.py s0724-s0730.wav output_git_clone.txt
        echo "✅ ${{ matrix.platform }} Python ${{ matrix.python-version }} git clone scenario successful"
    
    - name: Install package
      run: pip install .
    
    - name: Test pip install scenario
      run: |
        python -c "from ten_vad import TenVad; print('✅ ${{ matrix.platform }} Python ${{ matrix.python-version }} pip install import successful')"
        cd examples
        python test.py s0724-s0730.wav output_pip_install.txt
        echo "✅ ${{ matrix.platform }} Python ${{ matrix.python-version }} pip install scenario successful"

